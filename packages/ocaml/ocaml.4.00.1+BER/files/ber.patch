diff -N -u -r ocaml-4.00.1.orig/.depend ocaml-4.00.1/.depend
--- ocaml-4.00.1.orig/.depend	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/.depend	2013-02-20 17:25:22.000000000 +0100
@@ -96,6 +96,8 @@
 typing/stypes.cmi : typing/typedtree.cmi parsing/location.cmi \
     typing/annot.cmi
 typing/subst.cmi : typing/types.cmi typing/path.cmi typing/ident.cmi
+typing/trx.cmi : typing/typedtree.cmi parsing/parsetree.cmi \
+    parsing/longident.cmi parsing/location.cmi parsing/asttypes.cmi
 typing/typeclass.cmi : typing/types.cmi typing/typedtree.cmi \
     parsing/parsetree.cmi parsing/longident.cmi parsing/location.cmi \
     typing/ident.cmi typing/env.cmi typing/ctype.cmi parsing/asttypes.cmi
@@ -240,6 +242,16 @@
 typing/subst.cmx : typing/types.cmx utils/tbl.cmx typing/path.cmx \
     utils/misc.cmx parsing/location.cmx typing/ident.cmx typing/btype.cmx \
     typing/subst.cmi
+typing/trx.cmo : utils/warnings.cmi typing/types.cmi typing/typedtree.cmi \
+    typing/typecore.cmi typing/printtyp.cmi typing/predef.cmi typing/path.cmi \
+    parsing/parsetree.cmi utils/misc.cmi parsing/longident.cmi \
+    parsing/location.cmi typing/ident.cmi typing/env.cmi typing/ctype.cmi \
+    typing/btype.cmi parsing/asttypes.cmi typing/trx.cmi
+typing/trx.cmx : utils/warnings.cmx typing/types.cmx typing/typedtree.cmx \
+    typing/typecore.cmx typing/printtyp.cmx typing/predef.cmx typing/path.cmx \
+    parsing/parsetree.cmi utils/misc.cmx parsing/longident.cmx \
+    parsing/location.cmx typing/ident.cmx typing/env.cmx typing/ctype.cmx \
+    typing/btype.cmx parsing/asttypes.cmi typing/trx.cmi
 typing/typeclass.cmo : utils/warnings.cmi typing/typetexp.cmi \
     typing/types.cmi typing/typedtree.cmi typing/typedecl.cmi \
     typing/typecore.cmi typing/subst.cmi typing/stypes.cmi \
@@ -298,7 +310,7 @@
     typing/ident.cmx typing/env.cmx parsing/asttypes.cmi typing/typedtree.cmi
 typing/typemod.cmo : utils/warnings.cmi typing/typetexp.cmi typing/types.cmi \
     typing/typedtree.cmi typing/typedecl.cmi typing/typecore.cmi \
-    typing/typeclass.cmi typing/subst.cmi typing/stypes.cmi \
+    typing/typeclass.cmi typing/trx.cmi typing/subst.cmi typing/stypes.cmi \
     typing/printtyp.cmi typing/path.cmi parsing/parsetree.cmi \
     typing/mtype.cmi utils/misc.cmi parsing/longident.cmi \
     parsing/location.cmi typing/includemod.cmi typing/ident.cmi \
@@ -307,7 +319,7 @@
     typing/typemod.cmi
 typing/typemod.cmx : utils/warnings.cmx typing/typetexp.cmx typing/types.cmx \
     typing/typedtree.cmx typing/typedecl.cmx typing/typecore.cmx \
-    typing/typeclass.cmx typing/subst.cmx typing/stypes.cmx \
+    typing/typeclass.cmx typing/trx.cmx typing/subst.cmx typing/stypes.cmx \
     typing/printtyp.cmx typing/path.cmx parsing/parsetree.cmi \
     typing/mtype.cmx utils/misc.cmx parsing/longident.cmx \
     parsing/location.cmx typing/includemod.cmx typing/ident.cmx \
@@ -488,19 +500,19 @@
     bytecomp/lambda.cmx typing/ident.cmx typing/env.cmx utils/clflags.cmx \
     typing/btype.cmx parsing/asttypes.cmi bytecomp/translclass.cmi
 bytecomp/translcore.cmo : typing/types.cmi bytecomp/typeopt.cmi \
-    typing/typedtree.cmi bytecomp/translobj.cmi typing/primitive.cmi \
-    typing/predef.cmi typing/path.cmi typing/parmatch.cmi utils/misc.cmi \
-    bytecomp/matching.cmi parsing/longident.cmi parsing/location.cmi \
-    bytecomp/lambda.cmi typing/ident.cmi typing/env.cmi utils/config.cmi \
-    utils/clflags.cmi typing/btype.cmi parsing/asttypes.cmi \
-    bytecomp/translcore.cmi
+    typing/typedtree.cmi bytecomp/translobj.cmi typing/printtyped.cmi \
+    typing/primitive.cmi typing/predef.cmi typing/path.cmi \
+    typing/parmatch.cmi utils/misc.cmi bytecomp/matching.cmi \
+    parsing/longident.cmi parsing/location.cmi bytecomp/lambda.cmi \
+    typing/ident.cmi typing/env.cmi utils/config.cmi utils/clflags.cmi \
+    typing/btype.cmi parsing/asttypes.cmi bytecomp/translcore.cmi
 bytecomp/translcore.cmx : typing/types.cmx bytecomp/typeopt.cmx \
-    typing/typedtree.cmx bytecomp/translobj.cmx typing/primitive.cmx \
-    typing/predef.cmx typing/path.cmx typing/parmatch.cmx utils/misc.cmx \
-    bytecomp/matching.cmx parsing/longident.cmx parsing/location.cmx \
-    bytecomp/lambda.cmx typing/ident.cmx typing/env.cmx utils/config.cmx \
-    utils/clflags.cmx typing/btype.cmx parsing/asttypes.cmi \
-    bytecomp/translcore.cmi
+    typing/typedtree.cmx bytecomp/translobj.cmx typing/printtyped.cmx \
+    typing/primitive.cmx typing/predef.cmx typing/path.cmx \
+    typing/parmatch.cmx utils/misc.cmx bytecomp/matching.cmx \
+    parsing/longident.cmx parsing/location.cmx bytecomp/lambda.cmx \
+    typing/ident.cmx typing/env.cmx utils/config.cmx utils/clflags.cmx \
+    typing/btype.cmx parsing/asttypes.cmi bytecomp/translcore.cmi
 bytecomp/translmod.cmo : typing/types.cmi typing/typedtree.cmi \
     bytecomp/translobj.cmi bytecomp/translcore.cmi bytecomp/translclass.cmi \
     typing/printtyp.cmi typing/primitive.cmi typing/predef.cmi \
@@ -743,11 +755,11 @@
     asmcomp/reloadgen.cmi
 asmcomp/reloadgen.cmx : asmcomp/reg.cmx utils/misc.cmx asmcomp/mach.cmx \
     asmcomp/reloadgen.cmi
-asmcomp/schedgen.cmo : asmcomp/reg.cmi utils/misc.cmi asmcomp/mach.cmi \
-    asmcomp/linearize.cmi asmcomp/cmm.cmi asmcomp/arch.cmo \
+asmcomp/schedgen.cmo : asmcomp/reg.cmi asmcomp/proc.cmi utils/misc.cmi \
+    asmcomp/mach.cmi asmcomp/linearize.cmi asmcomp/cmm.cmi asmcomp/arch.cmo \
     asmcomp/schedgen.cmi
-asmcomp/schedgen.cmx : asmcomp/reg.cmx utils/misc.cmx asmcomp/mach.cmx \
-    asmcomp/linearize.cmx asmcomp/cmm.cmx asmcomp/arch.cmx \
+asmcomp/schedgen.cmx : asmcomp/reg.cmx asmcomp/proc.cmx utils/misc.cmx \
+    asmcomp/mach.cmx asmcomp/linearize.cmx asmcomp/cmm.cmx asmcomp/arch.cmx \
     asmcomp/schedgen.cmi
 asmcomp/scheduling.cmo : asmcomp/schedgen.cmi asmcomp/scheduling.cmi
 asmcomp/scheduling.cmx : asmcomp/schedgen.cmx asmcomp/scheduling.cmi
diff -N -u -r ocaml-4.00.1.orig/Makefile ocaml-4.00.1/Makefile
--- ocaml-4.00.1.orig/Makefile	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/Makefile	2013-02-20 17:25:22.000000000 +0100
@@ -21,6 +21,9 @@
 CAMLOPT=boot/ocamlrun ./ocamlopt -nostdlib -I stdlib -I otherlibs/dynlink
 COMPFLAGS= -strict-sequence -warn-error A $(INCLUDES)
 LINKFLAGS=
+# For debugging
+# COMPFLAGS=-warn-error A -g $(INCLUDES) # NNN
+# LINKFLAGS=-g #NNN
 
 CAMLYACC=boot/ocamlyacc
 YACCFLAGS=-v
@@ -45,6 +48,7 @@
   parsing/syntaxerr.cmo parsing/parser.cmo \
   parsing/lexer.cmo parsing/parse.cmo parsing/printast.cmo
 
+# NNN (trx)
 TYPING=typing/ident.cmo typing/path.cmo \
   typing/primitive.cmo typing/types.cmo \
   typing/btype.cmo typing/oprint.cmo \
@@ -56,6 +60,7 @@
   typing/includemod.cmo typing/typetexp.cmo typing/parmatch.cmo \
   typing/cmt_format.cmo typing/stypes.cmo typing/typecore.cmo \
   typing/typedecl.cmo typing/typeclass.cmo \
+  typing/trx.cmo \
   typing/typemod.cmo
 
 COMP=bytecomp/lambda.cmo bytecomp/printlambda.cmo \
@@ -115,8 +120,11 @@
 
 # Recompile the system using the bootstrap compiler
 all: runtime ocamlc ocamllex ocamlyacc ocamltools library ocaml \
-  otherlibraries ocamlbuild.byte $(CAMLP4OUT) $(DEBUGGER) ocamldoc
-
+	otherlibraries ocamldoc
+# NNNNN otherlibraries ocamldoc
+# NNN The rest is not tried or not yet supported
+#  otherlibraries ocamlbuild.byte $(CAMLP4OUT) $(DEBUGGER) ocamldoc
+# NNN make all && (cd metalib && make clean all) && (make install; cd metalib && make install)
 # Compile everything the first time
 world:
 	$(MAKE) coldstart
@@ -283,6 +291,13 @@
 	cp compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma compilerlibs/ocamltoplevel.cma $(BYTESTART) $(TOPLEVELSTART) $(COMPLIBDIR)
 	cp expunge $(LIBDIR)/expunge$(EXE)
 	cp toplevel/topdirs.cmi $(LIBDIR)
+# NNN typing/trx.ml needs its own interface (since it looks up identifiers
+# in itself)
+# Although typing/trx.cmi is already copied, see above, it is copied
+# into $((COMPLIBDIR). We need trx.cmi in the standard .cmi search path.
+	cp typing/trx.cmi $(LIBDIR)
+# BTW, trx.cmo is part of ocamlcommon.cma
+# NNN end
 	cd tools; $(MAKE) install
 	-cd man; $(MAKE) install
 	for i in $(OTHERLIBRARIES); do \
diff -N -u -r ocaml-4.00.1.orig/asmcomp/cmmgen.ml ocaml-4.00.1/asmcomp/cmmgen.ml
--- ocaml-4.00.1.orig/asmcomp/cmmgen.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/asmcomp/cmmgen.ml	2013-02-20 17:28:45.000000000 +0100
@@ -1710,6 +1710,7 @@
       (Clabel_address lbl,
        Cint(floatarray_header (List.length fields)) :: Cdefine_label lbl ::
        Misc.map_end (fun f -> Cdouble f) fields cont)
+  | Const_csp_value _  -> assert false
 
 and emit_string_constant s cont =
   let n = size_int - 1 - (String.length s) mod size_int in
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/.depend ocaml-4.00.1/ber-metaocaml-100/.depend
--- ocaml-4.00.1.orig/ber-metaocaml-100/.depend	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/.depend	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,19 @@
+metatop.cmi :
+print_code.cmi : runcode.cmi
+reify_type.cmi :
+runcode.cmi :
+trxtime.cmi :
+berstart.cmo :
+berstart.cmx :
+bertop.cmo :
+bertop.cmx :
+print_code.cmo : runcode.cmi print_code.cmi
+print_code.cmx : runcode.cmx print_code.cmi
+reify_type.cmo : reify_type.cmi
+reify_type.cmx : reify_type.cmi
+run_native.cmo :
+run_native.cmx :
+runcode.cmo : runcode.cmi
+runcode.cmx : runcode.cmi
+trxtime.cmo : trxtime.cmi
+trxtime.cmx : trxtime.cmi
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/ChangeLog ocaml-4.00.1/ber-metaocaml-100/ChangeLog
--- ocaml-4.00.1.orig/ber-metaocaml-100/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/ChangeLog	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,41 @@
+January 30, 2013
+	Rewritten trx.ml. Release N100.
+
+January 12, 2013
+	Importing the pretty-printing of code, greatly improved by Jacques
+	Carette.
+
+January 7-12, 2013
+	Beginning the port to OCaml 4.00.1. The basic changes to OCaml
+	are done. Started work on re-writing trx.ml
+
+December 28, 2012
+	Version N004 released
+
+November 8, 2012
+	Eliminating val_level from value_desc. Introducing Env map stage
+	to map an identifier to its stage, if not zero. Several
+	OCaml modules no longer have to be patched.
+	Simplified CSP code, removed a few patches from typecore.
+	SCP now carries strings, native_int, int32, int64 as
+	literal constants. Identifiers in List module are carried
+	by reference.
+
+October 4, 2012
+	Jacques Carette has committed Alain Frisch's patch implementing
+	the let! form proposed by Nicolas Pouillard for monadic
+	programming in Ocaml.
+	http://pauillac.inria.fr/~protzenk/let-bang.html
+	See metalib/test/pythagorian_triples.ml for an example.
+
+January 3, 2011
+	Added metaocamlmktop
+
+December 2010
+	Patch from Fabrice Le Fessant to remove functional values
+	from typing Env. See entry May 5, 2010 in Problems.txt.
+	Generic printing is now part of BER MetaOCaml.
+
+March 1, 2010
+	Version N002 released, based on OCaml 3.11
+
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/Files.txt ocaml-4.00.1/ber-metaocaml-100/Files.txt
--- ocaml-4.00.1.orig/ber-metaocaml-100/Files.txt	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/Files.txt	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,54 @@
+OCaml files affected by the BER MetaOCaml. 
+Search for NNN in each files for concrete changes
+
+./Makefile
+./ocamldoc/Makefile
+
+done	./parsing/lexer.mll
+done	./parsing/parser.mly
+done	./parsing/parsetree.mli
+done	./parsing/printast.ml
+
+done	./bytecomp/lambda.ml	Only adding Const_csp_value
+done	./bytecomp/lambda.mli
+done	./bytecomp/printlambda.ml
+done	./bytecomp/translcore.ml
+done	./bytecomp/symtable.ml
+
+done	./tools/depend.ml
+done	./tools/addlabels.ml
+done	./tools/dumpobj.ml (only printing Const_csp_value)
+done	./tools/ocamlprof.ml
+
+done	./typing/typedtree.mli
+done	./typing/typedtree.ml
+done	./typing/predef.ml
+done	./typing/predef.mli
+
+done    ./typing/printtyped.ml    did not exist before, trivial changes
+done    ./typing/cmt_format.ml    did not exist before, trivial changes
+
+done	./typing/env.mli
+done	./typing/env.ml
+
+done	./typing/typecore.mli
+done	./typing/typecore.ml
+done	./typing/typemod.ml 
+
+done    ./tools/untypeast.ml     did not exist before, trivial changes
+done    ./tools/typedtreeIter.ml did not exist before, trivial changes
+
+
+done	./typing/trx.mli
+done	./typing/trx.ml 
+
+
+		./typing/ident.ml       No longer changed
+		./typing/ident.mli      No longer changed
+		./typing/typeclass.ml   No longer changed
+
+./typing/unused_var.ml  No longer present
+
+
+./asmcomp/cmmgen.ml	Not changed; Const_csp_value will cause fatal error
+			Const_csp_value must not appear in native code
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/INSTALL ocaml-4.00.1/ber-metaocaml-100/INSTALL
--- ocaml-4.00.1.orig/ber-metaocaml-100/INSTALL	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/INSTALL	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,71 @@
+INSTALLATION
+
+You need the source OCaml 4.00.1 distribution, which you can download from
+    http://caml.inria.fr/download.en.html
+See also
+    http://ocaml.org/install.html
+
+1. Download, un-tar the OCaml distribution and configure it as described
+   in its INSTALL file
+
+   For example, in the OCaml distribution directory, do
+
+    ./configure -prefix `pwd` -no-pthread -no-tk
+
+  You may chose any other installation prefix. It is best however
+  to chose the prefix different from that of the standard OCaml installation,
+  so to keep the existing OCaml installation intact.
+
+1a. Update the Makefile in the ber-metaocaml directory
+
+    change CAMLROOT= at the beginning of the ber-metaocaml/Makefile
+    to point to the OCaml distribution directory 
+
+2. Patch the OCaml distribution
+
+   In the ber-metaocaml directory, do
+
+   make patch
+
+
+3. In the OCaml distribution directory, do
+
+    make core
+    make coreboot
+
+    make all
+
+    make -i install
+
+
+4. Build the BER MetaOCaml library, the top-level, and the
+   compilation script
+
+   In the ber-metaocaml directory, do
+
+    make all
+    make install
+
+  The BER MetaOCaml top-level can be started afterwards as
+    $prefix/bin/metaocaml 
+
+  The batch compiler can be run using the command file metaocamlc. 
+
+5. Optionally run sample tests
+   
+   In the ber-metaocaml directory, do
+
+   make test
+   make test-compile
+
+
+Installation of BER MetaOCaml on Windows has not been tested. Original
+MetaOCaml contained the following note about the Windows platform:
+
+      To use MetaOCaml under MS Windows, please do not use "Windows
+      OCaml".  Rather, use the standard OCaml system under cygwin.  If you
+      happened to install the "Windows OCaml" in the past, manually remove
+      some environment variables before you can install the standard system
+      successfully.  To do that, goto START -> Control Panel -> System ->
+      Advance -> Environment variables, and edit the OCAMLLIB variable and
+      remove any entries in that entry.
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/Makefile ocaml-4.00.1/ber-metaocaml-100/Makefile
--- ocaml-4.00.1.orig/ber-metaocaml-100/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/Makefile	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,137 @@
+# Build the BER MetaOCaml library, top-level, and the compiler driver
+# See INSTALL for more detail
+
+# Location of the OCaml distribution directory
+CAMLROOT=../
+
+include $(CAMLROOT)/config/Makefile
+
+RUNTIME=$(CAMLROOT)/boot/ocamlrun
+INCLUDES=-I $(CAMLROOT)/utils \
+	-I $(CAMLROOT)/parsing  -I $(CAMLROOT)/typing -I $(CAMLROOT)/bytecomp \
+	-I $(CAMLROOT)/asmcomp  -I $(CAMLROOT)/driver \
+	-I $(CAMLROOT)/toplevel -I $(CAMLROOT)/stdlib
+COMPILER=$(CAMLROOT)/ocamlc
+CAMLC=$(RUNTIME) $(COMPILER) $(INCLUDES)
+COMPFLAGS=-g -warn-error A -nostdlib
+OPTCOMPILER=$(CAMLROOT)/ocamlopt
+CAMLOPT=$(RUNTIME) $(OPTCOMPILER)
+OPTCOMPFLAGS=-warn-error A -nostdlib
+CAMLDEP=$(CAMLROOT)/boot/ocamlrun $(CAMLROOT)/tools/ocamldep
+
+METALIB=metalib.cma
+METALIBOBJS=runcode.cmo print_code.cmo
+METAOBJS=$(METALIB) bertop.cmo berstart.cmo
+
+all: $(METAOBJS) metaocaml metaocamlc
+
+.SUFFIXES: .mli .ml .cmi .cmo .cmx
+
+.mli.cmi:
+	$(CAMLC) $(COMPFLAGS) -c $<
+
+.ml.cmo:
+	$(CAMLC) $(COMPFLAGS) -c $<
+
+.ml.cmx:
+	$(CAMLOPT) $(OPTCOMPFLAGS) -c $<
+
+$(METALIB): $(METALIBOBJS)
+	$(CAMLC) $(COMPFLAGS) -o $@ -a $(METALIBOBJS)
+
+
+install: metaocaml metaocamlmktop metaocamlc
+	cp runcode.cmi print_code.cmi metalib.cma bertop.cmo berstart.cmo \
+	  $(LIBDIR)
+	cp metaocaml $(BINDIR)/metaocaml$(EXE)
+	cp metaocamlmktop $(BINDIR)/metaocamlmktop$(EXE)
+	cp metaocamlc $(BINDIR)/metaocamlc$(EXE)
+
+metaocaml: $(METAOBJS) $(CAMLROOT)/compilerlibs/ocamlcommon.cma
+# $(CAMLROOT)/tools/ocamlmktop \
+# -o $@ $(METALIB) bertop.cmo berstart.cmo
+	$(CAMLC) -nostdlib -linkall \
+	$(CAMLROOT)/compilerlibs/ocamlcommon.cma \
+	$(CAMLROOT)/compilerlibs/ocamlbytecomp.cma \
+	$(CAMLROOT)/compilerlibs/ocamltoplevel.cma \
+	-o $@ $(METALIB) bertop.cmo berstart.cmo \
+	$(CAMLROOT)/toplevel/topstart.cmo
+
+
+
+clean::
+	rm -f metaocaml
+
+metaocamlmktop: metaocamlmktop.tpl metaocaml
+	sed -e 's|%%BINDIR%%|$(BINDIR)|' metaocamlmktop.tpl > metaocamlmktop
+	chmod +x metaocamlmktop
+
+clean::
+	rm -f metaocamlmktop
+
+metaocamlc: metaocamlc.tpl metaocaml
+	sed -e 's|%%BINDIR%%|$(BINDIR)|' metaocamlc.tpl > metaocamlc
+	chmod +x metaocamlc
+
+clean::
+	rm -f metaocamlc
+
+clean::
+	rm -f *.cm* *.o *.a
+	rm -f test/*.cm* test/*.o
+	rm -f *~
+#	cd gprint && $(MAKE) CAMLROOT=../$(CAMLROOT) clean
+
+test:
+	TERM=dumb $(BINDIR)/metaocaml < test/trivial.ml > trivial.out && \
+	diff -u trivial.out trivial.ref
+	TERM=dumb $(BINDIR)/metaocaml < test/simple.ml > simple.out && \
+	diff -u simple.out simple.ref
+	$(BINDIR)/metaocaml test/simple_true.ml
+	$(BINDIR)/metaocaml test/quick_test.ml
+	$(BINDIR)/metaocaml test/test21.ml
+	$(BINDIR)/metaocaml test/pythagorian_triples.ml
+#	$(BINDIR)/metaocaml test/t4.ml
+#	cd gprint && $(MAKE) CAMLROOT=../$(CAMLROOT) MOCAMLTOP="../metaocaml -I .." testv_top
+#	cd gprint && $(MAKE) CAMLROOT=../$(CAMLROOT) vgprint_top
+
+test-compile:
+	$(BINDIR)/metaocamlc -o simple_true test/simple_true.ml
+	./simple_true
+# 	$(BINDIR)/metaocamlc -o quick_test test/quick_test.ml
+# 	./quick_test
+	$(BINDIR)/metaocamlc -dparsetree -drawlambda -dinstr -c test/test21.ml
+	$(BINDIR)/metaocamlc -c test/t4types.mli && \
+	cp test/t4types.cmi . # .cmi file should be where the executable is
+	$(BINDIR)/metaocamlc -o t4 -I test/ test/t4.ml
+	./t4
+	$(BINDIR)/metaocamlc -o pt test/pythagorian_triples.ml
+	./pt
+#	cd gprint && $(MAKE) CAMLROOT=../$(CAMLROOT) vgprint
+
+clean::
+	rm -f simple_true quick_test t4 pt trivial.out simple.out
+
+# Patch the OCaml distribution
+patch:
+	cp -p patches/trx.ml $(CAMLROOT)/typing/
+	cp -p patches/trx.mli $(CAMLROOT)/typing/
+#	patch -p0 -d $(CAMLROOT) < patches/patch
+	patch -p1 -d $(CAMLROOT) < patches/patch
+
+# Create the patch set
+makepatch:
+	cp -p $(CAMLROOT)/typing/trx.ml patches/
+	cp -p $(CAMLROOT)/typing/trx.mli patches/
+	sh ./build_patch.sh > patches/patch
+
+# metaocamlopt: stdlib/metanative.cmxa tools/metaocamlopt.tpl 
+# 	sed -e 's|%%BINDIR%%|$(BINDIR)|' tools/metaocamlopt.tpl > metaocamlopt
+# 	chmod +x metaocamlopt
+
+include .depend
+
+depend:
+	$(CAMLDEP) *.mli *.ml > .depend
+
+.PHONY: all test clean patch makepatch depend test-compile install
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/NOTES.txt ocaml-4.00.1/ber-metaocaml-100/NOTES.txt
--- ocaml-4.00.1.orig/ber-metaocaml-100/NOTES.txt	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/NOTES.txt	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,580 @@
+			BER MetaOCaml
+
+* Main differences from the original MetaOCaml
+
+** Substantial changes
+
+ -- Constructor restriction: all data constructors and record labels 
+ used within brackets must come from the types that are declared in 
+ separately compiled modules.
+
+ -- Scope extrusion check: attempting to build code values with
+ unbound or mistakenly bound variables (which is possible with
+ mutation or other effects) is caught early, raising an exception
+ with good diagnostics.
+
+ -- Introduced the type 'a cde of closed code values -- in preparation
+ for removing run from the `kernel' and moving it to a user-level
+ library, see below.
+
+ -- In OCaml 4.00.1 , the Core type checker was changed to use
+ type_expect. This generates better error messages. Therefore, the type
+ checking of brackets, escape, run and CSP was re-written accordingly,
+ to propagate expectations down. For example, <e> is expected to have
+ the type of (clsfier, ty) code where e has is expected to have the
+ type ty.
+
+ -- The main MetaOCaml kernel module, trx.ml, has been completely
+ re-written. Many algorithms were changed. For example, the traversal
+ of the Typedtree looking for brackets to replace is completely
+ re-written. Now we maintain sharing as much as possible. If the tree
+ has no brackets, it is returned as it was.  Previously, it was copied.
+
+ -- Applications with labeled arguments are supported now.
+
+ -- The problem with first-class polymorphism (records with polymorphic
+ fields inside brackets) has fixed itself. See the file
+ tests/simple.txt. Therefore, we can really remove run from the core
+ of MetaOCaml and use the type cde of closed code.
+
+ -- Precise type assignment when building Typedtree nodes (when
+ hand-compiling Parsetree generation)
+   
+ -- Processing of CSP has changed, split into two phases. At
+ compilation time, we know the type of the CSP and decide if values
+ of that type can be lifted. If not, we look at the CSP identifier
+ to decide if the CSP can be referred to by qualified name (that is,
+ the CSP identifier is part of a separately compiled module).
+ If all fails, we generate the call to a quotator that would build
+ the CSP at run-time, when the value to quote becomes known. Overall,
+ the procedure improves the printing of CSP.
+
+
+** Separation into `kernel' and `user-level' code
+
+The kernel modifies (and is part of) the OCaml system. The user-level
+code is in a directory metalib outside the OCaml distribution. The
+user-level code can be changed and expanded without the need to hack
+and re-compile (Meta)OCaml. Changes introduced to future versions of
+OCaml will not generally affect the `user-level' code.
+
+ -- Printing of code values --  AST pretty_printing by Ed Pizzi --
+ is moved to user-level, a dedicated file metalib/print_code.ml.
+ It is now maintained by Jacques Carette. 
+
+ -- Now BER MetaOCaml is built as a custom top-level, using the standard tool
+ ocamlmktop. We register code printers as regular top-level printers
+ of user-defined data types. Therefore, topmain is no longer modified.
+
+ -- Tag elimination is fully removed.
+
+ -- trxtime is moved to metalib.
+
+ -- Offshoring is temporarily removed; it should be re-introduced as
+ a module in metalib, a user-level code.
+
+
+** Engineering changes
+
+ -- All modified lines in the OCaml code are marked by (* NNN *)
+
+ -- There are comments now -- and lots of them
+
+ -- Added very many regression tests (which also work as examples) to test
+ every feature: see test/trivial.ml and test/simple.ml
+
+
+* What part of MetaOCaml can be moved to the OCaml proper
+Suggestions for the OCaml HQ
+
+ -- Merge metalib/print_code.ml and tools/pprintast.ml
+ Both are essentially the same. We could use optional arguments to
+ make the printing extensible and robust to AST changes.
+
+ -- Unify printing functions for various trees and make them
+ prettier. The very same fmt_longident_aux occurs three times in 
+ the OCaml code base (parsing/printast.ml, tools/pprintast.ml,
+ typing/printtyped.ml)
+
+ - Better and modular error handling. Currently, to add a new
+ error, say, to typecore.ml one has to add the error to typecore.mli,
+ make the same addition to typecore.ml, augment the printing function
+ in typecore.ml. To add a new category, one has to augment
+ driver/errors.ml. I have tried a uniform
+      exception Error of (format -> unit)
+ The error carries the function that will print out the error
+ message on the supplied ppf. Handler becomes much more extensible!
+ This approach does seem to work out.
+
+ -- On one hand, it is tempting to eliminate Const_csp_value. There
+ will no longer be a need to modify the code generator (in bytecomp/).
+ On the other hand, Const_csp_value does make sense as a structured
+ constant. Consider a constant that refers to a big array, or even 
+ array in ancient. Representing such constant in a Parsetree as a
+ string is ungainly. Syntactic extensions in particular could use
+ Const_csp_value.
+
+
+* Further plans
+
+** Get rid of .! as a kernel form
+
+The syntax .! may remain, but only as syntax. The parser would just 
+expand .! x  to {Trx.cde = x}. To really run the code, we would write
+    Run.run .! .<1>.
+Incidentally, we can have Run.run_bytecode and Run.run_native.
+Since it is possible now to dynamically load native code into
+bytecode, we can separate the mode of running the generated code
+(bytecode/native) from the mode of running the generator.
+
+We don't have to add the record 'a cde to predef. We can add it to
+Trx. The only drawback is that pretty-printer may print {cde = x} with
+the Trx qualification. But it is easy to adjust the pretty-printer to
+omit the Trx qualification.
+
+Then BER MetaOCaml becomes BE MetaOCaml?
+
+** Optimize the construction of code values (Parsetree)
+
+When the bracket expression is run, it produces the Parsetree that
+represents the code. The tree is constructed at run-time.  In some
+cases the Parsetree can be constructed at compile time, in
+trx.ml. A constant like <1> is such a case, when we can immediately
+construct the Parsetree: Pexp_constant (Constant_int 1).  After we
+construct the Parsetree at compile time, we use CSP to pass it over to
+run-time. When run, the program will use the compiled constant. This
+mechanism of building Parsetree at compile-time whenever possible is
+one of the large differences from the previous versions of MetaOCaml.
+
+This approach can be extended, by constructing large Parsetree
+subtrees at compile time, and passing them as CSP. See ``TODO: an
+optimization idea. Consider <assert e> as a typical expression.'' in
+trx.ml
+
+** Improve processing CSP
+
+When lifting int, bool, etc. values, we generate calls to run-time
+functions like lift_constant_int to do the Parsetree generation. In
+the future we should `inline' those functions -- that is, obtain the
+Typedtree for them and use the tree for building Texp_apply.
+
+Lists, arrays, option types of liftable types are themselves
+liftable. We can lift many more types. For arrays, check their length.
+If the array is short, it should be lifted. For long arrays, building
+a CSP is better (although it make take a bit longer since we will have
+to invoke dyn_quote at run-time).
+
+** Minimize changes to OCaml
+
+Strictly speaking, we don't need to change typedtree or parsetree. We
+can just add functions with distinguished names.  And add printers and
+add to the type checker. It helps if OCaml added one node to parsetree
+Pexp_extension and a similar node to typed tree. The user may register
+extensions, invoked by the type checker, printer, etc.  to type check
+the node.
+
+** Type-checking of run
+Type-checking of run  (in typing/typecore.ml) can be done differently,
+using polymorphic/universally quantified variables (Tpoly/Tunivar)
+
+One may think that we can pre-process the ParseTree before we hand it
+over to the type-checker, replacing Pexp_constant that occurs within
+the brackets with a node Pexp_apply "mk_constant", etc. However, we
+have problems with generalizing second-stage let. Since the let-form
+will be replaced with a function call, generalization won't be
+performed!
+
+** Search for TODO in trx.ml
+
+* Installation notes
+When linking the first time, beware!
+Since we added to predef.ml[i], we have changed the timestamps of the
+pre-defined identifiers and exceptions, and so created inconsistency
+with respect to the bootstrap compiler. So, when compiling the system
+the first time, after applying the patches to OCaml, do
+    make core
+    make coreboot
+    make all
+
+configuration line
+./configure -prefix /home/oleg/Cache/ncaml4/ -no-tk -no-pthread
+-no-camlp4 -no-graph
+
+
+* Old Future work
+
+** The problem of the constructor environment (signature)
+
+Why typecore.ml has so many changes.
+A bracket expression .< e >. is typechecked once, then it is turned
+into expression that builds, at run-time, the AST for e. When we run
+the code expression, MetaOCaml type-checks the AST -- essentially
+type-checking e the second time around, at a different level this
+time. The second type-checking certainly occurs in a different
+environment -- specifically, in a different constructor and label
+environment. The constructors and labels that have been in effect when
+e is first type-checked may be re-defined when e is type-checked the
+second time.
+
+Therefore, we remember, in the fields pexp_ext and ppat_ext the typed
+tree of the expression resulting from the original type-checker
+run. When we type-check the expression the second time, we keep the
+constructor descriptors resolved from the first time around (yet we
+re-typecheck the arguments of the record and the constructed
+expression: for the sake of staging constructs and CSP, which are
+demoted. After all, the second type-checking occurs at a different
+level).
+
+Currently, MetaOCaml adds pexp_ext and ppat_ext fields to ParseTree,
+to store ref to the type of the node. We only need this information
+for nodes of the variant and record types (see typecore). We don't
+need to store anything for literals, and other irrelevant nodes.
+Furthermore, we don't need to store anything for records and variants
+that are defined in Pervasives (or stdlib).  The next approximation:
+we don't need to store any type information if the type is a
+variant/record defined in another module (that is, qualified with the
+name of another module) -- provided that the corresponding .cmi is
+available at run-time, to the run-time compiler.
+
+What pexp_ext and ppat_ext really need to store? Can they just store
+constructor, labels, probably types and classes (but not values) maps
+from Env.t? (We need to force the maps: they have lazy components).
+We can bracket only expressions: therefore, staged code, when
+typechecked again, cannot modify the constructor, label etc maps
+from the environment. Well, there is always
+     <let module M = struct type foo = Foo ... end in ...>
+but it is not clear if we want to support this. 
+
+It would be great to find a way not not add fields to Parsetree such
+as pexp_ext and ppat_ext. The latter causes too many modifications, in
+all the places where such records are constructed. Could we store the
+_ext fields in a parallel map? How to garbage-collect them though? It
+would be great if the only cases where ppat_ext and pext_ext mattered
+where the cases of identifiers (so we can use Lident as a key).
+Incidentally, the type t in env.ml is a collection of various maps.
+Perhaps that's the place to store pexp_ext information for
+identifiers. Here is an idea: Think of replacing pexp_ext and ppat_ext
+with an extra field in location record. Location is almost always used
+as an abstract type.  Thus when extending the concrete type of
+Location.t, little code needs to be patched.
+
+Here is the idea how to simplify trx code. As we discussed earlier,
+the code expression produces Parsedtree, which contains only the names
+of the constructors. We need to know the constructor description.  In
+the regular type-checking, all this information can be found in the
+environment, placed there by data type declarations. When we invoke
+the type checker at run time (as part of running the code), there are
+no data declarations available. After all, a code expression contains
+only expression rather than declarations. Currently, we stash away the
+whole environment inside the fake parsetree.  What we can do: during
+the first type-checking, determine is a particular constructor name is
+pre-defined or user-defined. If a constructor name is not global,
+generate a long identifier of the form Lxxxx.real_name where Lxxxx is
+some random string. Maintain a new environment and store in it the
+association of that Lxxxx with the constructor description (which we
+can get from Env.t). Once we finish type-checking, attach the new env
+as part of the code value; perhaps each code value should have the
+field for the environment for constructor description, exception
+description, label and method description.  When we run the code, add
+this associated env to the env of the type-checker. We don't need to
+care of any time-stamps.  Since the parsed tree contains unique names
+anyway, like Lxxxxx, there is no chance of name clashes. Perhaps the
+synthesized constructor environment could be saved in the .cmo file
+(along with import and other such data)?
+
+*** A new idea
+
+In general, a code value should be a pair (ParseTree, CtorEnv).  An
+escape (splice) should merge the CtorEnv parts. So a code value is a
+closure with respect to a signature for type and data constructors. In
+a sense, lambda-a gives us that, if we consider type declarations as
+let-expressions (lambda-a has big lambda).
+
+Actually, OCaml 3.12 already has a similar facility: local open.
+So, a code value should be a parse tree expression of the form
+    let module M = struct 
+                    declaration of needed constructors, labels,
+		    exceptions
+                    let res = <expr>
+    in M.res
+Splice should merge such modules, performing renames in case
+of identically named constructors.
+
+See env.ml (and mtype.ml) for functions to export Env.t as a signature
+(and to merge an old signature with the current Env.t -- open).
+There is code for renaming and qualifying all identifiers by a path.
+So, when we generate the code for bracket, maintain the list of
+constructors used in the code. Then build the declarations.
+
+Since we won't store the env any more (as part of pexp_ext, ppat_ext),
+we don't need the lazy transformation of env.ml and we don't need
+to maintain extra time-stamps (which we currently do). The generated
+code becomes self-contained, with all needed constructors, which
+are explicit -- rather than hidden in *_ext fields.
+
+As the initial approximation, to make porting to OCaml 4, require
+that all constructors to be in separate modules (the corresponding
+.cmi must be available at run-time, and, properly, we should record
+their CRC). Later on, save the needed .cmi as part of the code (for
+native compilation). Later, we eliminate that restriction by
+building proper declarations. [BER MetaOCaml N100 implements this
+idea.]
+
+A code value should be a module, struct type t = ... let term = xxx
+end.  That nodule defines all type constructors/types that are used
+within the code, except for the built-ins or pervasives. We should
+define these types along with equalities (sharing constraints) so that
+the code and the main program use consistent types.That solves the
+problem of redeclarations (we introduce a nested struct).  Also, we
+automatically obtain the desired property that a code value is a
+closure with respect to the constructor env.
+
+type foo = Foo
+let x = <Foo>
+type bar = Foo
+let y = <Foo>
+
+type foo1 = Foo1
+let x = quote (struct type t1 = foo1 = Foo
+   let res = Foo end)
+
+It has to be a functor, from the env. We rely on contra-variance (env
+may contain many more types), Since the env should only contain
+types, its run-time representation is empty.  But splicing is a bit
+more expensive since we have to apply env. All identifiers in the env
+are alpha-renamed to contain the explicit tstamp.  The main benefit is
+that we don't need to modify the AST to contain the type env.
+
+An idea for the constructor calculus
+
+Datatype definitions can be represented in System Fw:
+        data T = Foo | Bar
+
+is equivalent to the type T, functions foo :: T and bar :: T and 
+the deconstructor T -> w -> w -> w. The body of the program in the scope of
+T can be represented as
+  Lam(t) lam(foo:t) lam(bar:t) lam(decon:forall w. t->w->w) ...
+
+Assume that Lam and lam are special in that they bind `special
+identifiers' (constructors) and that we can evaluate under such
+lam. If c is a special identifier, then c v is a value. (check CRWL; I
+think we don't need to do anything about not-fully-applied
+constructors, which are values anyway.)  We need Fw so we can bind
+types of the kind *->*, etc. needed for defining list-like types. The
+main advantage: we don't need to introduce constants, and we get the
+regular scoping, substitution rules. So, constants (constructors) and
+identifiers are pretty much the same, with respect to alpha renaming
+and substitution.  That simplifies the calculus as we introduce
+staging.
+
+
+** Other
+Think about moving the predefined type ('a,'b) code from
+typing/predef.ml[i] into trx.mli Do we really need the code type
+predefined? Can we consider it pervasive instead? There would be no
+need to modify typecore to add a special rule to process the code
+type.
+
+A conversation with Chung-chieh Shan brought up another issue:
+generalization is not at all clear staged languages. Consider
+    .<let f = fun x -> x in (f 1, f true)>.
+The code is OK. When we type-check it at level 0, we have to
+type-check the body of the bracket at level 1
+	   let f = fun x -> x in (f 1, f true)
+and it is certainly OK, since f is generalizable as being bound to a
+value. Now consider this:
+    .<let f = .~(.<fun x -> x>.) in (f 1, f true)>.
+Is this OK? MetaOCaml says yes. What about
+    .<let f = .~((fun y -> y) .<fun x -> x>.) in (f 1, f true)>.
+Now it does not generalize.
+For a good reason! The following, for example, generalizes
+let lift x = .<x>.;;
+let fff =
+	.<let foo = fun x -> let t = .~(lift (ref [])) in 
+	(match !t with [] -> t := [x]; x | [y] -> t := [x]; y) in
+	(foo ("xxx"), foo(true), foo([1,2]))>.;;
+and gives the Bus error. See more description and proposed restriction
+in the file Problems.txt, the entry as of June 11, 2010.
+
+Other interesting cases:
+let id y = y in .<let f = fun x -> id x in (f 1, f true)>.;;
+
+Interesting case:
+let id y = y in .<let f = fun x -> id y in (f 1, f true)>.;;
+let id y = y in .<let f = fun x -> id x in (f 1, f true)>.;;
+
+
+
+
+* Done in N004 (Nov 7, 2012)
+Check to see if val_level field in the value_description structure can
+be eliminated. Quite a few patches become unnecessary.  We should
+associate the staging level with identifiers rather than values.  We
+should introduce a new map in Env.t that maps identifiers to levels.
+Global identifiers and identifiers appearing in structures and
+signatures are not in the domain of that map and are implicitly
+0-level. We don't support module expressions in the staged code.
+
+We have done that.
+
+Adding a new Texp_ident (see typecore etc) should be accompanied by
+Env.add_level ident !global_level But we don't support staging for
+objects.
+
+Before
+
+# let x = 1 in .<x>.;;
+- : ('a, int) code = .<1>.
+# let x = [] in .<x>.;;
+- : ('a, 'b list) code = .<(* cross-stage persistent value (as id: x) *)>.
+# let x = None in .<x>.;;
+- : ('a, 'b option) code = .<(* cross-stage persistent value (as id: x) *)>.
+# let x = "abc" in .<x>.;;
+- : ('a, string) code = .<(* cross-stage persistent value (as id: x) *)>.
+# let x = 123l in .<x>.;;
+- : ('a, int32) code = .<(* cross-stage persistent value (as id: x) *)>.
+
+# .<Array.get>.;;
+- : ('a, 'b array -> int -> 'b) code = .<Array.get>.
+# .<List.nth>.;;
+- : ('a, 'b list -> int -> 'b) code =
+.<(* cross-stage persistent value (as id: List.nth) *)>.
+
+Now
+# let x = 1 in .<x>.;;
+- : ('a, int) code = .<1>.
+# let x = [] in .<x>.;;
+- : ('a, 'b list) code = .<(* cross-stage persistent value (as id: x) *)>.
+# let x = None in .<x>.;;
+- : ('a, 'b option) code = .<(* cross-stage persistent value (as id: x) *)>.
+# let x = "abc" in .<x>.;;
+- : ('a, string) code = .<"abc">.
+# let x = 123l in .<x>.;;
+- : ('a, int32) code = .<123>.
+# .<Array.get>.;;
+X: Stage for var is set to implicit 0:Array.get
+- : ('a, 'b array -> int -> 'b) code = .<Array.get>.
+# .<List.nth>.;;
+X: Stage for var is set to implicit 0:List.nth
+- : ('a, 'b list -> int -> 'b) code = .<List.nth>.
+
+More CSP are carried as literals. 
+
+When compiling code expressions, warnings should be disabled since
+they are not informative anyway.  See runcode.ml, the function
+with_disabled_warnings.
+
+
+* Done in N100 (January 2013)
+
+** trx.ml is re-written, and so most of the following has been taken
+care of
+
+In [old] trx.ml, check to see if ident_can_be_quoted and path_to_lid
+can be merged to a single function, following the idea that any path
+made of global/persistent components can be safely converted to lident
+(the time stamps are all zero anyway).  Any such path can be used to
+refer to a CSP by name, since that path persists and is stable. I
+guess it is also important that it is global: we can expect the same
+name available when we compile the code and when we invoke the
+type-checker again at run-time.
+
+In trx.ml, there are notes on CSP, in the comments before mkcsp.  If
+CSP id is long id, (global id), use it as a constant and generate the
+corresponding global ref code. Zero-arity constants such as [] or
+None, when used as CSP, can be included by value, and show as such
+when we print out the code values.  OCaml 3.11 adds annotations for
+identifiers (see typing/annot.mli and search for Annot in
+env.mli). Annot are used for the sake of .annot files. That data could
+be useful to identify CSP that refer to external or global
+identifiers.
+
+** Re-written trx.ml now does more efficient traversal, so most
+of the following has been taken care of
+
+It seems that there is a lot of room for improvement. For example,
+run compiles and type-checks the code expression from scratch.
+Mainly, Trx.structure pre-processes the whole program, each and every
+expression and definition -- even if an expression contains no
+staging forms. That pre-processing re-builds the whole parse tree,
+which is wasteful, and slows down compilation for large programs.
+We should hook escape and bracket processing to the type-checker -- to
+typecore.ml, and be done. We pay for staging only when needed.
+
+I have hooked Trx.trx_structure as a post-processor to
+Typemod.type_structure. Now, top-level drivers (toplevel/toploop.ml,
+driver/compile.ml) no longer have to be modified.  The function
+Typemod.type_structure traverses the whole structure expression,
+invoking typecore.type_exp and other functions.  But Trx.trx_structure
+does a very similar traversal! I have to think how to simplify
+unnecessary traversal and hook trx processing deeper, perhaps within
+typecore.type_exp and typecore.type_binding.  These are the only cases
+that matter...
+
+** Better quotation (which results in better printing of CSP *)
+# let l x = .<x>.;;
+val l : 'a -> ('cl, 'a) code = <fun>  (* Polymorphic! *)
+# l 1;;
+- : ('a, int) code = .<(* cross-stage persistent value (as id: x) *)>.
+# l 1.0;;
+- : ('a, float) code = .<1.>.   (* Now it prints as a constant *)
+
+** Record with polymorphic fields in brackets: problem solved
+
+A new way of running the code and its problems.  Actually, the
+problems are old -- the Trx module cannot handle polymorphic
+values. It erroneously fails to generalize type variables.  Here is
+the illustration of the bug.
+
+# .< {Trx.cde = .<1>.} >.;;
+- : ('a, int Trx.cde) code = .<{Trx.cde = .<1>.}>.
+# .! .< {Trx.cde = .<1>.} >.;;
+# .! .< {Trx.cde = .<1>.} >.;;
+This expression [1 is highlighted]
+has type ('a, int) code but is here used with type
+  ('b, int) code
+
+Exception: Trx.TypeCheckingError.
+
+Since the new way of running relies on the polymorphic values, the
+problem becomes acute.
+Compare:
+# let a1 = .<fun x -> .! .<1>.>.;;
+val a1 : ('a, 'b -> int) code = .<fun x_2 -> .!.<1>.>.
+# let a2 = .! a1;;
+val a2 : 'a -> int = <fun>
+# a2 42;;
+- : int = 1
+
+# let b1 = .<fun x -> Runcode.run {Trx.cde = .<1>.}>.;;
+val b1 : ('a, 'b -> int) code =
+  .<fun x_3 ->
+     (((* cross-stage persistent value (as id: Runcode.run) *))
+       {Trx.cde = .<1>.})>.
+# let b11 = {Trx.cde = b1 };;
+val b11 : ('a -> int) Trx.cde =
+  .<fun x_3 ->
+     (((* cross-stage persistent value (as id: Runcode.run) *))
+       {Trx.cde = .<1>.})>.
+
+# Runcode.run b11;;
+Warning X: this argument will not be used by the function.
+This expression has type ('a, int) code but is here used with type
+  ('b, int) code
+
+Exception: Trx.TypeCheckingError.
+
+Runcode re-typechecks the expression -- and here where the error comes
+in.
+
+One workaround: when trx pre-processes the code first-time around,
+it should detect {Trx.cde = xxx} that appears within quotation, and
+replace it with something else (Parsetree.exp?). After all, the
+type-checking has already happened; when the generated code is run, no
+real check are needed; so we can use the untyped Parsetree at will.
+
+I believe the problem is in the clause `Pexp_record(lid_sexp_list,
+opt_sexp)' of the function type_exp of the file typecore.ml. In the
+conditional branch of (is_type_exp_second_time sexp) being true, we
+may be missing generalization (or forget to introduce fresh type
+variables).
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/ORIGINAL-LICENSE-META ocaml-4.00.1/ber-metaocaml-100/ORIGINAL-LICENSE-META
--- ocaml-4.00.1.orig/ber-metaocaml-100/ORIGINAL-LICENSE-META	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/ORIGINAL-LICENSE-META	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,50 @@
+
+Copyright 2002-2006 
+Walid Taha's research group at Rice University and collaborators
+All Rights Reserved
+
+MetaOCaml is licensed as a patch to the respective distribution of
+OCaml upon which it is based.  Please see OCaml licence for status of
+a patch.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal with the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+Redistributions of source code must retain the above copyright notice,
+this list of conditions and the following disclaimers.
+
+ - Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimers in
+   the documentation and/or other materials provided with the
+   distribution.
+
+ - Neither the names of MetaOCaml, Concoqtion, Rice University, nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this Software without specific prior written permission.
+
+ - Products derived from this software may not be called "MetaOCaml",
+   "MetaOCaml Concoqtion", "Concoqtion", or an extension of these names
+   without prior written permission from the RAP group.
+
+Commercial use is prohibited without prior written permission.
+
+Permissions must be granted by
+
+	Walid Taha (taha@rice.edu)
+	Department of Computer Science
+	Rice University, Houston, TX 77025.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
+HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
+SOFTWARE.
+
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/Problems.txt ocaml-4.00.1/ber-metaocaml-100/Problems.txt
--- ocaml-4.00.1.orig/ber-metaocaml-100/Problems.txt	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/Problems.txt	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,208 @@
+			Open and closed problems
+
+June 11, 2010.
+
+While designing a counter-example, I was too
+successful. The counter-example worked, also for OCaml
+
+let lift x = .<x>.;;
+let fff =
+	.<let foo = fun x -> let t = .~(lift (ref [])) in 
+	(match !t with [] -> t := [x]; x | [y] -> t := [x]; y) in
+	(foo ("xxx"), foo(true), foo([1,2]))>.;;
+
+So, the future-stage lambda should not be considered unexpansive by
+default. We should check the body for escapes. In principle,
+we should also check for CSP -- however MetaOCaml, unlike the
+calculus of PEPM03 paper, permits CSP of only values rather than
+expressions. And we know that we can't have a polymorphic reference
+cell bound to an identifier or as a constant.
+So, we should declare expansive those future-stage lambda whose
+bodies contain expansive escapes (that is, escapes that are not
+manifest code constants such as <0>). We should be careful of multiple-levels
+though; the problem above occurs because ``polymorphic'' reference cell can
+be a value (once created), and can be lifted to code. So, we should
+conservatively regard as potentially expansive a future-stage lambda
+that has expansive escapes to any level.
+
+
+
+May 5, 2010
+Loading test/test21.ml in top-level works fine. However, compiling
+that file gives 
+  Fatal error: exception Invalid_argument("output_value: functional value")
+
+If we pass the flags -drawlambda -dinstr to the compiler, we observe
+that the constants "" and Pervasive.^ are accompanied with
+environments (which are probably useless in that case anyway).
+If the code file has nested modules, it seems the environemnt has
+functional values. Therefore, attempting to serialize such an
+environment fails.
+
+The permanent solution requires re-thinking of building parsetree at run-time
+(see quote_constant in trx.ml)
+We shouldn't probably attach environemnt to contants. Also, we should
+get rid of location information, which is not needed and can be
+confusing.
+
+
+It turns out that the environment indeed contains functional values.
+The patch from Fabrice Le Fessant (who faced a similar problem in
+JoCaml) helped.
+
+
+
+-- Older
+
+
+
+(* CSP issues *)
+let f = fun x -> .<x>.;;
+let a = .<fun y -> .~(f .<y>.)>.;;
+let b = .! a;;
+let c = b 56;;
+let d = .! c;;
+
+let f = fun x -> .<x>.;;
+let a = .<fun y -> .~(f .<.<y>.>.)>.;;
+let b = .! a;;
+let c = b 56;;
+let d = .! c;;
+
+let f = fun x -> .<x>.;;
+let a = .<fun y -> f y>.;;
+let f2 = .! a;;
+let a2 = .<fun y -> .~(f2 .<.<y>.>.)>.;;
+let b = .! a2;;
+let c = b 56;;
+let d = .! c;;
+
+
+(* Type synonyms/aliasing bug: *)
+-- Description: Pattern matching against a value whose type is a type
+synonym, while using the pattern alias (as s) results in a
+type-checking error when applying .! to a piece of code.
+
+-- The smallest example of this bug is:
+type vect = int * int;;
+type state = State of vect;;
+let f state = .<let (State d) as s = .~state in
+               let (u,v) = d in 34>.;;
+let c = f .<State (2,3)>. in .! c;;
+
+-- error: "This expression has type vect but is here used with type 'a * 'b"
+
+-- The piece of code where this exception is raised is the call to
+(type_expect) in the function type_let in typecore.ml.
+
+-- Suspected reasons: The type synonym 'vect' is not unified with 'a *
+'b, which it should be. The problem seems the way that we handle
+environments. When type-checking run, the (initial) environment in
+which it is type-checked does not seem to contain a binding for the
+type vect.
+
+-- General note: This problem seems to be an artifact of how we
+   implement environments. Perhaps we need to deal with these things
+   more systematically.
+
+
+Oct 3, 2006
+ printing of `record with expressions'
+ type recd = {f1 : int; f2 : string};;
+
+ let foo = .<let x = {f1=1; f2="a"} in
+            let y = {x with f1 = 2} in
+            y>.
+ ;;
+
+ produces the output
+  val foo : ('a, recd) code =
+   .<let x_3 = {f1 = 1; f2 = "a"} in let y_4 = {f1 = 2} (x_3) in y_4>.
+
+ The expression "{f1 = 2} (x_3)" obviously can't be right: a record is
+ not a function and can't be applied.
+
+ That is merely a printing issue:
+  .! foo;;
+   - : recd = {f1 = 2; f2 = "a"}
+
+ which is correct.
+
+
+Tue Jan 18 14:08:52 GMTST 2005
+  BUG: type aliases are not handled correctly in code, example:
+    # type a = int;;
+    # let f (x:a) = 1;;
+    # .! .<f 1>.;;
+    This expression has type int but is here used with type a
+  PROBLEM: the type of csp constants cannot resolve type aliases
+  FIX: when typing Pexp_cspval return a fresh variable so it will type
+    check in any situation
+
+Tue Jan 11 11:19:23 GMTST 2005
+  BUG: records, constructors etc are typed once and their type is reused, same
+    bug as on Jan 10 2005.
+  FIXED: when typing e.g. a record field access (Pexp_field) the stored type
+   is still used to get the label description (used by the compiler to compute
+   the offset for field access), but the toplevel type is not reused and a
+   fresh type variable is returned instead. In this way we avoid that several
+   runs of code coming from the same field access have their types unified.
+
+Mon Jan 10 18:51:21 GMTST 2005
+  BUG: csp constants in Pervasives (and similar) are type checked only once for
+  a given occurrence.
+   # let f x  = .< ref .~ x>.
+     in (.! (f .<3>.), .! (f .<1.3>.));;
+   This expression has type int but is here used with type float
+   Exception: Trx.TypeCheckingError.
+  PROBLEM: "ref" is typechecked only once when f is declared, and the resulting
+    type is used twice in the second line
+  FIXED: typing/typecore.ml now re-createx the untyped parsetree for the
+    Pervasive identifier and type-checks it again.
+
+Tue Jan 20 12:18:00 GMTST 2004
+  BUG: typechecker broken for csp ids, e.g. we get the wrong type
+  We get the incorrect typing (inner and outer code forced to be both 'a)
+   # .<fun x -> .<x>.>.;;
+   - : ('a, 'b -> ('a, 'b) code) code = .<fun (x_2) -> .<(x_2)>.>.    
+  PROBLEM: typechecker unifies the current level with the id's level left-to-right
+   but the latest classifier is the leftmost.
+  FIXED: levels are now unified right-to-left, and get correct type:
+    # .<fun x -> .<x>.>.;;
+    - : ('a, 'b -> ('c, 'b) code) code = .<fun (x_1) -> .<(x_1)>.>.
+
+Fri May 16 14:54:22 BST 2003
+  BUG: standalone bytecode compiling does not work with tag elimination
+       e.g. ./ocamlc toplevel/toplevellib.cma mex/evaletag.mk; ./a.out
+  PROBLEM: Tooploop.etag gets a typing error because timestamp of the code is in
+  the future (similar problem in the past with run)
+  FIXED: current timestamp bumped with the timestamp of the env passed to etag
+
+Mon Nov 25 18:24:28 GMT 2002
+  BUG: error typecore.ml: Texp_construct expected
+  PROBLEM: somehow typechecked made restrictive assuptions on the contents of the pexp_ext field for the case pPexp_construct
+  FIXED: assumptions relaxed 
+
+Mon Nov 25 10:10:32 GMT 2002
+  BUG: csp of array ops gives internal errors
+  PROBLEM: arrays are treated in a special way after typechecking phase, so replacing an op with a csp val of the op changes the semantics. Use ocamlc -dlambda to see how array ops are treated internally. 
+  FIXED: csp of array is rebuilt, like a Pervasives, so it's type-checked again, and the second phase of the compiler is happy.
+
+Thu Oct 24 09:55:36 BST 2002
+  BUG: csp at level n+2 gives Segmentation fault
+  PROBLEM: now Trx.mkcsp takes 2 args and not one, forgot to change cases
+  instvar and cspval at level n+1 accordingly
+  FIXED: cases instvar and cspvar at level n+1 now pass a second argument (None)
+
+Wed Oct  2 08:39:04 BST 2002
+  BUG: occurrences of a csp value share the same instantiated type
+  APPEARED: when treating Pervasives.* in a special way for performance. The
+  type of e.g. Pervasives.! is recorded in the extra field as an instantiated
+  type, so applications of the value cause unification.
+  BACKGROUND: values' types are closed schemas (all the identifiers are generic).
+  During type checking the types are instantiated. Instantiation is idempotent,
+  so one should always carry the schema somewhere. A typed expression exp such
+  that exp.exp_desc = Texp_ident (ident,value_description) has an instantiated
+  type in exp.exp_type and the type schema in value_description.val_type.
+  FIXED: Trx.trx creates a new instantiation for csp idents; Typecore.type_exp
+  re-instantiates the type schema when type-checking a cspval
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/README ocaml-4.00.1/ber-metaocaml-100/README
--- ocaml-4.00.1.orig/ber-metaocaml-100/README	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/README	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,141 @@
+		BER MetaOCaml
+		N100 January 2013
+
+0. TABLE OF CONTENTS
+
+   1 Copyright 
+   2 Installation
+   3 Staging constructs
+   4 Restrictions and Common Problems
+   5 Detailed Discussion
+   6 Credits
+
+1. COPYRIGHT
+
+BER MetaOCaml is a complete re-implementation of MetaOCaml, 
+which was licensed according to ORIGINAL-LICENSE-META
+
+
+2. INSTALLATION
+
+  Please see the file INSTALL
+
+
+3. STAGING CONSTRUCTS
+   (This is a modified version of the section from the last
+    release of the original MetaOCaml, Feb 3, 2006)
+
+  The three new constructs are
+
+    bracket: .< e >.  to delay computation (to the future stage)
+    escape:  .~ e     to perform a computation within brackets
+                      and splice-in the result
+    run:     .! e     to run a future-stage computation, or code, now
+
+  A special type constructor, called 'code' builds the type of
+  future-stage computations, or code expressions. For example, 
+
+    # .< 2 + 4 >.;;
+    - : ('cl, int) code = .<(2 + 4)>.
+
+  The type constructor code takes two arguments. The first argument
+  is always a type variable, usually named 'cl. It is called an environment
+  classifier, and is used to correctly type the run (.!)  construct.
+
+  Code fragments can be spliced into larger code contexts by using the
+  escape construct: 
+
+    # let x = .< 2 + 4 >. in .< .~ x + .~ x >. ;;
+    - : ('cl, int) code = .<((2 + 4) + (2 + 4))>.
+
+  The escape construct takes an expression of type ((_,t) code) and
+  produces an expression of type t, but only inside of a
+  code-constructing context (i.e., inside inside code brackets).
+  Attempting to escape code outside of a code-building context results
+  in the following type error:
+
+    # .~ .< 2 + 3 >.;;
+    Characters 0-14:
+    .~ .< 2 + 3 >.;;
+    ^^^^^^^^^^^^^^
+    Wrong level: escape at level 0
+
+
+  The run construct takes a code value, executes it and returns its result. 
+  For example: 
+
+    # .! .< 2 + 3 >.;;
+    - : int = 5
+
+  The run construct only works on code values which are polymorphic in
+  their environment classifier, which prevents nonsensical programs 
+  such as the following:
+
+    # .< fun x -> .~ (let u = .!.< x >. in .<()>.) >.;;
+    Characters 24-33:
+      .< fun x -> .~ (let u = .!.< x >. in .<()>.) >.;;
+                              ^^^^^^^^^
+    Error: .! error: 'cl not generalizable in ('cl, 'a) code
+
+  Please see many more examples in test/trivial.ml and other files
+  in the test/ directory.
+
+
+4. RESTRICTIONS AND COMMON PROBLEMS
+
+   1. All data constructors and record labels used within brackets must
+   come from the types that are declared in separately compiled modules.
+   For example, the following works:
+       .<true>.                 (* data constructor is Pervasive *)
+       .<Some [1]>.             (* ditto                         *)
+       .<{Complex.re = 1.0; im = 2.0}>. (* The Record Complex is defined *)
+                                        (* in the standard library.      *)
+       open Complex                     (* which is separately complied  *)
+       .<{re = 1.0; im = 2.0}>.
+
+   But the following are not allowed and flagged as compile-time error:
+
+       type foo = Bar
+       .<Bar>.
+
+       module Foo = struct exception E end
+      .<raise Foo.E>.
+
+   The type declaration foo or the module declaration Foo must be
+   moved into a separate file. The corresponding .cmi file must also be
+   available at run-time: either placed into the same directory as
+   the executable, or somewhere within the OCaml library search
+   path.
+
+   2. Escaped expressions at the same level evaluate in the same
+   order as arguments in an application. For byte-code OCaml,
+   this order is RIGHT to left.
+
+   3. Objects and modules are not supported within brackets
+     (but you can use brackets within modules or objects).
+
+
+5. DETAILED DISCUSSION
+
+   For differences from the original MetaOCaml and further discussion,
+   see NOTES.txt.
+
+
+6. CREDITS
+
+  BER MetaOCaml is a complete re-implementation of the original MetaOCaml. 
+
+  The original MetaOCaml was funded primarily by an NSF project titled:
+
+	"ITR/SY(CISE): Putting Multi-Stage Annotations to Work"
+
+  That project was led by Walid Taha. Most of the original development
+  and implementation of staging was done by Cristiano
+  Calcagno, then at Imperial College. 
+  Edward Pizzi has implemented the pretty-printing of code -- which
+  since then has been extensively modified and maintained by 
+  Jacques Carette.
+  Xavier Leroy, INRIA, helped with the compiler specifics.
+
+  Many members of the metaocaml-users and metaocaml-hackers lists have
+  helped identify bugs and in some cases fixed them.
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/berstart.ml ocaml-4.00.1/ber-metaocaml-100/berstart.ml
--- ocaml-4.00.1.orig/ber-metaocaml-100/berstart.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/berstart.ml	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,21 @@
+(*
+   To `run' the code we use toplevel facilities.
+   If we invoke BER MetaOcaml top level, then Toplevel.topstart() will
+   initalialize the top level.
+   If we execute a byte-compiled executable, we link with
+   the top-level library. But we need initialize it first.
+   This is the job of the current file.
+
+   This file must be linked in *before* the first user executable.
+
+   The present code roughly do the same steps OCaml top level does
+   when executing a script.
+   See Toplevel.topmain
+*)
+
+let () =
+  Toploop.set_paths ();
+  Compile.init_path();
+  Toploop.initialize_toplevel_env ()
+  (* toplevel_env := Compile.initial_env();
+  *)
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/bertop.ml ocaml-4.00.1/ber-metaocaml-100/bertop.ml
--- ocaml-4.00.1.orig/ber-metaocaml-100/bertop.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/bertop.ml	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,26 @@
+(* `Plugin' for the OCaml top-level *)
+open Longident
+
+(* Install printers for code values *)
+let install_printers () =
+  Topdirs.dir_install_printer Format.std_formatter
+    (Ldot(Lident "Print_code", "print_code"));
+  Topdirs.dir_install_printer Format.std_formatter
+    (Ldot(Lident "Print_code", "print_cde"))
+
+(* Initialization function *)
+
+let initialize () =
+  Printf.printf "BER MetaOCaml toplevel, version %s\n" Trx.meta_version;
+  install_printers ()
+
+(* Hook up to the top level *)
+let () =
+Toploop.toplevel_startup_hook :=
+  let old_hook = !Toploop.toplevel_startup_hook in
+  fun () -> 
+    begin
+      initialize ();
+      old_hook ()
+    end
+
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/build_patch.sh ocaml-4.00.1/ber-metaocaml-100/build_patch.sh
--- ocaml-4.00.1.orig/ber-metaocaml-100/build_patch.sh	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/build_patch.sh	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,41 @@
+#!/bin/sh
+# Building the patch set
+#    build_patch
+# This auxiliary file builds the patch set using the internal
+# SVN repository. The patch set is written into the standard output.
+
+cd ..
+
+git diff 4.00.1 -- \
+./.depend \
+./Makefile \
+./ocamldoc/Makefile \
+./parsing/lexer.mll \
+./parsing/parser.mly \
+./parsing/parsetree.mli \
+./parsing/printast.ml \
+./bytecomp/lambda.ml \
+./bytecomp/lambda.mli \
+./bytecomp/printlambda.ml \
+./bytecomp/translcore.ml \
+./bytecomp/symtable.ml \
+./tools/depend.ml \
+./tools/addlabels.ml \
+./tools/dumpobj.ml \
+./tools/ocamlprof.ml \
+./typing/typedtree.mli \
+./typing/typedtree.ml \
+./typing/predef.ml \
+./typing/predef.mli \
+./typing/printtyped.ml \
+./typing/cmt_format.ml \
+./typing/env.mli \
+./typing/env.ml \
+./typing/typecore.mli \
+./typing/typecore.ml \
+./typing/typemod.ml  \
+./tools/untypeast.ml \
+./tools/typedtreeIter.ml
+
+# svn diff -r5522 \
+# tools/addlabels.ml \
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/metaocamlc.tpl ocaml-4.00.1/ber-metaocaml-100/metaocamlc.tpl
--- ocaml-4.00.1.orig/ber-metaocaml-100/metaocamlc.tpl	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/metaocamlc.tpl	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+# Multi-shell script.  Works under Bourne Shell, MPW Shell, zsh.
+
+if : == x
+then # Bourne Shell or zsh
+     exec %%BINDIR%%/ocamlc -I +compiler-libs ocamlcommon.cma ocamlbytecomp.cma ocamltoplevel.cma metalib.cma berstart.cmo "$@"
+else # MPW Shell
+     ocamlc -I +compiler-libs ocamlcommon.cma ocamlbytecomp.cma ocamltoplevel.cma metalib.cma berstart.cmo {"parameters"}
+     exit {status}
+End # uppercase E because "end" is a keyword in zsh
+fi
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/metaocamlmktop.tpl ocaml-4.00.1/ber-metaocaml-100/metaocamlmktop.tpl
--- ocaml-4.00.1.orig/ber-metaocaml-100/metaocamlmktop.tpl	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/metaocamlmktop.tpl	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,16 @@
+#!/bin/sh
+#########################################################################
+#                                                                       #
+#                                 OCaml                                 #
+#                                                                       #
+#            Damien Doligez, projet Para, INRIA Rocquencourt            #
+#                                                                       #
+#   Copyright 1999 Institut National de Recherche en Informatique et    #
+#   en Automatique.  All rights reserved.  This file is distributed     #
+#   under the terms of the Q Public License version 1.0.                #
+#                                                                       #
+#########################################################################
+
+# $Id$
+
+exec %%BINDIR%%/ocamlc -I +compiler-libs -linkall ocamlcommon.cma ocamlbytecomp.cma ocamltoplevel.cma metalib.cma bertop.cmo berstart.cmo "$@" topstart.cmo
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/print_code.ml ocaml-4.00.1/ber-metaocaml-100/print_code.ml
--- ocaml-4.00.1.orig/ber-metaocaml-100/print_code.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/print_code.ml	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,1888 @@
+(* Printing code expressions *)
+(* Most of the code is authored by:  Ed Pizzi *)
+(* and simplified by Jacques Carette *)
+
+open Format
+open Parsetree
+(* open Pprintast *)
+
+open Asttypes
+open Location
+open Lexing
+
+(* borrowed from printast.ml *)
+let fmt_position f l =
+  if l.pos_fname = "" && l.pos_lnum = 1
+  then fprintf f "%d" l.pos_cnum
+  else if l.pos_lnum = -1
+       then fprintf f "%s[%d]" l.pos_fname l.pos_cnum
+       else fprintf f "%s[%d,%d+%d]" l.pos_fname l.pos_lnum l.pos_bol
+               (l.pos_cnum - l.pos_bol)
+
+let fmt_location f loc =
+  fprintf f "(%a..%a)" fmt_position loc.loc_start fmt_position loc.loc_end;
+  if loc.loc_ghost then fprintf f " ghost"
+(* end borrowing *)
+
+let indent    = 1     (* standard indentation increment *)
+let bar_on_first_case = true
+
+(* These sets of symbols are taken from the manual. However, it's
+   unclear what the sets infix_symbols and prefix_symbols are for, as
+   operator_chars, which contains their union seems to be the only set
+   useful to determine whether an identifier is prefix or infix.
+   The set postfix_chars I added, which is the set of characters allowed
+   at the end of an identifier to allow for internal MetaOCaml variable
+   renaming. *)
+
+let prefix_symbols  = [ '!'; '?'; '~' ]
+let infix_symbols = [ '='; '<'; '>'; '@'; '^'; '|'; '&'; '+'; '-';
+                       '*'; '/'; '$'; '%' ]
+let operator_chars = [ '!'; '$'; '%'; '&'; '*'; '+'; '-'; '.'; '/';
+                       ':'; '<'; '='; '>'; '?'; '@'; '^'; '|'; '~' ]
+let numeric_chars  = [ '0'; '1'; '2'; '3'; '4'; '5'; '6'; '7'; '8'; '9' ]
+
+type fixity = | Infix | Prefix
+
+let special_infix_strings =
+  ["asr"; "land"; "lor"; "lsl"; "lsr"; "lxor"; "mod"; "or"; ":="]
+
+(* determines if the string is an infix string.
+   checks backwards, first allowing a renaming postfix ("_102") which
+   may have resulted from Pexp -> Texp -> Pexp translation, then checking
+   if all the characters in the beginning of the string are valid infix
+   characters. *)
+let fixity_of_string s =
+  if ((List.mem s special_infix_strings)
+      || (List.mem (String.get s 0) infix_symbols)) then Infix else Prefix
+
+let fixity_of_longident = function
+  | (Longident.Lident (name) | Longident.Ldot (_, name)) ->
+      (fixity_of_string name) ;
+  | _ -> Prefix
+
+let fixity_of_exp e = match e.pexp_desc with
+  | Pexp_ident (li) -> fixity_of_longident li.txt
+  | Pexp_cspval (_,li) -> 
+	  if false (* default value of !Clflags.prettycsp *)
+	  then fixity_of_longident li.txt
+	  else Prefix
+  | _ -> Prefix
+
+let rec fmt_longident = function
+  | Longident.Lident (s) -> s
+  | Longident.Ldot (Longident.Lident("Pervasives"), s) -> s
+  | Longident.Ldot (y,s) -> fmt_longident y ^ "." ^ s
+  | Longident.Lapply (y, z) -> fmt_longident y ^ "(" ^ (fmt_longident z) ^ ")"
+
+let fmt_mutable_flag = function | Immutable -> "" | Mutable -> "mutable "
+
+let fmt_virtual_flag = function | Virtual  -> "virtual " | Concrete -> ""
+
+let fmt_ov_flag = function | Fresh -> "" | Override -> "!"
+
+module PR(F : sig val ppf : Format.formatter end) = struct
+
+let fmt = F.ppf
+let p = pp_print_string fmt
+let space () = pp_print_space fmt ()
+
+(* useful for %a *)
+let const f = fun _ x -> f x
+
+let fenced lf rf pr e = p lf; open_box 0; pr e; close_box (); p rf 
+let bp pr e = fenced "(" ")" pr e
+
+let fmt_constant = function
+  | Const_int (i) ->
+      if (i < 0) then fprintf fmt "(%d)" i else fprintf fmt "%d" i
+  | Const_char (c) ->
+      let i = int_of_char c in
+      if (i < 32) || (i >= 128) then fprintf fmt "'\\0%02x'" (Char.code c)
+      else fprintf fmt "'%c'" c
+  | Const_string (s) -> fprintf fmt "%S" s
+  | Const_float (s) -> 
+      if ((String.get s 0) = '-') then fprintf fmt "(%s)" s else p s
+      (* maybe parenthesize all floats for consistency? *)
+  | Const_int32 (i) -> fprintf fmt "%ld" i
+  | Const_int64 (i) -> fprintf fmt "%Ld" i
+  | Const_nativeint (i) -> fprintf fmt "%nd" i
+
+let string s = p s
+
+(* List2 - applies f to each element in list l, placing break hints
+     and a separator string between the resulting outputs.          *)
+
+let rec list2 (f:'a -> unit) ?(indent=0) ?(space=1) ?(breakfirst=false)
+              ?(breaklast=false) sep l =
+  let pbreak () = if (breaklast=true) then pp_print_break fmt space indent in
+  match l with
+    [] -> pbreak ()
+  | (last::[]) -> pbreak (); f last; pbreak ()
+  | (first::rest) -> 
+        pbreak ();
+        f first ;
+        p sep;
+        pp_print_break fmt space indent;
+        list2 f ~indent:indent ~space:space
+              ~breakfirst:false ~breaklast:breaklast sep rest
+
+let type_var s = p ("'" ^ s)
+
+let fmt_rec_flag = function
+  | Nonrecursive -> ""
+  | Recursive | Default -> " rec"
+    (* todo - what is "default" recursion?? 
+        this seemed safe, as it's better to falsely make a non-recursive
+        let recursive than the opposite. *)
+
+let fmt_direction_flag = function | Upto   -> "to" | Downto -> "downto"
+
+let fmt_private_flag = function | Public -> "" | Private -> "private "
+
+let fmt_class_params_def ppf (l, _) = match l with
+  | [] -> ()
+  | _  ->
+    fprintf ppf "[" ;
+    list2 type_var "," (List.map (fun x -> x.txt) l);
+    fprintf ppf "]@ "
+
+let fmt_class_params ppf (l, _) = match l with
+  | []  -> ()
+  | [x] -> fprintf ppf "%s@ " x
+  | _   -> fenced "(" ")" (list2 string ",") l; space ()
+
+let option f = function (* DELETE ?*)
+  | None -> ()
+  | Some x -> fprintf fmt "Some\n"; f x
+
+let option_quiet f = function
+  | None   -> ()
+  | Some x -> fprintf fmt "@ " ; f x
+
+let rec expression_is_terminal_list = function
+  | {pexp_desc = Pexp_construct ({txt = Longident.Lident("[]")}, None, _)}
+     -> true ;
+  | {pexp_desc = Pexp_construct ({txt = Longident.Lident("::")},
+                   Some({pexp_desc = Pexp_tuple([_ ; exp2])}), _)}
+     -> (expression_is_terminal_list exp2)
+  | {pexp_desc = _}
+     -> false
+
+(* check if it's a fixed-length list *)
+let rec pat_fixed_len_list li po = match (li,po) with
+    | Longident.Lident("::"), Some ({ppat_desc = Ppat_tuple([_; pat2])}) ->
+        begin
+          match pat2.ppat_desc with
+          | Ppat_construct ({txt=li}, po, _) -> pat_fixed_len_list li po
+          | _ -> false
+        end
+    | Longident.Lident("[]"), None -> true
+    | _,_ -> false
+
+let rec core_type x =
+  match x.ptyp_desc with
+  | Ptyp_any -> p "_";         (* done *)
+  | Ptyp_var (s) -> fprintf fmt "'%s" s; (* done *)
+  | Ptyp_arrow (l, ct1, ct2) ->          (* done *)
+      pp_open_hovbox fmt indent ;
+      p "(" ;
+      (match l with
+       | "" -> core_type ct1;
+       | s when (String.get s 0 = '?')  ->
+         (match ct1.ptyp_desc with
+          | Ptyp_constr ({txt = Longident.Lident ("option")}, l) ->
+            fprintf fmt "%s :@ " s ;
+            type_constr_list fmt l ;
+          | _ -> core_type ct1; (* todo: what do we do here? *)
+         );
+       | _ -> core_type ct1; (* todo: what do we do here? *)
+      );
+      fprintf fmt "@ ->@ " ;
+      core_type ct2 ;
+      p ")" ;
+      pp_close_box fmt () ;
+  | Ptyp_tuple l ->                      (* done *)
+      pp_open_hovbox fmt indent ;
+      p "(" ;
+      list2 core_type " *" l;
+      p ")" ;
+      pp_close_box fmt () ;
+  | Ptyp_constr (li, l) ->               (* done *)
+      pp_open_hovbox fmt indent ;
+      type_constr_list fmt ~space:true l ;
+      p (fmt_longident li.txt);
+      pp_close_box fmt () ;
+  | Ptyp_object ([]) -> p "< >"
+  | Ptyp_object (l) ->
+      pp_open_hovbox fmt indent ;
+      p "< " ;
+      list2 core_field_type " ;" l;
+      p " >" ;
+      pp_close_box fmt ()
+  | Ptyp_class (li, l, low) ->           (* done... sort of *)
+      pp_open_hovbox fmt indent ;
+      list2 core_type ~breaklast:true "" l;
+      fprintf fmt "#%s" (fmt_longident li.txt);
+      if ((List.length low) < 0) then begin (* done, untested *)
+        fprintf fmt "@ [> " ;
+        list2 class_var "" low;
+        fprintf fmt " ]";
+      end ;
+      pp_close_box fmt ();
+  | Ptyp_alias (ct, s) ->                (* done *)
+      pp_open_hovbox fmt indent ;
+      p "(" ;
+      core_type ct ;
+      fprintf fmt "@ as@ '%s)" s;
+      pp_close_box fmt () ;
+  | Ptyp_variant (l, closed, _) ->
+      pp_open_hovbox fmt indent ;
+      (match closed with
+       | true  -> p "[ " ;
+       | false -> p "[> " ;
+      );
+      list2 type_variant_helper " |" l;
+      p " ]";
+      pp_close_box fmt () ;
+  | Ptyp_poly (sl, ct) ->                (* done? *)
+      pp_open_hovbox fmt indent ;
+      if ((List.length sl) > 0) then begin
+        list2 (fprintf fmt "'%s") ~breaklast:true "" sl;
+        fprintf fmt ".@ " ;
+      end ;
+      core_type ct ;
+      pp_close_box fmt () ; 
+  | Ptyp_package (li, []) ->
+      p (fmt_longident li.txt)
+  | Ptyp_package (li, lst) ->
+      pp_open_hovbox fmt indent ;
+      p (fmt_longident li.txt); 
+      fprintf fmt "@ with@ ";
+      list2 package_type_cstr "and" lst;
+      pp_close_box fmt () ;
+      failwith "Ptyp_package printing not implemented yet"
+
+and package_type_cstr (li, typ) = 
+      pp_open_hovbox fmt indent ;
+      p "type ";
+      p (fmt_longident li.txt);
+      p " = ";
+      core_type typ;
+      pp_close_box fmt ()
+
+and class_var s = fprintf fmt "`%s" s
+
+and core_field_type x =
+  match x.pfield_desc with
+  | Pfield (s, ct) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "%s :@ " s;
+      core_type ct;
+      pp_close_box fmt () ;
+  | Pfield_var ->
+      p "..";
+
+and type_constr_list ppf ?(space=false) l =
+  match (List.length l) with
+   | 0 -> ()
+   | 1 -> list2 core_type "" l;
+          if (space) then fprintf ppf " " ;
+   | _ -> fprintf ppf "(" ; 
+          list2 core_type "," l;
+          fprintf ppf ")" ;
+          if (space) then fprintf ppf " " ;
+
+and pattern_with_label ppf x s =
+  if (s = "") then pattern x
+  else begin
+    let s =
+      if (String.get s 0 = '?') then begin
+        fprintf ppf "?" ;
+        String.sub s 1 ((String.length s) - 1)
+      end else begin
+        fprintf ppf "~" ;
+        s
+      end in
+    p s;
+    match x.ppat_desc with
+    | Ppat_var (s2) ->
+        if (s <> s2.txt) then begin
+          fprintf ppf ":" ;
+          pattern x ;
+        end
+    | _ -> fprintf ppf ":" ;
+           pattern x
+  end ;
+
+and pattern_with_when ppf whenclause x =
+  match whenclause with
+  | None -> pattern x ;
+  | Some (e) ->
+      pp_open_hovbox ppf indent ;
+      pattern x ;
+      fprintf ppf "@ when@ " ;
+      expression e ;
+      pp_close_box ppf () ;
+
+and pattern x =
+  match x.ppat_desc with
+  | Ppat_any -> p "_";            (* OXX done *)
+  | Ppat_var ({txt = s}) ->
+      ( match fixity_of_string s with
+        | Infix  -> fprintf fmt "(%s)" s              (* OXX done *)
+        | Prefix -> p s)
+  | Ppat_alias (pat, {txt=s}) ->                (* OXX done ... *)
+      pp_open_hovbox fmt indent ;
+      p "(" ;
+      pattern pat ;
+      fprintf fmt " as@ %s)" s;
+      pp_close_box fmt () ;
+  | Ppat_constant (c) -> fmt_constant c;
+  | Ppat_tuple (l) ->                       (* OXX done *)
+      fprintf fmt "@[<hov 1>(";
+      list2 pattern "," l;
+      fprintf fmt "@])";
+  | Ppat_construct ({txt=li}, po, _) -> 
+      pp_open_hovbox fmt indent ;
+      ( if pat_fixed_len_list li po then
+        (match li,po with
+         | Longident.Lident("::"),
+           Some ({ppat_desc = Ppat_tuple([pat1; pat2])}) ->
+             p "[" ;
+             pattern pat1 ;
+             pattern_finlist_helper fmt pat2 ;
+             p "]"; 
+         | Longident.Lident("[]"), _ -> p "[]"
+         | _,_ -> assert false )
+      else
+        (match li,po with
+         | Longident.Lident("::"),
+           Some ({ppat_desc = Ppat_tuple([pat1; pat2])}) ->
+             p "(" ;
+             pattern pat1 ;
+             fprintf fmt "@ ::@ " ;
+             pattern_list_helper fmt pat2 ;
+             p ")"; 
+         | _,_ -> p (fmt_longident li);
+            option_quiet pattern_in_parens po ) ) ;
+      pp_close_box fmt () ;
+      (* OXX what is the boolean at the end?  The parser always sets it
+         to false, so ignore it since it can't be part of the external syntax
+      *)
+
+  | Ppat_variant (l, po) ->
+      (match po with
+       | None -> p l
+       | Some (pat) ->
+          pp_open_hovbox fmt indent ;
+          fprintf fmt "(`%s@ " l ;
+          pattern pat ;
+          p ")" ;
+          pp_close_box fmt () ;
+      );
+  | Ppat_record (l,cf) ->
+      p "{" ;
+      list2 longident_x_pattern ";" l;
+      if cf = Open then fprintf fmt "; _ ";
+      p "}" ;
+  | Ppat_array (l) ->                      (* OXX done *)
+     pp_open_hovbox fmt 2 ;
+     p "[|" ;
+     list2 pattern ";" l;
+     p "|]" ;
+     pp_close_box fmt () ;
+  | Ppat_or (p1, p2) ->                    (* OXX done *)
+      pp_open_hovbox fmt indent ;
+      p "(" ;
+      pattern p1 ;
+      fprintf fmt "@ | " ;
+      pattern p2 ;
+      p ")" ;
+      pp_close_box fmt () ;
+  | Ppat_constraint (pat, ct) ->             (* OXX done, untested *)
+      p "(" ;
+      pattern pat ;
+      p " :" ;
+      pp_print_break fmt 1 indent ;
+      core_type ct ;
+      p ")" ;
+  | Ppat_type {txt=li} ->                        (* OXX done *)
+      fprintf fmt "#%s" (fmt_longident li);
+  | Ppat_lazy pat ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "(lazy @ ";
+      pattern pat ;
+      p ")" ;
+      pp_close_box fmt ()
+  | Ppat_unpack {txt = s} ->
+      fprintf fmt "(module @ %s)" s;
+
+and expression x =
+  match x.pexp_desc with
+  | Pexp_ident ({txt=li}) -> (* was (li, b) *)
+      ( match fixity_of_longident li with
+        | Infix  -> fprintf fmt "(%s)" (fmt_longident li)
+        | Prefix -> p (fmt_longident li))
+  | Pexp_constant (c) -> fmt_constant c;
+  | Pexp_let (rf, l, e) ->
+      let l1 = (List.hd l) in
+      let l2 = (List.tl l) in
+      pp_open_hvbox fmt 0 ;
+      pp_open_hvbox fmt indent ;
+      fprintf fmt "let%s " (fmt_rec_flag rf);
+      pattern_x_expression_def fmt l1;
+      pattern_x_expression_def_list fmt l2;
+      pp_close_box fmt () ;
+      fprintf fmt " in@ " ;
+      expression_sequence fmt ~first:false ~indent:0 e ;
+      pp_close_box fmt () ;
+  | Pexp_function (pat, eo, l) ->
+      if (List.length l = 1) then begin
+        pp_open_hvbox fmt indent;
+        p "fun " ;
+        pattern_x_expression_case_single fmt (List.hd l) eo pat
+      end else begin
+        pp_open_hvbox fmt 0;
+        p "function" ;
+        option_quiet expression_in_parens eo ;
+        pp_print_space fmt () ;
+        pattern_x_expression_case_list fmt l ;
+      end ;
+      pp_close_box fmt ();
+  | Pexp_apply (e, l) -> (* was (e, l, _) *)
+     let fixity = fixity_of_exp e in
+     (* let fixity =
+         (match e.pexp_desc with Pexp_ident (_, b) -> b
+                                 | _ -> false ) in *)
+     let sd =
+       (match e.pexp_desc with
+        | Pexp_ident ({txt=Longident.Ldot (Longident.Lident(modname), valname)})
+          -> (modname, valname)
+        | Pexp_ident ({txt=Longident.Lident(valname)})
+          -> ("",valname)
+        | _ -> ("","")) in 
+     (match sd,l with
+      | ("Array", "get"), [(_,exp1) ; (_,exp2)] ->
+               pp_open_hovbox fmt indent;
+               (match exp1.pexp_desc with
+                | Pexp_ident (_) -> expression exp1
+                | _ -> expression_in_parens exp1
+               );
+               p ".";
+               expression_in_parens exp2;
+               pp_close_box fmt ();
+      | ("Array", "set"), [(_,array) ; (_,index) ; (_, value)] ->
+               pp_open_hovbox fmt indent;
+               (match array.pexp_desc with
+                | Pexp_ident (_) -> expression array
+                | _ -> expression_in_parens array
+               );
+               p ".";
+               expression_in_parens index;
+               fprintf fmt "@ <-@ ";
+               expression value;
+               pp_close_box fmt ()
+      | ("","!"),[(_,exp1)] ->
+               p "!" ;
+               expression exp1
+      (* | ("","raise"),[(_,exp)] ->
+               p "raising [" ;
+               expression exp;
+               fprintf fmt "], says %s" st; *)
+      | _,_ -> begin
+          pp_open_hovbox fmt (indent + 1) ; 
+          p "(" ;
+          ( match fixity with
+          | Prefix -> begin        
+             (match e.pexp_desc with
+              | Pexp_ident(_) -> expression e ;
+              | Pexp_send (_,_) -> expression e ;
+              | _ -> pp_open_hovbox fmt indent;
+                     expression_in_parens e ;
+                     pp_close_box fmt () );
+             fprintf fmt "@ " ;
+             list2 label_x_expression_param "" l
+            end
+          | Infix -> begin
+              let args = (List.length l) in
+              if (args = 2) then begin
+                let arg1 = (List.hd l) in
+                let arg2 = (List.hd (List.tl l)) in
+                label_x_expression_param arg1 ;
+                pp_print_space fmt () ;
+                (match e.pexp_desc with
+                 | Pexp_ident({txt = li}) ->
+                     (* override parenthesization of infix identifier *)
+                     p (fmt_longident li);
+                 | _ -> expression e) ;
+                pp_print_space fmt () ;
+                label_x_expression_param arg2 
+              end
+              else begin
+                (* p "(" ; *)
+                expression e ;
+                (* p ")" ; *)
+                list2 label_x_expression_param ~breakfirst:true "" l
+              end
+            end ) ;
+          p ")" ;
+          pp_close_box fmt ()
+          end )
+  | Pexp_match (e, l) ->
+      p "(" ;
+      pp_open_hvbox fmt 0;
+      pp_open_hovbox fmt 2;
+      fprintf fmt "match@ " ;
+      expression e ;
+      p " with" ;
+      pp_close_box fmt () ;
+      pp_print_space fmt () ;
+      pattern_x_expression_case_list fmt l ;
+      pp_close_box fmt () ;
+      p ")" ;
+  | Pexp_try (e, l) ->
+      p "(";
+      pp_open_vbox fmt 0; (* <-- always break here, says style manual *)
+      pp_open_hvbox fmt 0;
+      p "try";
+      pp_print_break fmt 1 indent ;
+      expression_sequence fmt ~first:false e;
+      pp_print_break fmt 1 0;
+      p "with";
+      pp_close_box fmt ();
+      pp_print_cut fmt ();
+      pattern_x_expression_case_list fmt l ;
+      pp_close_box fmt ();
+      p ")";
+  | Pexp_tuple (l) ->
+      fprintf fmt "@[<hov 1>(";
+      list2 (bp expression) "," l;
+      fprintf fmt ")@]";
+  | Pexp_construct ({txt=li}, None, _) -> p (fmt_longident li)
+  | Pexp_construct ({txt=li}, Some eo, _) ->
+      (match li with
+       | Longident.Lident ("::") ->
+           (match eo with
+              ({pexp_desc = Pexp_tuple ([exp1 ; exp2])}) ->
+               pp_open_hovbox fmt indent ;
+               if (expression_is_terminal_list exp2) then begin
+                 p "[" ;
+                 expression exp1 ;
+                 expression_list_helper fmt exp2 ;
+                 p "]" ;
+               end else begin
+                 pp_open_hovbox fmt indent ;
+                 p "(" ;
+                 expression exp1 ;
+                 fprintf fmt " ::@ " ;
+                 expression_list_nonterminal fmt exp2 ;
+                 p ")" ;
+                 pp_close_box fmt () ;
+               end ;
+               pp_close_box fmt () ;
+            | _ -> assert false
+           );
+       | _ -> 
+           pp_open_hovbox fmt indent ;
+           p (fmt_longident li);
+           expression_in_parens eo;
+           pp_close_box fmt () ;
+           p ")"
+      );
+  | Pexp_variant (l, eo) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "`%s" l ;
+      option_quiet expression eo ;
+      pp_close_box fmt () ;
+  | Pexp_record (l, None) ->
+      pp_open_hovbox fmt indent ; (* maybe just 1? *)
+      p "{" ;
+      list2 longident_x_expression ";" l;
+      p "}" ;
+      pp_close_box fmt () ;
+  | Pexp_record (l, Some eo) ->
+      pp_open_hovbox fmt indent ; (* maybe just 1? *)
+      p "{" ;
+      expression eo;
+      p " with ";
+      list2 longident_x_expression ";" l;
+      p "}" ;
+      pp_close_box fmt () ;
+  | Pexp_field (e, {txt=li}) ->
+      pp_open_hovbox fmt indent ;
+      (match e.pexp_desc with
+       | Pexp_ident (_) ->
+           expression e ;
+       | _ ->
+           expression_in_parens e ;
+      );
+      fprintf fmt ".%s" (fmt_longident li);
+      pp_close_box fmt () ;
+  | Pexp_setfield (e1, {txt=li}, e2) ->
+      pp_open_hovbox fmt indent ;
+      (match e1.pexp_desc with
+       | Pexp_ident (_) ->
+           expression e1 ;
+       | _ ->
+           expression_in_parens e1 ;
+      );
+      fprintf fmt ".%s" (fmt_longident li);
+      fprintf fmt "@ <-@ ";
+      expression e2;
+      pp_close_box fmt () ;
+  | Pexp_array (l) ->
+      pp_open_hovbox fmt 2 ;
+      p "[|" ;
+      list2 expression ";" l;
+      p "|]" ;
+      pp_close_box fmt () ;
+  | Pexp_ifthenelse (e1, e2, eo) ->
+      fprintf fmt "@[<hv 0>" ;
+      expression_if_common fmt e1 e2 eo;
+      fprintf fmt "@]";
+
+  | Pexp_sequence (_, _) ->
+      fprintf fmt "@[<hv 0>begin" ;
+      pp_print_break fmt 1 indent ;
+      (* "@;<1 2>" ; *)
+      expression_sequence fmt ~first:false x ;
+      fprintf fmt "@;<1 0>end@]" ;
+  | Pexp_while (e1, e2) ->
+      pp_open_hvbox  fmt 0 ;
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "while@ " ;
+      expression e1 ;
+      p " do" ;
+      pp_close_box fmt () ;
+      pp_print_break fmt 1 indent ;
+      expression_sequence fmt e2 ~first:false;
+      pp_print_break fmt 1 0 ;
+      p "done" ;
+      pp_close_box fmt () ;
+  | Pexp_for ({txt=s}, e1, e2, df, e3) ->
+      pp_open_hvbox  fmt 0 ;
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "for %s =@ " s ;
+      expression e1 ;
+      fprintf fmt "@ %s@ " (fmt_direction_flag df);
+      expression e2 ;
+      p " do" ;
+      pp_close_box fmt () ;
+
+      pp_print_break fmt 1 indent ;
+      expression_sequence fmt ~first:false e3 ;
+      pp_print_break fmt 1 0 ;
+      p "done" ;
+      pp_close_box fmt () ;
+  | Pexp_constraint (e, cto1, cto2) ->
+      pconstraint e cto1 cto2
+  | Pexp_when (_, _) ->
+      assert false ;
+      (* This is a weird setup. The ocaml phrase
+          "pattern when condition -> expression"
+          found in pattern matching contexts is encoded as:
+          "pattern -> when condition expression"
+         Thus, the when clause ("when condition"), which one might expect
+          to be part of the pattern, is encoded as part of the expression
+          following the pattern.
+         A "when clause" should never exist in a vaccum. It should always
+          occur in a pattern matching context and be printed as part of the
+          pattern (in pattern_x_expression_case_list).
+         Thus these Pexp_when expressions are printed elsewhere, and if
+          this code is executed, an error has occurred. *)
+  | Pexp_send (e, s) ->
+      pp_open_hovbox fmt indent;
+      (match e.pexp_desc with
+       | Pexp_ident(_) ->
+           expression e;
+           fprintf fmt "#%s" s;
+       | _ ->
+           fprintf fmt "(" ;
+           expression_in_parens e;
+           fprintf fmt "@,#%s" s;
+           fprintf fmt ")"
+      );
+      pp_close_box fmt (); (* bug fixed? *)
+  | Pexp_new {txt=li} ->
+      pp_open_hovbox fmt indent;
+      fprintf fmt "new@ %s" (fmt_longident li);
+      pp_close_box fmt ();
+  | Pexp_setinstvar ({txt=s}, e) ->
+      pp_open_hovbox fmt indent;
+      fprintf fmt "%s <-@ " s;
+      expression e;
+      pp_close_box fmt ();
+  | Pexp_override (l) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "{< " ;
+      if ((List.length l) > 0) then begin
+        list2 string_x_expression ";" l;
+        fprintf fmt " " ;
+      end ;
+      fprintf fmt ">}" ;
+      pp_close_box fmt () ;
+  | Pexp_letmodule ({txt=s}, me, e) ->
+      pp_open_hvbox fmt 0 ;
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "let module %s =@ " s ;
+      module_expr fmt me ;
+      fprintf fmt " in" ;
+      pp_close_box fmt () ;
+      pp_print_space fmt () ;
+      expression_sequence fmt ~first:false ~indent:0 e ;
+      pp_close_box fmt () ;
+  | Pexp_assert (e) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "assert@ " ;
+      expression e ;
+      pp_close_box fmt () ;
+  | Pexp_assertfalse ->
+      fprintf fmt "assert false" ;
+  | Pexp_lazy (e) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "lazy@ " ;
+      expression e ;
+      pp_close_box fmt () ;
+  | Pexp_poly (e, cto) ->
+      (* should this even print by itself? *)
+      (match cto with
+       | None -> expression e ;
+       | Some (ct) ->
+          pp_open_hovbox fmt indent ;
+          expression e ;
+          fprintf fmt "@ (* poly:@ " ;
+          core_type ct ;
+          fprintf fmt " *)" ;
+          pp_close_box fmt () );
+  | Pexp_object cs ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "object@ " ;
+      class_structure fmt cs ;
+      pp_close_box fmt () ;
+  | Pexp_newtype (li,fun_def) -> (* XXX may sometimes need a leading 'fun'? *)
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "(type %s) %a" li (const expression) fun_def;
+      pp_close_box fmt ()
+  | Pexp_pack me ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "(module %a)" module_expr me;
+      pp_close_box fmt ()
+  | Pexp_open (li, sexpr) -> 
+      fprintf fmt "let open %s in@ " (fmt_longident li.txt);
+      pp_open_hovbox fmt indent ;
+      expression_sequence fmt sexpr;
+      pp_close_box fmt ()
+
+(* XXO *)
+  | Pexp_bracket (e) ->
+      pp_open_hovbox fmt 2 ; (* indent ? *)
+      fprintf fmt ".<" ;
+      expression e;
+      fprintf fmt ">." ;
+      pp_close_box fmt () ;
+  | Pexp_escape (e) ->
+      fprintf fmt ".~";
+      (match e.pexp_desc with
+       | Pexp_ident (_) ->
+          expression e;
+       | _ ->
+          expression_in_parens e;
+      );
+  | Pexp_run (e) ->
+      fprintf fmt ".!";
+      (match e.pexp_desc with
+         Pexp_bracket (e') ->
+           expression e;
+       | _ ->
+           expression_in_parens e)
+  | Pexp_cspval (v,loc) ->
+      if false (* default value of (!Clflags.prettycsp)  *)
+      then p (fmt_longident loc.txt)
+      (* was: compiled code omitted
+         however, CSP values's are not always compiled code:
+           let f x = x in
+           let g   = .!.<fun x -> f x>. *)
+      else 
+          fprintf fmt "(* cross-stage persistent value (id: %s) *)"
+               (fmt_longident loc.txt)
+
+and value_description ppf x =
+  pp_open_hovbox ppf indent ;
+  core_type x.pval_type;
+  if ((List.length x.pval_prim) > 0) then begin
+    fprintf ppf " =@ " ;
+    list2 string "" x.pval_prim
+  end ;
+  pp_close_box ppf () ;
+
+and type_declaration ppf x =
+  pp_open_hovbox ppf indent ;
+  (match x.ptype_kind with
+   | Ptype_variant (first::rest) ->
+      pp_open_hovbox ppf indent ;
+      pp_open_hvbox ppf 0 ;
+      type_variant_leaf ppf first true ;
+      type_variant_leaf_list ppf rest ;
+      (* string_x_core_type_list ppf lst; *)
+      pp_close_box ppf () ;
+      pp_close_box ppf () ;
+   | Ptype_variant [] ->
+      assert false ;
+   | Ptype_abstract ->
+      (match x.ptype_manifest with
+       | None -> ()
+       | Some(y) -> core_type y)
+   | Ptype_record l -> 
+       pp_open_hovbox ppf indent ;
+
+       fprintf ppf "{" ;
+       pp_print_break ppf 0 indent ;
+       pp_open_hvbox ppf 0;
+       list2 type_record_field ";" l;
+       pp_close_box ppf () ;
+       fprintf ppf "@," ;
+       pp_close_box ppf () ;
+       fprintf ppf "}" ;
+
+       pp_close_box ppf () ;
+  );
+  list2 typedef_constraint ~breakfirst:true "" x.ptype_cstrs;
+  pp_close_box ppf ()
+
+and pconstraint ?(simple=true) e cto1 cto2 =
+    pp_open_hovbox fmt 2 ;
+    if simple then p "(";
+    expression e;
+    (match cto1 with
+     | Some x1 -> fprintf fmt " :@ " ; core_type x1
+     | None    -> () ) ;
+    (match cto2 with
+     | Some x2 -> fprintf fmt " :>@ " ; core_type x2
+     | None    -> () ) ;
+    if simple then p ")";
+    pp_close_box fmt ()
+
+and exception_declaration ppf x =
+  match x with
+  | [] -> ()
+  | first::rest ->
+      fprintf ppf "@ of@ ";
+      list2 core_type " *" x;
+
+and class_type ppf x =
+  match x.pcty_desc with
+  | Pcty_signature (cs) ->
+      class_signature ppf cs;
+  | Pcty_constr ({txt=li}, l) ->
+      pp_open_hovbox ppf indent ;
+      (match l with
+       | [] -> ()
+       | _  -> fprintf ppf "[" ;
+               list2 core_type "," l;
+               fprintf ppf "]@ " ); 
+      p (fmt_longident li);
+      pp_close_box ppf () ;
+  | Pcty_fun (l, co, cl) ->
+      pp_open_hovbox ppf indent ;
+      core_type co ;
+      fprintf ppf " ->@ " ;
+      (match l with
+       | "" -> () ;
+       | _  -> fprintf ppf "[%s] " l ); (* todo - what's l *)
+      class_type ppf cl ;
+      pp_close_box ppf () ;
+
+and class_signature ppf {pcsig_self=ct; pcsig_fields=l} =
+  pp_open_hvbox ppf 0;
+  pp_open_hovbox ppf indent ;
+  fprintf ppf "object";
+  (match ct.ptyp_desc with
+   | Ptyp_any -> ()
+   | _ -> fprintf ppf "@ (";
+          core_type ct;
+          fprintf ppf ")" );
+  pp_close_box ppf () ;
+  list2 class_type_field ~indent:indent ~breakfirst:true "" l;
+  pp_print_break ppf 1 0;
+  fprintf ppf "end";
+
+and class_type_field {pctf_desc=x} =
+  match x with
+  | Pctf_inher (ct) ->      (* todo: test this *)
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "inherit@ " ;
+      class_type fmt ct ;
+      pp_close_box fmt () ;
+  | Pctf_val (s, mf, vf, ct) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "val %s%s%s :@ " (fmt_mutable_flag mf) 
+        (fmt_virtual_flag vf) s;
+      core_type ct ;
+      pp_close_box fmt () ;
+  | Pctf_virt (s, pf, ct) ->    (* todo: test this *)
+      pp_open_hovbox fmt indent ;
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "method@ %svirtual@ %s" (fmt_private_flag pf) s ;
+      pp_close_box fmt () ;
+      fprintf fmt " :@ " ;
+      core_type ct ;
+      pp_close_box fmt () ;
+  | Pctf_meth (s, pf, ct) ->
+      pp_open_hovbox fmt indent ;
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "method %s%s" (fmt_private_flag pf) s;
+      pp_close_box fmt () ;
+      fprintf fmt " :@ " ;
+      core_type ct ;
+      pp_close_box fmt () ;
+  | Pctf_cstr (ct1, ct2) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "constraint@ " ;
+      core_type ct1;
+      fprintf fmt " =@ " ;
+      core_type ct2;
+      pp_close_box fmt () ;
+
+and class_description x =
+  pp_open_hvbox fmt 0 ;
+  pp_open_hovbox fmt indent ;
+  fprintf fmt "class %s%a%s :" (fmt_virtual_flag x.pci_virt)
+    fmt_class_params_def x.pci_params x.pci_name.txt ; 
+  pp_close_box fmt () ;
+  pp_print_break fmt 1 indent ;
+  class_type fmt x.pci_expr ;
+  pp_close_box fmt () ;
+
+and class_type_declaration ppf x =
+  class_type_declaration_ext ppf true x ;
+
+and class_type_declaration_ext ppf first x =
+  pp_open_hvbox ppf 0;
+  pp_open_hovbox ppf indent ;
+  fprintf ppf "%s@ %s%a%s =" (if (first) then "class type" else "and")
+    (fmt_virtual_flag x.pci_virt) fmt_class_params_def x.pci_params
+    x.pci_name.txt ; 
+  pp_close_box ppf ();
+  pp_print_break ppf 1 indent ;
+  class_type ppf x.pci_expr;
+  pp_close_box ppf ();
+
+and class_type_declaration_list ppf ?(first=true) l =
+  if (first) then pp_open_hvbox ppf 0 ;
+  match l with
+  | [] -> if (first) then pp_close_box ppf () ;
+  | h :: [] ->
+      class_type_declaration_ext ppf first h ;
+      pp_close_box ppf () ;
+  | h :: t ->
+      class_type_declaration_ext ppf first h ;
+      pp_print_space ppf () ;
+      class_type_declaration_list ppf ~first:false t ;
+
+and class_expr ppf x =
+ match x.pcl_desc with
+ | Pcl_structure (cs) ->
+     class_structure ppf cs ;
+ | Pcl_fun (l, eo, pat, e) ->
+     pp_open_hvbox ppf indent;
+     pp_open_hovbox ppf indent;
+     fprintf ppf "fun@ ";
+     pattern pat;
+     fprintf ppf " ->";
+     pp_close_box ppf ();
+     (match (eo, l) with
+      | (None, "") -> () ;
+      | (_,_) ->
+          pp_open_hovbox ppf indent;
+          fprintf ppf " (* eo: ";
+          option expression eo;
+          fprintf ppf "@ label: ";
+          p l;
+          fprintf ppf " *)";
+          pp_close_box ppf ()
+     );
+     fprintf ppf "@ ";
+     class_expr ppf e;
+     pp_close_box ppf ();
+ | Pcl_let (rf, l, ce) ->
+     let l1 = (List.hd l) in
+     let l2 = (List.tl l) in
+     pp_open_hvbox ppf 0 ;
+     pp_open_hvbox ppf indent ;
+     fprintf ppf "let%s " (fmt_rec_flag rf);
+     pattern_x_expression_def ppf l1;
+     pattern_x_expression_def_list ppf l2;
+     pp_close_box ppf () ;
+     pp_close_box ppf () ;
+     fprintf ppf " in@ " ;
+     class_expr ppf ce;
+ | Pcl_apply (ce, l) ->
+     pp_open_hovbox ppf indent ;
+     fprintf ppf "(";
+     class_expr ppf ce;
+     list2 label_x_expression_param ~breakfirst:true "" l;
+     fprintf ppf ")";
+     pp_close_box ppf () ;
+ | Pcl_constr ({txt=li}, l) ->
+     pp_open_hovbox ppf indent;
+     if ((List.length l) != 0) then begin
+       fprintf ppf "[" ;
+       list2 core_type "," l;
+       fprintf ppf "]@ " ;
+     end ;
+     p (fmt_longident li);
+     pp_close_box ppf ();
+ | Pcl_constraint (ce, ct) ->
+     pp_open_hovbox ppf indent;
+     fprintf ppf "(";
+     class_expr ppf ce;
+     fprintf ppf "@ : ";
+     class_type ppf ct;
+     fprintf ppf ")";
+     pp_close_box ppf ();
+
+and class_structure ppf {pcstr_pat=p; pcstr_fields=l} =
+  pp_open_hvbox ppf 0 ;
+  pp_open_hovbox ppf indent ;
+  fprintf ppf "object" ;
+  (match p.ppat_desc with
+   | Ppat_any -> ();
+   | _ -> fprintf ppf "@ " ;
+          pattern_in_parens p );
+  pp_close_box ppf () ;
+  list2 class_field ~indent:indent ~breakfirst:true "" l;
+  fprintf ppf "@ end" ;
+  pp_close_box ppf () ;
+
+and class_field {pcf_desc=x} =
+  match x with
+  | Pcf_inher (ov,ce, so) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "inherit@ %s" (fmt_ov_flag ov);
+      class_expr fmt ce;
+      (match so with
+       | None -> ();
+       | Some (s) -> fprintf fmt "@ as %s" s );
+      pp_close_box fmt ();
+  | Pcf_valvirt ({txt=s}, mf, ct) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "val virtual %s%s" (fmt_mutable_flag mf) s;
+      fprintf fmt " :@ " ;
+      core_type ct;
+      pp_close_box fmt () ;
+  | Pcf_val ({txt=s}, mf, ov, e) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "val %s%s%s =@ " (fmt_ov_flag ov) (fmt_mutable_flag mf) s ;
+      expression_sequence fmt ~indent:0 e ;
+      pp_close_box fmt () ;
+  | Pcf_virt ({txt=s}, pf, ct) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "method virtual %s%s" (fmt_private_flag pf) s ;
+      fprintf fmt " :@ " ;
+      core_type ct;
+      pp_close_box fmt () ;
+  | Pcf_meth ({txt=s}, pf, ov, e) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "method %s%s%s" (fmt_ov_flag ov) (fmt_private_flag pf) s ;
+      (match e.pexp_desc with
+       | Pexp_poly (e, Some(ct)) ->
+           fprintf fmt " :@ " ;
+           core_type ct ;
+           fprintf fmt " =@ " ;
+           expression e ;
+       | _ -> 
+           fprintf fmt " =@ " ;
+           expression e;
+      ) ;
+      (* special Pexp_poly handling? *)
+      pp_close_box fmt () ;
+  | Pcf_constr (ct1, ct2) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "constraint@ ";
+      core_type ct1;
+      fprintf fmt " =@ " ;
+      core_type ct2;
+      pp_close_box fmt ();
+  | Pcf_init (e) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "initializer@ " ;
+      expression_sequence fmt ~indent:0 e ;
+      pp_close_box fmt () ;
+
+and class_fun_helper ppf e =
+  match e.pcl_desc with
+  | Pcl_fun (l, eo, pat, e) ->
+      pattern pat;
+      fprintf ppf "@ ";
+      (match (eo, l) with
+       | (None, "") -> () ;
+       | (_,_) ->
+           fprintf ppf "(* ";
+           option expression eo;
+           p l;
+           fprintf ppf " *)@ "
+      );
+      class_fun_helper ppf e;
+  | _ -> e;
+
+and class_declaration_list ppf ?(first=true) l =
+  match l with
+  | [] -> if (first = false) then pp_close_box ppf ();
+  | cd::l ->
+      let s = (if first then begin pp_open_hvbox ppf 0 ; "class" end
+               else begin "@ and" end) in
+      class_declaration ppf ~str:s cd ;
+      class_declaration_list ppf ~first:false l ;
+
+and class_declaration ppf ?(str="class") x =
+  pp_open_hvbox ppf indent ;
+  pp_open_hovbox ppf indent ;
+  fprintf ppf "%s %s%a%s@ " str (fmt_virtual_flag x.pci_virt)
+    fmt_class_params_def x.pci_params x.pci_name.txt ;
+  let ce =
+    (match x.pci_expr.pcl_desc with
+     | Pcl_fun (l, eo, p, e) ->
+        class_fun_helper ppf x.pci_expr;
+     | _ -> x.pci_expr) in
+  let ce =
+    (match ce.pcl_desc with
+     | Pcl_constraint (ce, ct) ->
+         fprintf ppf ":@ " ;
+         class_type ppf ct ;
+         fprintf ppf "@ " ;
+         ce
+     | _ -> ce ) in
+  fprintf ppf "=" ;
+  pp_close_box ppf () ;
+  fprintf ppf "@ " ;
+  class_expr ppf ce ;
+  pp_close_box ppf () ;
+
+and module_type ppf x =
+  match x.pmty_desc with
+  | Pmty_ident ({txt=li}) ->
+      p (fmt_longident li);
+  | Pmty_signature (s) ->
+      pp_open_hvbox ppf 0;
+      fprintf ppf "sig";
+      list2 signature_item ~breakfirst:true ~indent:indent "" s;
+      pp_print_break ppf 1 0;
+      fprintf ppf "end";
+      pp_close_box ppf ();
+  | Pmty_functor ({txt=s}, mt1, mt2) ->
+      pp_open_hvbox ppf indent;
+      pp_open_hovbox ppf indent;
+      fprintf ppf "functor@ (%s : " s ;
+      module_type ppf mt1;
+      fprintf ppf ") ->";
+      pp_close_box ppf ();
+      pp_print_space ppf ();
+      module_type ppf mt2;
+      pp_close_box ppf ();
+  | Pmty_with (mt, l) ->
+      pp_open_hovbox ppf indent ;
+      fprintf ppf "(" ;
+      module_type ppf mt ;
+      fprintf ppf "@ with@ " ;
+      with_constraint_list ppf l ;
+      fprintf ppf ")" ;
+      pp_close_box ppf ()
+  | Pmty_typeof me -> 
+      pp_open_hovbox ppf 0 ;
+      fprintf fmt "module type of@ %a" module_expr me;
+      pp_close_box ppf ()
+
+and signature x = List.iter signature_item x
+
+and signature_item x =
+  match x.psig_desc with
+  | Psig_type (l) ->
+      let first = (List.hd l) in
+      let rest  = (List.tl l) in
+      pp_open_hvbox fmt 0;
+      pp_open_hvbox fmt 0;
+      fprintf fmt "type " ;
+      string_x_type_declaration fmt first;
+      pp_close_box fmt ();
+      type_def_list_helper fmt rest;
+      pp_close_box fmt ();
+  | Psig_value ({txt=s}, vd) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "val %s :@ " s;
+      value_description fmt vd;
+      pp_close_box fmt () ;
+  | Psig_exception ({txt=s}, ed) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "exception %s" s;
+      exception_declaration fmt ed;
+      pp_close_box fmt ();
+  | Psig_class (l) ->
+      pp_open_hvbox fmt 0 ;
+      list2 class_description "" l;
+      pp_close_box fmt () ;
+  | Psig_module ({txt=s}, mt) ->  (* todo: check this *)
+      pp_open_hovbox fmt indent ;
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "module@ %s =" s ;
+      pp_close_box fmt () ;
+      pp_print_space fmt () ;
+      module_type fmt mt;
+      pp_close_box fmt () ;
+  | Psig_open ({txt=li}) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "open@ %s" (fmt_longident li);
+      pp_close_box fmt () ;
+  | Psig_include (mt) ->  (* todo: check this *)
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "include@ " ;
+      module_type fmt mt;
+      pp_close_box fmt () ;
+  | Psig_modtype ({txt=s}, md) -> (* todo: check this *)
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "module type %s" s ;
+      (match md with
+       | Pmodtype_abstract -> ()
+       | Pmodtype_manifest (mt) ->
+           pp_print_space fmt () ;
+           module_type fmt mt;
+      );
+      pp_close_box fmt () ;
+  | Psig_class_type (l) ->
+      class_type_declaration_list fmt l ;
+  | Psig_recmodule decls ->
+      pp_open_hvbox fmt 0 ;
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "module rec@ " ;
+      string_x_module_type_list fmt decls ; (* closes hov box *)
+      pp_close_box fmt () ;
+
+and modtype_declaration ppf x =
+  match x with
+  | Pmodtype_abstract -> fprintf ppf "Pmodtype_abstract\n";
+  | Pmodtype_manifest (mt) ->
+      fprintf ppf "Pmodtype_manifest\n";
+      module_type ppf mt;
+
+and module_expr ppf x =
+  match x.pmod_desc with
+  | Pmod_ident ({txt=li}) ->
+      p (fmt_longident li);
+  | Pmod_structure (s) ->
+      pp_open_hvbox ppf 0;
+      fprintf ppf "struct";
+      list2 structure_item ~breakfirst:true ~indent:indent "" s;
+      pp_print_break ppf 1 0;
+      fprintf ppf "end";
+      pp_close_box ppf (); (* bug fixed? *)
+  | Pmod_functor ({txt=s}, mt, me) ->
+      pp_open_hvbox ppf indent ;
+      fprintf ppf "functor (%s : " s;
+      module_type ppf mt;
+      fprintf ppf ") ->@ ";
+      module_expr ppf me;
+      pp_close_box ppf () ;
+  | Pmod_apply (me1, me2) ->
+      pp_open_hovbox ppf indent;
+      module_expr ppf me1;
+      pp_print_cut ppf ();
+      fprintf ppf "(" ;
+      module_expr ppf me2;
+      fprintf ppf ")" ;
+      pp_close_box ppf ();
+  | Pmod_constraint (me, mt) ->
+      fprintf ppf "(";
+      pp_open_hovbox ppf indent;
+      module_expr ppf me;
+      fprintf ppf " :@ ";  (* <-- incorrect indentation? *)
+      module_type ppf mt;
+      pp_close_box ppf ();
+      fprintf ppf ")";
+  | Pmod_unpack e ->
+      pp_open_hovbox ppf indent;
+      p "( val";
+      ( match e.pexp_desc with
+        | Pexp_constraint (ex, ct1, ct2) -> pconstraint ~simple:false ex ct1 ct2
+        | _                              -> expression e);
+      p ")";
+      pp_close_box ppf ()
+
+and structure x = List.iter structure_item x
+
+(* closes one box *)
+and string_x_modtype_x_module ppf ({txt=s}, mt, me) =
+(*
+  (match me.pmod_desc with
+   | Pmod_constraint (me, ({pmty_desc=(Pmty_ident (_)
+        | Pmty_signature (_))} as mt)) ->
+       (* assert false ; *) (* 3.07 - should this ever happen here? *)
+       fprintf ppf "%s :@ " s ;
+       module_type ppf mt ;
+       fprintf ppf " =" ;
+       pp_close_box ppf () ;
+       pp_print_space ppf () ;
+       module_expr ppf me ;
+   | _ ->
+*)
+       fprintf ppf "%s :@ " s;
+       module_type ppf mt ;
+       fprintf ppf " =" ;
+       pp_close_box ppf () ;
+       pp_print_space ppf () ;
+       module_expr ppf me ;
+(*  ) ; *)
+
+(* net gain of one box (-1, +2) *)
+and string_x_modtype_x_module_list ppf l =
+  match l with
+  | [] -> ()
+  | hd :: tl ->
+          pp_close_box ppf () ;
+          pp_print_space ppf () ;
+          pp_open_hvbox ppf indent ;
+          pp_open_hovbox ppf indent ;
+          fprintf ppf "and " ;
+          string_x_modtype_x_module ppf hd; (* closes a box *)
+          string_x_modtype_x_module_list ppf tl ; (* net open of one box *)
+
+(* context: [hv [hov .]]  returns [hv .]
+   closes inner hov box. *)
+and string_x_module_type_list ppf ?(first=true) l = 
+  match l with
+  | [] -> () ;
+  | hd :: tl ->
+     if (first=false) then begin
+       pp_print_space ppf () ;
+       pp_open_hovbox ppf indent ;
+       fprintf ppf "and " ;
+     end ;
+     string_x_module_type ppf hd ;
+     pp_close_box ppf () ;
+     string_x_module_type_list ppf ~first:false tl ;
+     
+and string_x_module_type ppf ({txt=s}, mty) =
+  fprintf ppf "%s :@ " s ;
+  module_type ppf mty ;
+
+and structure_item x =
+  match x.pstr_desc with
+  | Pstr_eval (e) -> 
+      pp_open_hvbox fmt 0 ;
+      expression_sequence fmt ~first:false ~indent:0 e ;
+      pp_close_box fmt () ;
+  | Pstr_type (l) ->
+      let first = (List.hd l) in
+      let rest  = (List.tl l) in
+      pp_open_vbox fmt 0;
+      pp_open_hvbox fmt 0;
+      fprintf fmt "type " ;
+      string_x_type_declaration fmt first;
+      pp_close_box fmt ();
+      type_def_list_helper fmt rest;
+      pp_close_box fmt ();
+  | Pstr_value (rf, l) -> 
+      let l1 = (List.hd l) in
+      let l2 = (List.tl l) in
+      pp_open_hvbox fmt 0 ;
+      pp_open_hvbox fmt indent ;
+      fprintf fmt "let%s " (fmt_rec_flag rf);
+      pattern_x_expression_def fmt l1;
+      pattern_x_expression_def_list fmt l2;
+      pp_close_box fmt () ;
+      pp_close_box fmt () ;
+  | Pstr_exception ({txt=s}, ed) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "exception@ %s" s;
+      exception_declaration fmt ed;
+      pp_close_box fmt () ;
+  | Pstr_module ({txt=s}, me) ->
+      pp_open_hvbox fmt indent;
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "module %s" s ;
+      (match me.pmod_desc with
+       | Pmod_constraint (me, ({pmty_desc=(Pmty_ident (_)
+            | Pmty_signature (_))} as mt)) ->
+           fprintf fmt " :@ " ;
+           module_type fmt mt ;
+           fprintf fmt " =" ;
+           pp_close_box fmt () ;
+           pp_print_space fmt () ;
+           module_expr fmt me ;
+       | _ ->
+           fprintf fmt " =" ;
+           pp_close_box fmt () ;
+           pp_print_space fmt () ;
+           module_expr fmt me ;
+      ) ;
+      pp_close_box fmt ();
+  | Pstr_open ({txt=li}) ->
+      fprintf fmt "open %s" (fmt_longident li);
+  | Pstr_modtype ({txt=s}, mt) ->
+      pp_open_hovbox fmt indent;
+      fprintf fmt "module type %s =@ " s;      
+      module_type fmt mt;
+      pp_close_box fmt () ; (* bug fixed? *)
+  | Pstr_class (l) ->
+      class_declaration_list fmt l;
+  | Pstr_class_type (l) ->
+      class_type_declaration_list fmt l ;
+  | Pstr_primitive ({txt=s}, vd) ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "external@ %s :@ " s;
+      value_description fmt vd;
+      pp_close_box fmt () ;
+  | Pstr_include me ->
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "include " ;
+      module_expr fmt me ;
+      pp_close_box fmt () ;
+  | Pstr_exn_rebind ({txt=s}, {txt=li}) ->        (* todo: check this *)
+      pp_open_hovbox fmt indent ;
+      fprintf fmt "exception@ %s =@ %s" s (fmt_longident li);
+      pp_close_box fmt () ;
+  | Pstr_recmodule decls -> (* 3.07 *)
+      let l1 = (List.hd decls) in
+      let l2 = (List.tl decls) in
+      pp_open_hvbox fmt 0;        (* whole recmodule box *)
+      pp_open_hvbox fmt indent ;  (* this definition box *)
+      pp_open_hovbox fmt indent ; (* first line box *)
+      fprintf fmt "module rec " ;
+      string_x_modtype_x_module fmt l1; (* closes a box *)
+      string_x_modtype_x_module_list fmt l2; (* net opens one box *)
+      pp_close_box fmt () ;
+      pp_close_box fmt () ;
+      pp_close_box fmt () ;
+
+and type_def_list_helper ppf l =
+  match l with
+  | [] -> ()
+  | first :: rest ->
+      pp_print_space ppf () ;
+      pp_open_hovbox ppf indent ;
+      fprintf ppf "and " ;
+      string_x_type_declaration ppf first;
+      pp_close_box ppf () ;
+      type_def_list_helper ppf rest ;
+
+and string_x_type_declaration ppf ({txt=s}, td) =
+  let l = List.map (function None -> "" | Some{txt=x} -> x)
+                   td.ptype_params in
+  (match l with
+    | [] -> ()
+    | [_] -> list2 type_var "" l;
+             fprintf ppf " " ;
+    | _ -> pp_open_hovbox ppf indent ;
+           fprintf ppf "(" ; 
+           list2 type_var "," l;
+           fprintf ppf ")" ;
+           pp_close_box ppf ();
+           fprintf ppf " " ;
+  );
+  p s ;
+  (match (td.ptype_kind, td.ptype_manifest) with
+    | Ptype_abstract, None -> ()
+    | Ptype_record _, _ -> fprintf ppf " = " ;
+    | _ , _ -> fprintf ppf " =" ;
+               pp_print_break ppf 1 indent ;
+  );
+  type_declaration ppf td;
+
+and with_constraint_list ?(first=true) ppf = function
+  | [] -> () ;
+  | h :: [] ->
+     if (first = false) then fprintf ppf "@ and " ;
+     with_constraint ppf h ;
+  | h :: t  ->
+     if (first = false) then fprintf ppf "@ and " ;
+     with_constraint ppf h ;
+     fprintf ppf "@ and " ;
+     with_constraint ppf h ;
+     with_constraint_list ~first:false ppf t;
+
+and with_constraint ppf ({txt=li}, wc) = match wc with
+  | Pwith_type (td) ->
+      fprintf ppf "type@ %s =@ " (fmt_longident li);
+      type_declaration ppf td ;
+  | Pwith_module ({txt=li2}) ->
+      fprintf ppf "module %s =@ %s" (fmt_longident li) (fmt_longident li2);
+  | Pwith_typesubst _
+  | Pwith_modsubst _ ->                 (* XXX Notdone *)
+      failwith "Pwithtypesubst and Pwith_modsubst aren't printed yet"
+
+and typedef_constraint (ct1, ct2, l) =
+  pp_open_hovbox fmt indent ;
+  fprintf fmt "constraint@ " ; 
+  core_type ct1;
+  fprintf fmt " =@ " ;
+  core_type ct2;
+  pp_close_box fmt () ;
+
+and type_variant_leaf ppf ({txt=s}, l, vo,_) first = (* XXX Notdone: vo *)
+  if (first) then begin
+    pp_print_if_newline ppf ();
+    pp_print_string ppf "  ";
+  end else begin
+    fprintf ppf "@ | " ;
+  end ;
+  pp_open_hovbox ppf indent ;
+  p s ;
+  if ((List.length l) > 0) then begin
+    fprintf ppf "@ of@ " ;
+    list2 core_type " *" l
+  end ;
+  pp_close_box ppf ();
+
+and type_variant_leaf_list ppf list =
+  match list with
+  | [] -> ()
+  | first :: rest ->
+    type_variant_leaf ppf first false ;
+    type_variant_leaf_list ppf rest ;
+
+and type_record_field ({txt=s}, mf, ct,_) =
+  pp_open_hovbox fmt indent ;
+  fprintf fmt "%s%s:" (fmt_mutable_flag mf) s ;
+  core_type ct ;
+  pp_close_box fmt () ;
+
+and longident_x_pattern ({txt=li}, pat) =
+  pp_open_hovbox fmt indent ;
+  fprintf fmt "%s =@ " (fmt_longident li);
+  pattern pat;
+  pp_close_box fmt () ;
+
+and pattern_x_expression_case_list
+ ppf ?(first:bool=true) ?(special_first_case=bar_on_first_case)
+ (l:(pattern * expression) list) =
+  match l with
+  | []        -> ()
+  | (p,e)::[] -> (* last time *)
+    if (first=false) then fprintf ppf "| " ;
+    pp_open_hvbox ppf indent ;
+    let (e,w) =
+     (match e with
+      | {pexp_desc = Pexp_when (e1, e2)} -> (e2, Some (e1))
+      | _ -> (e, None)) in 
+    pattern_with_when ppf w p ;
+    fprintf ppf " ->@ " ;
+    pp_open_hvbox ppf 0 ;
+    expression_sequence ppf ~indent:0 e ;
+    pp_close_box ppf () ;
+    pp_close_box ppf () ;
+  | (p,e)::r  -> (* not last  *)
+    pp_open_hvbox ppf (indent + 2) ;
+    if ((first=true) & (special_first_case=false)) then begin
+      pp_print_if_newline ppf () ;
+      pp_print_string ppf "  "
+    end else
+      fprintf ppf "| " ;
+    let (e,w) =
+     (match e with
+      | {pexp_desc = Pexp_when (e1, e2)} -> (e2, Some (e1))
+      | _ -> (e, None)) in 
+    pattern_with_when ppf w p ;
+    fprintf ppf " ->@ " ;
+    pp_open_hvbox ppf 0 ;
+    expression_sequence ppf ~indent:0 e ;
+    pp_close_box ppf () ;
+    pp_close_box ppf () ;
+    pp_print_break ppf 1 0;
+    (pattern_x_expression_case_list ppf ~first:false r);
+
+and pattern_x_expression_def ppf (pat, e) =
+  pattern pat ;
+  fprintf ppf " =@ " ;
+  expression e;
+
+and pattern_list_helper ppf pat =
+  match pat with
+  | {ppat_desc = Ppat_construct ({txt=Longident.Lident("::")},
+                   Some ({ppat_desc = Ppat_tuple([pat1; pat2])}),
+                   _)}
+    -> pattern pat1 ;
+       fprintf ppf "@ ::@ " ;
+       pattern_list_helper ppf pat2 ;
+  | _ -> pattern pat ;
+
+(* this prints the rest of a finite-list pattern, starting with a ';' *)
+and pattern_finlist_helper ppf pat =
+  match pat with
+  | {ppat_desc = Ppat_construct ({txt=Longident.Lident("::")},
+                   Some ({ppat_desc = Ppat_tuple([pat1; pat2])}),
+                   _)}
+    -> fprintf ppf "@ ;@ " ;
+       pattern pat1 ;
+       pattern_finlist_helper ppf pat2 ;
+  | {ppat_desc = Ppat_construct ({txt=Longident.Lident("[]")}, _,_)} -> ()
+  | _ -> assert false
+
+and string_x_expression ({txt=s}, e) =
+  pp_open_hovbox fmt indent ;
+  fprintf fmt "%s =@ " s ;
+  expression e ;
+  pp_close_box fmt () ;
+
+and longident_x_expression ({txt=li}, e) =
+  pp_open_hovbox fmt indent ;
+  fprintf fmt "%s =@ " (fmt_longident li);
+  expression e;
+  pp_close_box fmt () ;
+
+and label_x_expression_param (l,e) =
+  match l with 
+  | ""  -> expression_param e ;
+  | lbl ->
+      if ((String.get lbl 0) = '?') then begin
+        fprintf fmt "%s:" lbl ;
+        expression_param e ;
+      end else begin
+        fprintf fmt "~%s:" lbl ;
+        expression_param e ;
+      end ;
+
+and expression_param e =
+  match e.pexp_desc with
+    Pexp_ifthenelse _ -> expression_in_parens e ;
+  | Pexp_function   _ -> expression_in_parens e ;
+  | _ -> expression e ;
+
+and expression_in_parens e =
+  let already_has_parens =
+    (match e.pexp_desc with
+       Pexp_apply ({pexp_desc=Pexp_ident ({txt=Longident.Ldot (
+         Longident.Lident(modname), funname)})},_)
+         -> (match modname,funname with
+             | "Array","get" -> false;
+             | "Array","set" -> false;
+             | _,_ -> true) ;
+     | Pexp_apply ({pexp_desc=Pexp_ident ({txt=Longident.Lident(funname)})},_)
+       -> (match funname with
+           | "!" -> false;
+           | _ -> true);
+     | Pexp_apply (_,_) -> true;
+     | Pexp_match (_,_) -> true;
+     | Pexp_tuple (_) -> true ;
+     | Pexp_constraint (_,_,_) -> true ;
+     | _ -> false) in
+  if (already_has_parens) then expression e
+  else begin
+    fprintf fmt "(" ;
+    expression e ;
+    fprintf fmt ")" ;
+  end ;
+
+and pattern_in_parens pat =
+  let already_has_parens =
+    match pat.ppat_desc with
+    | Ppat_alias (_,_) -> true
+    | Ppat_tuple (_) -> true
+    | Ppat_or (_,_) -> true
+    | Ppat_constraint (_,_) -> true
+    | _ -> false in
+  if (already_has_parens) then pattern pat
+  else begin
+    fprintf fmt "(" ;
+    pattern pat ;
+    fprintf fmt ")" ;
+  end; 
+
+and pattern_constr_params_option ppf po =
+  match po with
+  | None -> ();
+  | Some pat ->
+      pp_print_space ppf ();
+      pattern_in_parens pat;
+
+and type_variant_helper x =
+  match x with
+  | Rtag (l, b, ctl) ->  (* is b important? *)
+      pp_open_hovbox fmt indent ; 
+      fprintf fmt "`%s" l ; 
+      if ((List.length ctl) != 0) then begin
+        fprintf fmt " of@ " ;
+        list2 core_type " *" ctl
+      end ;
+      pp_close_box fmt () ;
+  | Rinherit (ct) ->
+      core_type ct
+
+(* prints a list of definitions as found in a let statement
+   note! breaks "open and close boxes in same function" convention, however
+         does always open and close the same number of boxes. (i.e. no "net
+         gain or loss" of box depth.                                         *)
+and pattern_x_expression_def_list ppf l =
+  match l with
+  | [] -> ()
+  | hd :: tl ->
+          pp_close_box ppf () ;
+          pp_print_space ppf () ;
+          pp_open_hvbox ppf indent ;
+          fprintf ppf "and " ;
+          pattern_x_expression_def ppf hd;
+          pattern_x_expression_def_list ppf tl ;
+
+(* end an if statement by printing an else phrase if there is an "else"
+   statement in the ast. otherwise just close the box. *)
+(* added: special case for "else if" case *)
+
+and expression_eo ppf eo extra =
+  match eo with
+  | None   -> ();
+  | Some x ->
+    if extra then fprintf ppf " "
+    else fprintf ppf "@ " ;
+    match x.pexp_desc with
+    | Pexp_ifthenelse (e1, e2, eo) ->   (* ... else if ...*)
+        fprintf ppf "else" ;
+        expression_elseif ppf (e1, e2, eo)
+    | Pexp_sequence (e1, e2) ->
+        fprintf ppf "else" ;
+        expression_ifbegin ppf x;       (* ... else begin ... end*)
+    | _ ->                              (* ... else ... *)
+      pp_open_hvbox ppf indent ;
+      fprintf ppf "else@ " ;
+      expression x ;
+      pp_close_box ppf () ;
+
+and expression_elseif ppf (e1,e2,eo) =
+      fprintf ppf " " ;
+      expression_if_common ppf e1 e2 eo ;      
+
+and expression_ifbegin ppf e =
+      fprintf ppf " begin";
+      pp_print_break ppf 1 indent ; (* "@;<1 2>"; *)
+      expression_sequence ppf e;
+      pp_print_break ppf 1 0 ; (* fprintf ppf "@;<1 0>" *)
+      fprintf ppf "end";
+
+and expression_if_common ppf e1 e2 eo =
+  match e2.pexp_desc with
+     | Pexp_sequence (e3, e4) ->
+         fprintf ppf "if " ;
+         expression e1;
+         fprintf ppf " then" ;
+         expression_ifbegin ppf e2;
+         expression_eo ppf eo true;   (* ... then begin ... end *)
+     | _ -> 
+         pp_open_hvbox ppf indent ;
+         fprintf ppf "if " ;
+         expression e1;
+         fprintf ppf " then@ " ;
+         expression e2;
+         pp_close_box ppf () ;
+         expression_eo ppf eo false;
+
+and expression_sequence ppf ?(skip=1) ?(indent=indent) ?(first=true) expr =
+  if (first = true) then begin
+    pp_open_hvbox ppf 0 ;
+    expression_sequence ppf ~skip:skip ~indent:0 ~first:false expr ;
+    pp_close_box ppf () ;
+  end else
+    match expr.pexp_desc with
+    | Pexp_sequence (e1, e2) ->
+         expression e1 ;
+         fprintf ppf ";" ; 
+         pp_print_break ppf skip indent ; (* "@;<1 2>" ; *)
+         expression_sequence ppf ~skip:skip ~indent:indent ~first:false e2 ;
+    | _ ->
+         expression expr ;
+
+and expression_list_helper ppf exp =
+  match exp with
+  | {pexp_desc = Pexp_construct ({txt=Longident.Lident("[]")}, None, _)}
+     -> () ;
+  | {pexp_desc = Pexp_construct ({txt=Longident.Lident("::")},
+                   Some({pexp_desc = Pexp_tuple([exp1 ; exp2])}), _)}
+     -> fprintf ppf ";@ " ;
+        expression exp1 ;
+        expression_list_helper ppf exp2 ; 
+  | {pexp_desc = _}
+     -> assert false;
+
+and expression_list_nonterminal ppf exp =
+  match exp with
+  | {pexp_desc = Pexp_construct ({txt=Longident.Lident("[]")}, None, _)}
+     -> fprintf ppf "[]" ; (* assert false; *)
+  | {pexp_desc = Pexp_construct ({txt=Longident.Lident("::")},
+                   Some({pexp_desc = Pexp_tuple([exp1 ; exp2])}), _)}
+     -> expression exp1;
+        fprintf ppf " ::@ ";
+        expression_list_nonterminal ppf exp2;
+  | {pexp_desc = _}
+     -> expression exp;
+;
+
+and directive_argument = function
+  | Pdir_none -> ()
+  | Pdir_string (s) -> fprintf fmt "@ \"%s\"" s
+  | Pdir_int (i) -> fprintf fmt "@ %d" i
+  | Pdir_ident (li) -> fprintf fmt "@ %s" (fmt_longident li)
+  | Pdir_bool (b) -> fprintf fmt "@ %s" (string_of_bool b)
+
+and string_x_core_type_list (s, l) =
+  p s;
+  List.iter core_type l
+
+and pattern_x_expression_case_single ppf (pat, e) eo lbl =
+  (match eo with
+     None ->   pattern_with_label ppf pat lbl
+   | Some x -> fprintf ppf "?" ;
+               pp_open_hovbox ppf indent ;
+               fprintf ppf "(" ;
+               pattern pat ;
+               fprintf ppf " =@ " ;
+               expression x ;
+               fprintf ppf ")" ;
+               pp_close_box ppf ()
+  ) ;
+  fprintf ppf " ->@ " ;
+  expression_sequence ppf ~indent:0 e ;;
+
+let rec toplevel_phrase = function
+  | Ptop_def (s) ->
+      pp_open_hvbox fmt 0;
+      list2 structure_item ~breakfirst:false ~indent:0 "" s;
+      pp_close_box fmt ();
+  | Ptop_dir (s, da) ->
+      pp_open_hovbox fmt indent;
+      fprintf fmt "#%s" s;
+      directive_argument da;
+      pp_close_box fmt ()
+
+end
+
+(* print code as a parse tree. Useful for debugging *)
+let print_code_as_ast x =
+  Printast.implementation Format.std_formatter
+  [{ pstr_desc = Pstr_eval ((Obj.magic x) : Parsetree.expression);
+     pstr_loc  = Location.none }]
+
+let inpc ppf x = 
+  let module M = PR(struct let ppf = ppf end) in
+  fprintf ppf ".<@,"; M.expression x; fprintf ppf ">.@ ";
+  try ignore (Trx.check_scope_extrusion x)
+  with e -> fprintf ppf "\n%s" (Printexc.to_string e)
+  
+
+let inpc_string x =
+  ignore (flush_str_formatter ()) ;
+  inpc str_formatter x ;
+  flush_str_formatter ()
+
+let top_phrase_pretty ppf x =
+  let module M = PR(struct let ppf = ppf end) in
+  pp_print_newline ppf () ;
+  M.toplevel_phrase x;
+  fprintf ppf ";;" ;
+  pp_print_newline ppf ()
+
+(* These functions are suitable for installing as printers
+   at the toplevel, using top-level directive install printer.
+   Don't rename these functions or change their types.
+   See metatop.ml, which refers to these functions by their external
+   symbolic name.
+*)
+
+let print_code ppf (x : ('c,'a) code) = inpc ppf (Obj.magic x)
+
+let print_cde ppf (x : 'a Runcode.cde) = print_code ppf x.Runcode.cde
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/print_code.mli ocaml-4.00.1/ber-metaocaml-100/print_code.mli
--- ocaml-4.00.1.orig/ber-metaocaml-100/print_code.mli	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/print_code.mli	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,14 @@
+(* Printing code expressions *)
+
+
+(* low-level pretty-printers of the Ast *)
+val inpc              : Format.formatter -> Parsetree.expression -> unit
+val top_phrase_pretty : Format.formatter -> Parsetree.toplevel_phrase -> unit
+val inpc_string       : Parsetree.expression -> string
+
+(* Print code values *)
+val print_code : Format.formatter -> ('c,'a) code -> unit
+val print_cde  : Format.formatter -> 'a Runcode.cde -> unit
+
+(* print code as a parse tree. Useful for debugging *)
+val print_code_as_ast : ('a, 'b) code -> unit
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/runcode.ml ocaml-4.00.1/ber-metaocaml-100/runcode.ml
--- ocaml-4.00.1.orig/ber-metaocaml-100/runcode.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/runcode.ml	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,109 @@
+(* Run the closed code: byte-code and native code *)
+
+open Format
+open Parsetree
+
+type 'a cde = {cde : 'c. ('c,'a) code}  (* Type of the closed code *)
+
+(* Cast the closed code to Typedtree.expression, 
+   revealing its representation
+*)
+let cde_repr {cde = x} = Obj.magic x
+
+
+(* Execute a thunk (which does compilation) while disabling certain
+   warnings.
+*)
+let warnings_descr =
+    [(Warnings.Partial_match "",("P","p"));
+     (Warnings.Unused_argument,("X","x"));
+     (Warnings.Unused_var "",("Y","y"));
+     (Warnings.Unused_var_strict "",("Z","z"))
+    ]
+
+let with_disabled_warnings warnings thunk =
+  let disable_str =
+    String.concat "" 
+      (List.map 
+	 (fun w -> snd (List.assoc w warnings_descr)) warnings) in
+  let curr_str = 
+    String.concat "" 
+      (List.map 
+	 (fun w -> 
+	   let state = Warnings.is_active w in
+	   (if state then fst else snd) (List.assoc w warnings_descr))
+	 warnings) in
+  let () = Warnings.parse_options false disable_str in
+  try
+    let r = thunk () in
+    Warnings.parse_options false curr_str; r
+  with e ->
+    Warnings.parse_options false curr_str;
+    raise e
+
+
+
+
+let initial_env = ref Env.empty
+
+(* Load and execute bytecode: copied from toploop/toploop.ml *)
+let load_lambda ppf lam =
+  if !Clflags.dump_rawlambda then fprintf ppf "%a@." Printlambda.lambda lam;
+  let slam = Simplif.simplify_lambda lam in
+  if !Clflags.dump_lambda then fprintf ppf "%a@." Printlambda.lambda slam;
+  let (init_code, fun_code) = Bytegen.compile_phrase slam in
+  if !Clflags.dump_instr then
+    fprintf ppf "%a%a@."
+    Printinstr.instrlist init_code
+    Printinstr.instrlist fun_code;
+  let (code, code_size, reloc) = Emitcode.to_memory init_code fun_code in
+  let can_free = (fun_code = []) in
+  let initial_symtable = Symtable.current_state() in
+  Symtable.patch_object code reloc;
+  Symtable.check_global_initialized reloc;
+  Symtable.update_global_table();
+  try
+    let retval = (Meta.reify_bytecode code code_size) () in
+    if can_free then begin
+      Meta.static_release_bytecode code code_size;
+      Meta.static_free code;
+    end;
+    retval
+  with x ->
+    if can_free then begin
+      Meta.static_release_bytecode code code_size;
+      Meta.static_free code;
+    end;
+    Symtable.restore_state initial_symtable;
+    raise x
+
+
+let run' exp =
+  let exp = Trx.check_scope_extrusion exp in
+  if !initial_env = Env.empty then initial_env := Compile.initial_env();
+  Ctype.init_def(Ident.current_time()); 
+  with_disabled_warnings [Warnings.Partial_match "";
+			  Warnings.Unused_argument;
+			  Warnings.Unused_var "";
+			  Warnings.Unused_var_strict ""]
+ (fun () ->
+   let sstr = [{pstr_desc = Pstr_eval exp; pstr_loc = Location.none}] in
+   let str = try
+    begin
+       Typecore.reset_delayed_checks ();
+       let (str, sg, newenv) = Typemod.type_toplevel_phrase !initial_env sstr in
+       Typecore.force_delayed_checks (); str
+    end
+   with 
+    x -> (Errors.report_error Format.std_formatter x;
+	  Format.pp_print_newline Format.std_formatter ();
+	  failwith 
+            "Error type-checking generated code: scope extrusion?")
+  in
+  let lam = Translmod.transl_toplevel_definition str in
+  load_lambda Format.std_formatter lam
+ )
+
+let run exp =
+  let exp = cde_repr exp in		(* reveal concerete representation *)
+  Obj.obj (run' exp)
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/runcode.mli ocaml-4.00.1/ber-metaocaml-100/runcode.mli
--- ocaml-4.00.1.orig/ber-metaocaml-100/runcode.mli	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/runcode.mli	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,13 @@
+(* Given a closed code expression, compile and run it, returning
+   its result or propagating raised exceptions.
+*)
+
+type 'a cde = {cde : 'c. ('c,'a) code}  (* Type of the closed code *)
+
+val cde_repr : 'a cde -> Parsetree.expression
+
+val run : 'a cde -> 'a
+
+(* legacy, to be removed ZZZ *)
+val run' : Parsetree.expression -> Obj.t
+
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/simple.ref ocaml-4.00.1/ber-metaocaml-100/simple.ref
--- ocaml-4.00.1.orig/ber-metaocaml-100/simple.ref	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/simple.ref	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,54 @@
+BER MetaOCaml toplevel, version N 100
+        OCaml version 4.00.1
+
+#         val tr1 : ('cl, 'a -> int) code = .<fun x_1 -> 1>. 
+# * *   val tr1' : ('cl, 'a -> 'b -> 'b) code = .<fun x_2 -> fun x_3_4 -> x_3_4>. 
+# * *   val tr2 : ('cl, 'a -> int) code = .<fun x_5 -> 1>. 
+# * *     Characters 90-98:
+  let tr3 = .<fun x -> .~(let x = .! .<x>. in .<x>.)>.;;
+                                  ^^^^^^^^
+Error: .! error: 'cl not generalizable in ('cl, 'a) code
+
+#   * * * *   Error was expected
+- : unit = ()
+#   Characters 16-27:
+  .< fun x -> .~ (.!.< x >.) >.;;
+                 ^^^^^^^^^^^
+Error: .! occurs check error: 'cl occurs in ('cl, ('cl, 'a) code) code
+# * * * * *   Error was expected
+- : unit = ()
+#   Characters 36-37:
+  let tr4 = .<fun x -> .~(let x = .! x in .<x>.)>.;;
+                                     ^
+Error: Wrong level: variable bound at level 1 and used at level 0
+# * * * * *   Error was expected
+- : unit = ()
+#   val tr5 : ('cl, 'a -> int) code = .<fun x_6 -> .!.<1>.>. 
+# * *   #   val tr6 : ('cl, 'a -> 'a) code = .<fun x_7 -> .!.<x_7>.>. 
+# * *   #   Characters 22-26:
+  let tr7 = .<fun x -> .! x>.;;
+                       ^^^^
+Error: .! error: 'cl not generalizable in ('cl, 'a) code
+
+# * * * * *   Error was expected
+- : unit = ()
+#     val tr8 : ('cl, 'a -> ('cl, 'a) code) code = .<
+  fun x_8 -> (* cross-stage persistent value (id: y) *)>. 
+# * * *     Characters 152-158:
+  let tr8r = .! tr8;;
+             ^^^^^^
+Error: .! occurs check error: 'cl occurs in ('cl, 'a -> ('cl, 'a) code) code
+# * * * * *   Error was expected
+- : unit = ()
+#     val tm1 : ('cl, 'a -> ('cl0, 'a) code) code = .<fun x_9 -> .<x_9>.>. 
+# * *         val tg1 : '_a list ref = {contents = []}
+# * * *   val tg2 : '_a list ref = {contents = []}
+# * * *         * * * *     * * * * * * * * * * * * * * * * * *       val tfc1 : int Runcode.cde = .<1>. 
+#   #   val tfc2 : ('cl, int Runcode.cde) code = .<{Runcode.cde = .<1>.}>. 
+# * *   val tfc3 : int Runcode.cde = .<1>. 
+#   val tfc4 : int Runcode.cde Runcode.cde = .<{Runcode.cde = .<1>.}>. 
+#   val tfc5 : int Runcode.cde = .<1>. 
+#   #     
+All Done
+- : unit = ()
+# 
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/test/bool2.ml ocaml-4.00.1/ber-metaocaml-100/test/bool2.ml
--- ocaml-4.00.1.orig/ber-metaocaml-100/test/bool2.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/test/bool2.ml	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,8 @@
+type ('a,'b) staged = Now of 'b | Later of ('a, 'b) code
+
+(* It is the *presence* of this module with a nested module which 
+ * causes the failure, even though it is empty and not used! *)
+module XXX = struct
+  module TT = struct
+  end
+end
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/test/pythagorian_triples.ml ocaml-4.00.1/ber-metaocaml-100/test/pythagorian_triples.ml
--- ocaml-4.00.1.orig/ber-metaocaml-100/test/pythagorian_triples.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/test/pythagorian_triples.ml	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,87 @@
+(* Test of the let! notation: Fair monad for non-determinism *)
+
+module NonDet : sig
+  type 'a stream_v
+  type 'a stream = unit -> 'a stream_v
+
+  val ret  : 'a -> 'a stream
+  val fail : 'a stream
+
+      (* a.k.a bind or disjunction *)
+  val (let!) : 'a stream -> ('a -> 'b stream) -> 'b stream
+      (* a.k.a. fair disjunction *)
+  val mplus  : 'a stream -> 'a stream -> 'a stream
+
+  val guard  : bool -> unit stream
+  val yield  : 'a stream -> 'a stream
+
+  val run : int ->             (* upper bound on the number of solutions *)
+            'a stream ->
+	    'a list
+end = struct
+  type 'a stream_v = 
+    Nil | Cons of 'a * 'a stream | InC of 'a stream
+  and 'a stream = unit -> 'a stream_v
+
+  let fail  = fun () -> Nil
+  let ret a = fun () -> Cons (a,fail)
+
+  (* actually, interleave: a fair disjunction with breadth-first search*)
+  let rec mplus a b = fun () -> 
+    match a () with
+    | Nil          -> InC b
+    | Cons (a1,a2) -> Cons (a1,(mplus b a2))
+    | InC a -> 
+	begin match b () with
+	| Nil   -> InC a
+        | InC b -> InC (mplus a b)
+        | Cons (b1,b2) -> Cons (b1, (mplus a b2))
+	end
+
+  (* a fair conjunction *)
+  let rec (let!) m f = fun () -> 
+    match m () with
+    | Nil        -> fail ()
+    | InC a      -> InC ((let!) a f)
+    | Cons (a,b) -> mplus (f a) ((let!) b f) ()
+
+  let guard be = if be then ret () else fail
+  let yield m  () = InC m
+
+  let rec run n m = 
+    if n = 0 then [] else
+    match m () with
+    | Nil -> []
+    | InC a -> run n a
+    | Cons (a,b) -> (a::run (n-1) b)
+end;;
+
+open NonDet;;
+
+(* The example uses left recursion and truly infinite streams! *)
+(* Don't try this in Prolog or in Haskell's MonadPlus. *)
+
+let rec numb () = 			(* infinite stream of integers *)
+    yield (mplus (let! n = numb in ret (n+1))         (* left recursion! *)
+	       (ret 0)) ()
+;;
+
+let pyth : (int * int * int) NonDet.stream =
+  let! i  = numb in
+  let! () = guard (i>0) in
+  let! j  = numb in
+  let! () = guard (j>0) in
+  let! k  = numb in
+  let! () = guard (k>0) in
+  (* Just to illustrate the `let' form within let! *)
+  let test x = x*x = j*j + k*k in
+  let! () = guard (test i) in
+  ret (i,j,k)
+;;
+
+let [(5, 4, 3); (5, 3, 4); (10, 8, 6); (10, 6, 8); (13, 12, 5); (13, 5, 12);
+     (15, 12, 9); (15, 9, 12); (17, 15, 8); (17, 8, 15)]
+ =
+run 10 pyth;;
+
+print_endline "\nAll done";;
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/test/quick_test.ml ocaml-4.00.1/ber-metaocaml-100/test/quick_test.ml
--- ocaml-4.00.1.orig/ber-metaocaml-100/test/quick_test.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/test/quick_test.ml	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,615 @@
+(* Quick test of BER MetaOCaml. From PEPM09 and PEPM08 papers:
+
+     Closing the Stage: From staged code to typed closures.
+     Yukiyoshi Kameyama, Oleg Kiselyov, and Chung-chieh Shan
+
+*)
+
+(* ---------------------------------------------------------------------- *)
+(* The power example, Sec 2 *)
+
+let square x = x * x
+let rec power : int -> ('a,int) code -> ('a,int) code = 
+   fun n -> fun x ->
+    if n = 0 then .<1>.
+       else if n mod 2 = 0 
+           then .< (*csp*)square .~(power (n/2) x)>.
+           else .<.~x * .~(power (n-1) x)>.
+;;
+let power7_cde = .<fun x -> .~(Printf.printf "power\n"; power 7 .<x>.)>.;;
+(* "power" printed once *)
+(*
+val power7_cde : ('cl, int -> int) code = .<
+  fun x_41 ->
+   (x_41 *
+     (((* cross-stage persistent value (id: square) *))
+       (x_41 *
+         (((* cross-stage persistent value (id: square) *)) (x_41 * 1)))))>.
+*)
+let power7 : int -> int = .! power7_cde;;
+let (128, 2187) = (power7 2, power7 3);;
+(* nothing is printed...
+  val res : int * int = (128, 2187)
+*)
+
+(* The following won't work, 
+let power7 : int -> int = 
+  .! .<fun x -> .~(Printf.printf "power\n"; power 7 .<x>.)>.;;
+*)
+
+(* But the following does. It will become the standard *)
+let power7 : int -> int = 
+  Runcode.run {Runcode.cde= 
+               .<fun x -> .~(Printf.printf "power\n"; power 7 .<x>.)>.};;
+(* "power" printed once *)
+let (128, 2187) = (power7 2, power7 3);;
+(* nothing is printed...
+  val res : int * int = (128, 2187)
+*)
+
+
+(* ---------------------------------------------------------------------- *)
+(* The ef example. *)
+
+(* The source code *)
+let ef = fun z -> .<fun x -> .~z + x>.;;
+let ef1 = .<fun y -> .~(ef .<y>.)>.;;
+(*
+  val ef1 : ('a, int -> int -> int) code =
+  .<fun y_1 -> fun x_2 -> (y_1 + x_2)>.
+*)
+let 5 = (.! ef1) 2 3;; (* 5 *)
+
+let ef2 = .<fun x -> fun y -> .~(ef .<x*y>.)>.;;
+(*
+ val ef2 : ('a, int -> int -> int -> int) code =
+  .<fun x_1 -> fun y_2 -> fun x_3 -> ((x_1 * y_2) + x_3)>.
+*)
+let 10 = (.! ef2) 2 3 4;; (* 10 *)
+
+(* ---------------------------------------------------------------------- *)
+(* The eta example. *)
+
+let (5,10,34) = 
+  let eta f = .<fun x -> .~(f .<x>.)>. in
+    (Runcode.run 
+       {Runcode.cde= .< fun y ->         
+             .~(eta (fun z -> .< .~z + y   >.)) >.})
+    2 3,
+    (Runcode.run
+       {Runcode.cde= .< fun y -> fun w -> 
+             .~(eta (fun z -> .< .~z + y*w >.)) >.})
+    2 3 4,
+    (Runcode.run
+       {Runcode.cde= .< fun x u -> 
+             .~(eta (fun z -> .<fun y -> .~z + u*x*y >.)) >.})
+    2 3 4 5
+ ;;
+
+
+(* ---------------------------------------------------------------------- *)
+(* Cross-stage presistence *)
+
+(* This example includes persistence of a code value, which we
+ specifically exclude in the paper. *)
+
+let cspe =
+.<fun x -> .~(let u = .<x>. in 
+     (.! .<fun y -> .<.~u>.>.) ()) >.;;
+
+(*
+    val cspe : ('cl, 'a -> 'a) code = .<fun x_1 -> x_1>.
+*)
+
+let 42 = (.! cspe) 42;;
+
+(* This CSP example does fit our restriction *)
+
+let rec scspe x = .<(fun y -> x) (scspe 1)>.;;
+(*
+val scspe : int -> ('a, int) code = <fun>
+# scspe 10;;
+- : ('a, int) code =
+.<((fun y_1 -> 10) (((* cross-stage persistent value (as id: scspe) *)) 1))>.
+# .! (scspe 10);;
+- : int = 10
+*)
+
+let 10 = .! (scspe 10);;
+
+(* ---------------------------------------------------------------------- *)
+(* Scope extrusion via mutable state *)
+
+(*
+let extr = let x = ref .<1>. in
+    let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+    !x;;
+
+(* It does type-check ... but printing it produces an error *)
+
+Failure("Scope extrusion at Characters 65-66:\n      let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in\n                                   ^\n for the identifier v_64 bound at Characters 50-51:\n      let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in\n                    ^\n")
+*)
+
+(* Previously:
+    val extr : ('a, int) code = .<v_1>.
+
+    # .! extr ;;
+    Unbound value v_1
+    Exception: Trx.TypeCheckingError.
+*)
+
+(* The run-time error is reported on an attempt to run the code *)
+let true = 
+ try .! (let x = ref .<1>. in
+    let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+    !x); false
+ with Failure e -> print_string e; true
+;;
+(*
+Scope extrusion at Characters 75-76:
+      let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+                                   ^
+ for the identifier v_66 bound at Characters 60-61:
+      let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+                    ^
+*)
+
+(* The run-time error is reported on an attempt to splice the code *)
+let true = 
+ try let x = ref .<1>. in
+     let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+     .<1 + .~(!x)>.; false     (* triggers an error with the message below *)
+ with Failure e -> print_string e; true
+;;
+(*
+Scope extrusion at Characters 72-73:
+       let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+                                    ^
+ for the identifier v_67 bound at Characters 57-58:
+       let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+                     ^
+*)
+
+
+(*
+ *  In this example, we compute a staged power function while tracking how many
+ *  multiplications the generated code performs.  This example demonstrates the
+ *  utility of our environment-passing translation, in two ways.  First, it is
+ *  easiest to write this example if we use a side effect such as mutable state
+ *  in MetaOCaml, but such an extension (a piece of state of type int) has not
+ *  been shown sound except through our translation.  Second, we can write this
+ *  example in pure MetaOCaml (more awkwardly) using our translation.
+ *
+ *  Thanks to Olivier Danvy for suggesting this example.
+ *)
+
+let rec powerc = function
+    | 0 -> (.<fun x -> 1>.,0)
+    | 1 -> (.<fun x -> x>.,1)
+    | n -> let (c,n1) = powerc (pred n) in
+           (.<fun x -> (.~c x) * x>.,succ n1)
+;;
+(*
+  val powerc : int -> ('a, int -> int) code * int = <fun>
+*)
+
+let test = powerc 5;;
+(*
+val test : ('a, int -> int) code * int =
+  (.<fun x_5 ->
+   (((fun x_4 ->
+       (((fun x_3 ->
+           (((fun x_2 -> (((fun x_1 -> x_1) x_2) * x_2)) x_3) * x_3)) x_4) *
+         x_4)) x_5) * x_5)>.,
+   5)
+*)
+
+let 32 = (.! (fst test)) 2;;
+(*
+val testc : int = 32
+*)
+
+let mul x y = .<.<.~.~x * .~.~y>.>.;;
+(*
+val mul :
+  ('cl, ('cl0, int) code) code ->
+  ('cl, ('cl0, int) code) code -> ('cl, ('cl0, int) code) code = <fun>
+*)
+
+let rec powerd = function
+    | 0 -> (.<fun x -> .<1>.>.,0)
+    | 1 -> (.<fun x -> x>.,1)
+    | n -> let (c,n1) = powerd (pred n) in
+           (.<fun x -> .~(mul .<.~c x>. .<x>.)>.,succ n1)
+;;
+(*
+ val powerd : int -> ('cl, ('cl0, int) code -> ('cl0, int) code) code * int
+*)
+
+let test1 = powerd 5;;
+(*
+val test1 : ('a, ('_b, int) code -> ('_b, int) code) code * int =
+  (.<fun x_5 ->
+   .<(.~((fun x_4 ->
+           .<(.~((fun x_3 ->
+                   .<(.~((fun x_2 -> .<(.~((fun x_1 -> x_1) x_2) * .~x_2)>.)
+                          x_3) * .~x_3)>.) x_4) * .~x_4)>.) x_5) * .~x_5)>.>.,
+   5)
+*)
+
+let testd = .! (fst (powerd 5));;
+let testdd = .<fun x -> .~(testd .<x>.)>.;;
+(*
+val testdd : ('_a, int -> int) code =
+  .<fun x_1 -> ((((x_1 * x_1) * x_1) * x_1) * x_1)>.
+*)
+
+(* An attempt to write testd without overt use of multiple levels:
+   no nested brackets.
+*)
+let one = .<1>.;;
+let mul1 x y = .<.~x * .~y>.;;
+let mull x y = .<mul1 .~x  .~y>.;;
+
+let rec powerd1 = function
+    | 0 -> (.<fun x -> one>.,0)
+    | 1 -> (.<fun x -> x>.,1)
+    | n -> let (c,n1) = powerd1 (pred n) in
+           (.<fun x -> .~(mull .<.~c x>. .<x>.)>.,succ n1)
+;;
+(*
+  val powerd1 : int -> ('cl, ('a, int) code -> ('a, int) code) code * int =
+*)
+
+let test11 = powerd1 5;;
+(*
+val test11 : ('a, ('_b, int) code -> ('_b, int) code) code * int =
+  (.<fun x_5 ->
+   (((* cross-stage persistent value (as id: mul1) *))
+     ((fun x_4 ->
+        (((* cross-stage persistent value (as id: mul1) *))
+          ((fun x_3 ->
+             (((* cross-stage persistent value (as id: mul1) *))
+               ((fun x_2 ->
+                  (((* cross-stage persistent value (as id: mul1) *))
+                    ((fun x_1 -> x_1) x_2) x_2)) x_3) x_3)) x_4) x_4)) x_5)
+     x_5)>.,
+   5)
+*)
+
+let testd1 () = .! (fst (powerd1 5));;
+let testdd1 = .<fun x -> .~(testd1 () .<x>.)>.;;
+(*
+val testdd1 : ('cl, int -> int) code =
+  .<fun x_1 -> ((((x_1 * x_1) * x_1) * x_1) * x_1)>.
+*)
+let 32 = (Runcode.run {Runcode.cde= .<fun x -> .~(testd1 () .<x>.)>.}) 2;;
+
+
+(* Meta-programming with delimited continuations *)
+(* Writing an efficient specialized version of Gibonacci,
+   without using any fix-point combinators, etc.
+*)
+
+open Printf;;
+
+(* The original Gibonacci *)
+
+let rec gib x y n =
+  if n = 0 then x else 
+  if n = 1 then y else
+  gib x y (n-1) + gib x y (n-2) 
+;;
+let 8 = gib 1 1 5;;
+
+(* Naively staged Gibonacci, to the statically known value of n *)
+
+let rec gibgen x y n =
+  if n = 0 then x else 
+  if n = 1 then y else
+  .<.~(gibgen x y (n-1)) + .~(gibgen x y (n-2))>.
+;;
+(* 
+  val gibgen : ('cl, int) code -> ('cl, int) code -> int -> ('cl, int) code 
+*)
+let test_gibgen n = .<fun x y -> .~(gibgen .<x>. .<y>. n)>.;;
+(* val test_gibgen : int -> ('a, int -> int -> int) code = <fun> *)
+let test_gibgen5 = test_gibgen 5;;
+(*
+val test_gibgen5 : ('a, int -> int -> int) code =
+  .<fun x_1 ->
+   fun y_2 -> ((((y_2 + x_1) + y_2) + (y_2 + x_1)) + ((y_2 + x_1) + y_2))>.
+*)
+let 8 = (.! test_gibgen5) 1 1;;
+
+(* Clearly, the naive Gibonacci is inefficient. 
+   The specialized code test_gibgen5 shows why:
+   the computation (y_2 + x_1) is repeated thrice within such a short fragment
+*)
+
+(* To improve Gibonacci, we have to add memoization *)
+
+(* First we define the abstract data types of memoization table 
+   with integer keys *)
+
+(* For the sake of the closest correspondence with circle-shift.elf,
+   we use pairs to emulate 'a option data type. In the rest of the
+   code, 'a maybe is an abstract data type.
+*)
+module Maybe :
+ sig
+   type 'a maybe
+   val nothing   : 'a maybe
+   val just      : 'a -> 'a maybe
+   val ifnothing : 'a maybe -> bool
+   val fromjust  : 'a maybe -> 'a
+ end = struct
+   type 'a maybe  = bool * (unit -> 'a)
+   let nothing    = (true,  fun () -> failwith "nothing")
+   let just x     = (false, fun () -> x)
+   let ifnothing  = fst
+   let fromjust x = snd x ()
+end;;
+open Maybe;;
+
+module Memo :
+ sig
+   type 'a memo
+   val empty  : 'a memo
+   val lookup : int -> 'a memo -> 'a maybe
+   val ext    : 'a memo -> int -> 'a -> 'a memo
+ end = struct
+   (* The following implementation uses functions, for compatibility
+      with circle-shift.elf. The rest of the code does not depend
+      on the implementation and can't even know it.
+    *)
+   type 'a memo = int -> 'a maybe
+   let empty    = fun key -> nothing
+   let lookup   = fun n table -> table n
+   let ext      = fun table n v -> 
+                     fun key -> if key = n then just v else table key
+end;;
+open Memo;;
+
+(* we can write the standard, textbook memoizer *)
+(* It memoizes the result of the application of function f to the integer n.
+ *)
+
+let new_memo () =
+  let table = ref empty in
+  fun f n ->
+    let r = lookup n !table in
+    if ifnothing r 
+    then                                (* memo table miss *)
+      let v = f n in			(* compute the value *)
+      table := ext !table n v; v
+    else fromjust r			(* else return the memoized value *)
+;;
+
+
+(* Now we can memoize Gibonacci and obtain an improved version *)
+let gibo x y =
+  let memo = new_memo () in
+  let rec loop n =
+    if n = 0 then x else 
+    if n = 1 then y else
+    memo loop (n-1) + memo loop (n-2)
+ in loop
+;;
+
+let 8  = gibo 1 1 5;;  (* 8 *)
+let 1346269 = gibo 1 1 30;;
+(* 1346269, without memoization it would've taken a while...*)
+
+(* We may try to stage it, naively *)
+
+let sgibo_naive x y =
+  let memo = new_memo () in
+  let rec loop n =
+    if n = 0 then x else 
+    if n = 1 then y else
+    .<.~(memo loop (n-1)) + .~(memo loop (n-2))>.
+ in loop
+;;
+
+let test_sgibo_naive5  = 
+  .<fun x y -> .~(sgibo_naive .<x>. .<y>. 5)>.;;
+(*
+  val test_sgibo_naive5 : ('a, int -> int -> int) code =
+  .<fun x_1 ->
+   fun y_2 -> ((((y_2 + x_1) + y_2) + (y_2 + x_1)) + ((y_2 + x_1) + y_2))>.
+*)
+
+(* Alas, the result shows the duplication of computations. The result of
+  loop, in sgibo_naive, is a present-stage value but future-stage
+  computation. We saved effort at the present stage but we saved no
+  computation at the future stage. We need let insertion to save 
+  future-stage computations.
+*)
+
+(* But the let-insertion isn't that easy! The naive version *)
+
+let sgibo1_naive x y =
+  let memo = new_memo () in
+  let rec loop n =
+    if n = 0 then x else 
+    if n = 1 then y else
+    .<let t1 = .~(memo loop (n-1)) and t2 = .~(memo loop (n-2))
+      in t1 + t2>.
+ in loop
+;;
+
+let true =
+ try
+ let test_sgibo1_naive5  = 
+  .<fun x y -> .~(sgibo1_naive .<x>. .<y>. 5)>.
+ in false
+ with Failure e -> print_string e; true
+;;
+ 
+(* Previously, it worked:
+
+  val test_sgibo1_naive5 : ('a, int -> int -> int) code =
+  .<fun x_1 ->
+   fun y_2 ->
+    let t1_3 =
+     let t1_5 =
+      let t1_7 = let t1_9 = y_2 and t2_10 = x_1 in (t1_9 + t2_10)
+      and t2_8 = y_2 in
+      (t1_7 + t2_8)
+     and t2_6 = let t1_9 = y_2 and t2_10 = x_1 in (t1_9 + t2_10) in
+     (t1_5 + t2_6)
+    and t2_4 =
+     let t1_7 = let t1_9 = y_2 and t2_10 = x_1 in (t1_9 + t2_10)
+     and t2_8 = y_2 in
+     (t1_7 + t2_8) in
+    (t1_3 + t2_4)>.
+*)
+(* the naive version obviously doesn't do any good: It creates even bigger
+   duplicated computations *)
+(* But now it raises the exception
+Scope extrusion at Characters 127-201:
+  .........................string e; true
+  ;;
+   for the identifier t2_138 bound at Characters 160-162:
+*)
+  
+(* We have to change the memo table implementation. Our memo table should
+   contain only those future-stage computations that are future-stage
+   values. So, we need to do let-insertion after we detected a miss.
+   But for that, we have to re-write everything in CPS. We have to write
+   the memo-table implementation in CPS:
+*)
+   
+let new_memo_let_CPS () =
+  let table = ref empty in
+  fun f n k ->
+    let r = lookup n !table in
+    if ifnothing r 
+    then                                (* memo table miss *)
+      f n 				(* compute the value *)
+       (fun v -> .<let t = .~v in 
+                     .~(table := ext !table n .<t>.; k .<t>.)>.)
+    else k (fromjust r)			(* else return the memoized value *)
+;;
+
+(* but we also must re-write sgibo in CPS! *)
+
+let sgibo_CPS x y =
+  let memo = new_memo_let_CPS () in
+  let rec loop n k =
+    if n = 0 then k x else 
+    if n = 1 then k y else
+    memo loop (n-1) (fun r1 ->
+    memo loop (n-2) (fun r2 ->
+    k .<.~r1 + .~r2>.))
+  in loop
+;;
+
+let test_sgibo_CPS5  = 
+  .<fun x y -> .~(sgibo_CPS .<x>. .<y>. 5 (fun x ->x))>.;;
+
+(*
+  val test_sgibo_CPS5 : ('a, int -> int -> int) code =
+  .<fun x_1 ->
+   fun y_2 ->
+    let t_3 = y_2 in
+    let t_4 = x_1 in
+    let t_5 = (t_3 + t_4) in
+    let t_6 = (t_5 + t_3) in let t_7 = (t_6 + t_5) in (t_7 + t_6)>.
+*)
+let 8 = (.! test_sgibo_CPS5) 1 1;;
+
+(* Now we get the desired result: no duplicate computations.
+   At the cost of changing all of our code, even sgibo, in CPS.
+   Memoization is no longer easy -- it becomes very intrusive.
+*)
+
+(* Not only this approach inconvenient, it is also unsafe.
+   The mutation in maintaining the table in new_memo_let_CPS
+   results in unsafety. We store in the `global' memo table code
+   values like .<t>. -- with variables bound in the scope 
+   that is more narrow than the dynamic scope of the table.
+ *)
+
+(* Let's make a simple `pessimization' of sgibo1_CPS. Let's suppose the
+   programmer didn't want to rewrite gib in CPS, and continued to use
+   memoization in `direct style'.
+*)
+
+let sgibo1_bad x y =
+  let memo = new_memo_let_CPS () in
+  let rec loop n =
+    if n = 0 then x else 
+    if n = 1 then y else
+    .<.~(memo (fun n k -> k (loop n)) (n-1) (fun x ->x)) + 
+      .~(memo (fun n k -> k (loop n)) (n-2) (fun x ->x))>.
+ in loop
+;;
+
+let true =
+ try
+   let test_sgibo1_bad  = 
+     .<fun x y -> .~(sgibo1_bad .<x>. .<y>. 5)>. in
+   false
+ with Failure e -> print_string e; true
+;;
+
+(* Previously (before version N100) it worked:
+  val test_sgibo1_bad : ('a, int -> int -> int) code =
+  .<fun x_1 ->
+   fun y_2 ->
+    (let t_7 = (t_6 + t_5) in t_7 +
+      let t_6 =
+       (let t_5 = (t_3 + let t_4 = x_1 in t_4) in t_5 + let t_3 = y_2 in t_3) in
+      t_6)>.
+*)
+
+(* Although the result appears efficient -- only four additions --
+   it is incorrect! Please notice how variable t_6 is referenced before
+   it is bound. Attempting to run this code gives
+
+.! test_sgibo1_bad;;
+  Unbound value t_6
+  Exception: Trx.TypeCheckingError.
+*)
+
+(* But now we get a scope extrusion error
+Scope extrusion at Characters 302-303:
+   for the identifier t_152 bound at Characters 242-243:
+*)
+
+(* To rely on MetaOCaml's type soundness, we must not use any side effects
+   in our code generator.  We could write our memoizing gib without state,
+   by including state-passing in our continuation-passing, as follows.
+*)
+
+let new_memo_let_CPS_only f n k table =
+   let r = lookup n table in
+   if ifnothing r
+   then
+     f n
+      (fun v table -> .<let t = .~v in
+                    .~(k .<t>. (ext table n .<t>.))>.)
+      table
+   else
+     k (fromjust r) table
+;;
+
+let sgibo_CPS_only x y =
+  let memo = new_memo_let_CPS_only in
+  let rec loop n k =
+    if n = 0 then k x else 
+    if n = 1 then k y else
+    memo loop (n-1) (fun r1 ->
+    memo loop (n-2) (fun r2 ->
+    k .<.~r1 + .~r2>.))
+  in loop
+;;
+
+let test_sgibo_CPS_only5  = 
+  .<fun x y -> .~(sgibo_CPS_only .<x>. .<y>. 5 (fun r table -> r) empty)>.;;
+
+let 8 = (.! test_sgibo_CPS_only5) 1 1;;
+
+Printf.printf "\nAll Done\n";;
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/test/simple.ml ocaml-4.00.1/ber-metaocaml-100/test/simple.ml
--- ocaml-4.00.1.orig/ber-metaocaml-100/test/simple.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/test/simple.ml	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,147 @@
+(* Various simple (one-liner) examples and NON-examples  *)
+
+(* Safety of run *)
+
+let tr1 = .<fun x -> .~(.! .<.<1>.>.)>.;;
+(*
+val tr1 : ('a, 'b -> int) code = .<fun x_36 -> 1>.
+*)
+let tr1' = .<fun x -> .~(.! .<.<fun x -> x>.>.)>.;;
+(*
+val tr1' : ('cl, 'a -> 'b -> 'b) code = .<fun x_2 -> fun x_3_4 -> x_3_4>. 
+*)
+let tr2 = .<fun x -> .~(let x = .! .<1>. in .<x>.)>.;;
+(*
+val tr2 : ('a, 'b -> int) code = .<fun x_37 -> 1>.
+*)
+
+let tr3 = .<fun x -> .~(let x = .! .<x>. in .<x>.)>.;;
+
+(*
+  let tr3 = .<fun x -> .~(let x = .! .<x>. in .<x>.)>.;;
+                                     ^^^^^
+Error: .! error: 'a not generalizable in ('a, 'b) code
+*)
+print_endline "Error was expected";;
+
+.< fun x -> .~ (.!.< x >.) >.;;
+(*
+Characters 15-26:
+  .< fun x -> .~ (.!.< x >.) >.;;
+                 ^^^^^^^^^^^
+Error: .! occurs check error: 'cl occurs in ('cl, ('cl, 'a) code) code
+*)
+print_endline "Error was expected";;
+
+let tr4 = .<fun x -> .~(let x = .! x in .<x>.)>.;;
+(*
+Characters 35-36:
+  let tr4 = .<fun x -> .~(let x = .! x in .<x>.)>.;;
+                                     ^
+Error: Wrong level: variable bound at level 1 and used at level 0
+*)
+print_endline "Error was expected";;
+
+let tr5 = .<fun x -> .! .<1>.>.;;
+(*
+val tr5 : ('a, 'b -> int) code = .<fun x_38 -> .!.<1>.>.
+*)
+let 1 = (.! tr5) true;;
+
+let tr6 = .<fun x -> .! .<x>.>.;;
+(*
+val tr6 : ('a, 'b -> 'b) code = .<fun x_39 -> .!.<x_39>.>.
+*)
+let 1 = (.! tr6) 1;;
+
+let tr7 = .<fun x -> .! x>.;;
+(*
+Characters 24-25:
+  let tr7 = .<fun x -> .! x>.;;
+                          ^
+Error: .! error: 'a not generalizable in ('a, 'b) code
+*)
+print_endline "Error was expected";;
+
+ (* Bizzare CSP *)
+let tr8 = .<fun x -> .~(let y = .<x>. in .<y>.)>.;;
+(*
+val tr8 : ('a, 'b -> ('a, 'b) code) code =
+  .<fun x_41 -> (* cross-stage persistent value (as id: y) *)>.
+*)
+(* But it cannot be run! *)
+let tr8r = .! tr8;;
+(*
+Characters 14-17:
+  let tr8r = .! tr8;;
+                ^^^
+Error: .! occurs check error: 'a occurs in ('a, 'b -> ('a, 'b) code) code
+*)
+print_endline "Error was expected";;
+
+
+let tm1 = .<fun x -> .< x >. >.;;
+(*
+val tm1 : ('a, 'b -> ('c, 'b) code) code = .<fun x_35 -> .<x_35>.>.
+*)
+
+(* Generalization *)
+
+let tg1 = .! ((fun x -> .<x>.) (ref []));;
+(*
+val tg1 : '_a list ref = {contents = []}
+   should not be polymorphic!
+*)
+let tg2 = .! .<ref []>.;;
+(*
+val tg2 : '_a list ref = {contents = []}
+   should not be polymorphic!
+*)
+
+(* First-class polymorphism *)
+
+(* Recall, in runcode.mli:
+
+type 'a cde = {cde : 'c. ('c,'a) code}  (* Type of the closed code *)
+
+*)
+
+(* In all previous versions of MetaOCaml, up to BER N004:
+
+# Runcode.run;;
+- : 'a Runcode.cde -> 'a = <fun>
+# {Runcode.cde = .<1>.};;
+- : int Runcode.cde = .<1>.
+# Runcode.run {Runcode.cde = .<1>.};;
+- : int = 1
+# .<{Runcode.cde = .<1>.}>.;;
+- : ('a, int Runcode.cde) code = .<{Runcode.cde = .<1>.}>.
+# .! .<{Runcode.cde = .<1>.}>.;;
+Characters 22-23:
+  .! .<{Runcode.cde = .<1>.}>.;;
+                        ^
+Error: This expression has type ('a, int) code
+       but an expression was expected of type ('b, int) code
+
+Exception: Trx.TypeCheckingError.
+*)
+
+(* Now *)
+let tfc1 = {Runcode.cde = .<1>.};;
+(* - : int Runcode.cde = .<1>. *)
+let 1 = Runcode.run {Runcode.cde = .<1>.};;
+
+let tfc2 = .<{Runcode.cde = .<1>.}>.;;
+(*
+- : ('cl, int Runcode.cde) code = .<{Runcode.cde = .<1>.}>. 
+*)
+let tfc3 = .! .<{Runcode.cde = .<1>.}>.;;
+(* - : int Runcode.cde = .<1>.  *)
+let tfc4 = {Runcode.cde= .<{Runcode.cde = .<1>.}>.};;
+(* - : int Runcode.cde Runcode.cde = .<{Runcode.cde = .<1>.}>.  *)
+let tfc5 = Runcode.run {Runcode.cde= .<{Runcode.cde = .<1>.}>.};;
+(* - : int Runcode.cde = .<1>.  *)
+let 1 = Runcode.run (Runcode.run {Runcode.cde= .<{Runcode.cde = .<1>.}>.});;
+(* - : int = 1 *)
+
+Printf.printf "\nAll Done\n";;
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/test/simple_true.ml ocaml-4.00.1/ber-metaocaml-100/test/simple_true.ml
--- ocaml-4.00.1.orig/ber-metaocaml-100/test/simple_true.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/test/simple_true.ml	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,135 @@
+(* Various simple tests, all should pass. Whenever an error is discovered,
+   please add here.
+*)
+
+(* From Problems.txt  Wed Oct  2 08:39:04 BST 2002
+  Occurrences of a csp value share the same instantiated type
+*)
+
+let f1 x = x;;                             (* polymophic *)
+let t1 = .<(f1 1, f1 true)>.;;
+(*
+val t1 : ('cl, int * bool) code = .<
+  (((((* cross-stage persistent value (id: f1) *)) 1)),
+   ((((* cross-stage persistent value (id: f1) *)) true)))>.
+*)
+let (1,true) = .! t1;;
+
+(* From Problems.txt Thu Oct 24 09:55:36 BST 2002
+  CSP at level n+2 gives Segmentation fault
+*)
+(* use f1 above *)
+let t2 = .<(.<f1 1>., .<f1 true>.)>.;;
+(*
+val t2 : ('cl, ('cl0, int) code * ('cl1, bool) code) code = .<
+  ((.<(((* cross-stage persistent value (id: f1) *)) 1)>.),
+   (.<(((* cross-stage persistent value (id: f1) *)) true)>.))>.
+*)
+let 1 = .! (fst (.! t2));;
+let true = .! (snd (.! t2));;
+
+(* From Problems.txt Mon Nov 25 10:10:32 GMT 2002
+  CSP of array ops gives internal errors
+*)
+
+let t3 = .<Array.get [|1|] 0>.;;
+(*
+val t3 : ('cl, int) code = .<([|1|]).(0)>. 
+*)
+let 1 = .! t3;;
+
+(* From Problems.txt Tue Jan 20 12:18:00 GMTST 2004
+  typechecker broken for csp ids, e.g. we get the wrong type
+  We get the incorrect typing (inner and outer code forced to be both 'a)
+   # .<fun x -> .<x>.>.;;
+*)
+
+let t4 = .<fun x -> .<x>.>.;;
+(*
+val t4 : ('cl, 'a -> ('cl0, 'a) code) code = .<fun x_1 -> .<x_1>.>. 
+*)
+let true = .! ((.! t4) true);;
+
+(* From Problems.txt  Mon Jan 10 18:51:21 GMTST 2005
+  CSP constants in Pervasives (and similar) are type checked only once for
+  a given occurrence.
+   # let f x  = .< ref .~ x>.
+     in (.! (f .<3>.), .! (f .<1.3>.));;
+   This expression has type int but is here used with type float
+*)
+
+let t5 =
+  let f x  = .< ref .~ x>.
+  in (.! (f .<3>.), .! (f .<1.3>.));;
+
+(*
+val t5 : int ref * float ref = ({contents = 3}, {contents = 1.3})
+*)
+
+(* From Problems.txt Tue Jan 18 14:08:52 GMTST 2005
+  type aliases are not handled correctly in code, example:
+    # type a = int;;
+    # let f (x:a) = 1;;
+    # .! .<f 1>.;;
+*)
+type a = int;;
+let 1 =
+  let f (x:a) = 1 in
+  .! .<f 1>.;;
+
+(* From Problems.txt Oct 3, 2006 Printing of records in brackets *)
+
+let t7 = 
+  let open Complex in
+  .<let x = {re=1.0; im=2.0} in
+    let y = {x with re = 2.0} in
+    y>.
+ ;;
+
+(*
+val t7 : ('cl, Complex.t) code = .<
+  let x_39 = {Complex.re = 1.0; Complex.im = 2.0} in
+  let y_40 = {x_39 with Complex.re = 2.0} in y_40>. 
+*)
+
+let {Complex.re=2.0; im=2.0} = .! t7;;
+
+(* First-class polymorphism *)
+
+let tfc1 = {Runcode.cde = .<1>.};;
+(* - : int Runcode.cde = .<1>. *)
+let 1 = Runcode.run {Runcode.cde = .<1>.};;
+
+let tfc2 = .<{Runcode.cde = .<1>.}>.;;
+(*
+- : ('cl, int Runcode.cde) code = .<{Runcode.cde = .<1>.}>. 
+*)
+let tfc3 = .! .<{Runcode.cde = .<1>.}>.;;
+(* - : int Runcode.cde = .<1>.  *)
+let tfc4 = {Runcode.cde= .<{Runcode.cde = .<1>.}>.};;
+(* - : int Runcode.cde Runcode.cde = .<{Runcode.cde = .<1>.}>.  *)
+let tfc5 = Runcode.run {Runcode.cde= .<{Runcode.cde = .<1>.}>.};;
+(* - : int Runcode.cde = .<1>.  *)
+let 1 = Runcode.run (Runcode.run {Runcode.cde= .<{Runcode.cde = .<1>.}>.});;
+(* - : int = 1 *)
+
+(* complex runs *)
+let tr1 = .<fun x -> .~(.! .<.<1>.>.)>.;;
+let 1 = (.! tr1) 42;;
+(*
+val tr1 : ('a, 'b -> int) code = .<fun x_36 -> 1>.
+*)
+
+let tr1' = .<fun x -> .~(.! .<.<fun x -> x>.>.)>.;;
+(*
+val tr1' : ('cl, 'a -> 'b -> 'b) code = .<fun x_2 -> fun x_3_4 -> x_3_4>. 
+*)
+let 2 = (.! tr1') 1 2;;
+
+let tr2 = .<fun x -> .~(let x = .! .<1>. in .<x>.)>.;;
+(*
+val tr2 : ('a, 'b -> int) code = .<fun x_37 -> 1>.
+*)
+let 1 = (.! tr2) 42;;
+
+Printf.printf "\nAll Done\n";;
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/test/t4.ml ocaml-4.00.1/ber-metaocaml-100/test/t4.ml
--- ocaml-4.00.1.orig/ber-metaocaml-100/test/t4.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/test/t4.ml	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,109 @@
+
+(* Author:  Walid Taha and Cristiano Calcagno
+   Date:    Fri Aug 31 03:03:11 EDT 2001 *)
+
+open T4types;;
+
+let unJ(J i) = i
+let unF(F f) = f
+
+let term0 = A(L("x",V"x"),I 7)
+
+let term1 = A(R ("f","n", C(V "n",I 42,A (V "f",D (V "n")))),I 1000000)
+
+exception Yiikes
+;;
+
+let env0 = fun x -> raise Yiikes;;
+
+let ext env x v = fun y -> if x=y then v else env y
+
+let rec eval e env =
+match e with
+  I i -> J i
+| V s -> env s
+| A (e1,e2) -> (unF(eval e1 env)) (eval e2 env)
+| L (x,e) -> F (fun v -> eval e (ext env x v))
+| D e -> J ((unJ (eval e env))-1)
+| C (e1,e2,e3) -> if (unJ(eval e1 env))=0 
+                     then (eval e2 env)
+                     else (eval e3 env)
+| R (f,x,e) -> F (let rec ff xx = eval e (ext (ext env x xx)
+                                              f (F ff))
+                  in ff)
+;;
+
+let J 42 = eval term1 env0;; (* Unstaged *)
+
+let rec eval' e env =
+match e with
+  I i -> .<J i>.
+| V s -> env s
+| A (e1,e2) -> .<(unF .~(eval' e1 env)) (.~(eval' e2 env))>.
+| L (x,e) -> .<F (fun v -> .~(eval' e (ext env x .<v>.)))>.
+| D e -> .<J (unJ .~(eval' e env) - 1)>.
+| C (e1,e2,e3) -> .< if (unJ .~(eval' e1 env)) = 0 
+                              then .~(eval' e2 env)
+                              else .~(eval' e3 env) >.
+| R (f,x,e) ->
+  .<F (let rec ff xx = .~(eval' e (ext (ext env x .<xx>.) f .<F ff>.)) in ff)>.
+;;
+
+let stage1Running = eval' term1 env0;;
+
+(*
+val stage1Running : ('a, dom) code =
+  .<((((* cross-stage persistent value (as id: unF) *))
+     (F
+       (let rec ff_1 =
+         fun xx_2 ->
+          if ((((* cross-stage persistent value (as id: unJ) *)) xx_2) = 0) then
+           (J (42))
+          else
+           ((((* cross-stage persistent value (as id: unF) *)) (F (ff_1)))
+             (J
+               ((((* cross-stage persistent value (as id: unJ) *)) xx_2) - 1))) in
+        ff_1))) (J (1000000)))>.
+
+*)
+let compiling = .! .<fun () -> .~ stage1Running>.;;
+
+let J 42 = compiling ();;
+
+let unJ' = .<fun (J i) -> i>.
+let unF' = .<fun (F f) -> f>.
+
+let rec eval'' e env =
+match e with
+  I i -> .<J i>.
+| V s -> env s
+| A (e1,e2) -> .<.~unF' .~(eval'' e1 env) .~(eval'' e2 env)>.
+| L (x,e) -> .<F (fun v -> .~(eval'' e (ext env x .<v>.)))>.
+| D e -> .<J (.~unJ' .~(eval'' e env) - 1)>.
+| C (e1,e2,e3) -> .<if .~unJ' .~(eval'' e1 env) = 0 
+                              then .~(eval'' e2 env)
+                              else .~(eval'' e3 env)>.
+| R (f,x,e) ->
+  .<F (let rec ff xx = .~(eval'' e (ext (ext env x .<xx>.) f (.<F ff>.))) in ff)>.
+;;
+
+let stage1Running' = eval'' term1 env0;;
+
+(*
+val stage1Running' : ('a, dom) code =
+  .<((fun F (f_2) -> f_2)
+    (F
+      (let rec ff_1 =
+        fun xx_2 ->
+         if (((fun J (i_1) -> i_1) xx_2) = 0) then (J (42))
+         else
+          ((fun F (f_2) -> f_2) (F (ff_1))
+            (J (((fun J (i_1) -> i_1) xx_2) - 1))) in
+       ff_1)) (J (1000000)))>.
+*)
+
+let compiling' = .! .<fun () -> .~ stage1Running'>.;;
+
+let J 42 = (compiling' ());;
+
+Printf.printf "\n4.ml Done\n";;
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/test/t4types.mli ocaml-4.00.1/ber-metaocaml-100/test/t4types.mli
--- ocaml-4.00.1.orig/ber-metaocaml-100/test/t4types.mli	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/test/t4types.mli	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,17 @@
+(* Data type declarations for the staged eval example by 
+   Walid Taha and Cristiano Calcagno
+
+In MetaOCaml N100, all data types used within brackets must be 
+in separate .ml or .mli files
+*)
+
+type exp = I of int
+         | V of string
+         | A of exp * exp
+         | L of string * exp
+         | D of exp
+         | C of exp * exp * exp
+         | R of string * string * exp
+
+type dom = J of int
+         | F of (dom -> dom)
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/test/test20.ml ocaml-4.00.1/ber-metaocaml-100/test/test20.ml
--- ocaml-4.00.1.orig/ber-metaocaml-100/test/test20.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/test/test20.ml	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,20 @@
+open Bool2
+
+type ('a,'b,'c) unary = {
+  unow : 'b -> 'c ;
+  ulater : ('a,'b) code -> ('a, 'c) code
+}
+
+module type SET =
+sig
+  type n
+  val to_string : ('a, n, string) unary
+end
+
+module E2 (N : SET) = struct
+    let to_str p = match p with
+      | Now (x,y) -> Now ((N.to_string.unow x) ^ (N.to_string.unow y))
+      | Later p -> Later (.< let (x, y) = .~p in 
+                .~(N.to_string.ulater .<x>.) ^ 
+                .~(N.to_string.ulater .<y>.) >. )
+end
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/test/test21.ml ocaml-4.00.1/ber-metaocaml-100/test/test21.ml
--- ocaml-4.00.1.orig/ber-metaocaml-100/test/test21.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/test/test21.ml	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,5 @@
+(* this generates an error in BER-meta but not in meta-309-alpha-030 *)
+module Bool = struct module C = struct end end
+
+let h = .<"" ^ "">. 
+
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/test/trivial.ml ocaml-4.00.1/ber-metaocaml-100/test/trivial.ml
--- ocaml-4.00.1.orig/ber-metaocaml-100/test/trivial.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/test/trivial.ml	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,961 @@
+(* Trivial tests of MetaOCaml, which are also regression tests *)
+
+3+2;;
+(* - : int = 5 *)
+let rec fact = function | 0 -> 1 | n -> n * fact (n-1);;
+(* val fact : int -> int = <fun> *)
+let 120 = fact 5;;
+
+.<1>.;;
+(* - : ('cl, int) code = .<1>. *)
+.<"aaa">.;;
+(* - : ('cl, string) code = .<"aaa">. *)
+let 1 = .! .<1>.;;
+(* - : int = 1 *)
+
+
+.<fun x -> .~(let y = x in y)>.;;
+(*
+Characters 22-23:
+  .<fun x -> .~(let y = x in y)>.;;
+                        ^
+Error: Wrong level: variable bound at level 1 and used at level 0
+*)
+print_endline "Error was expected";;
+
+.<fun x -> 1 + .~(.<true>.)>.;;
+(*
+Characters 20-24:
+  .<fun x -> 1 + .~(.<true>.)>.;;
+                      ^^^^
+Error: This expression has type bool but an expression was expected of type
+         int
+*)
+print_endline "Error was expected";;
+
+.<fun x -> .~(.! .<x>.; .<1>.)>.;;
+(*
+Characters 14-22:
+  .<fun x -> .~(.! .<x>.; .<1>.)>.;;
+                ^^^^^^^^
+Error: .! error: 'cl not generalizable in ('cl, 'a) code
+*)
+print_endline "Error was expected";;
+
+(* CSP *)
+
+let x = 1 in .<x>.;;
+(*
+- : ('cl, int) code = .<1>.
+*)
+let x = 1.0 in .<x>.;;
+(*
+- : ('cl, float) code = .<1.>.
+*)
+let x = true in .<x>.;;
+(*
+- : ('cl, bool) code = .<true>.
+*)
+let x = "aaa" in .<x>.;;
+(*
+- : ('cl, string) code = .<"aaa">.
+*)
+let x = 'a' in .<x>.;;
+(*
+- : ('cl, char) code = .<'a'>.
+*)
+let x = ['a'] in .<x>.;;
+(*
+- : ('cl, char list) code = .<(* cross-stage persistent value (as id: x) *)>.
+*)
+
+let l x = .<x>.;;                       (* polymorphic *)
+(* val l : 'a -> ('cl, 'a) code = <fun> *)
+l 1;;
+(*
+- : ('a, int) code = .<(* cross-stage persistent value (as id: x) *)>.
+*)
+let 1 = .! (l 1);;
+l 1.0;;                  (* better printing in N100 *)
+(*
+- : ('a, float) code = .<1.>.
+*)
+let 1.0 = .! (l 1.0);;
+
+.<List.rev>.;;
+(*
+- : ('cl, 'a list -> 'a list) code = .<List.rev>.
+*)
+
+.<Array.get>.;;
+(*
+- : ('cl, 'a array -> int -> 'a) code = .<Array.get>.
+*)
+.<(+)>.;;
+(*
+- : ('cl, int -> int -> int) code = .<(+)>.
+*)
+
+
+let x = true in .<assert x>.;;
+(*
+- : ('cl, unit) code = .<assert (true)>.
+*)
+
+(* Applications and labels *)
+.<succ 1>.;;
+(*
+- : ('cl, int) code = .<succ 1>.
+*)
+
+let 2 = .! .<succ 1>.;;
+
+.<1 + 2>.;;
+(*
+- : ('cl, int) code = .<(1 + 2)>.
+*)
+let 3 = .! .<(1 + 2)>.;;
+
+.<String.length "abc">.;;
+(*
+- : ('cl, int) code = .<String.length "abc">.
+*)
+let 3 = 
+  .! .<String.length "abc">.;;
+
+.<StringLabels.sub ?pos:1 ?len:2 "abc">.;;
+(*
+- : ('cl, string) code = .<(StringLabels.sub "abc" ~pos:1 ~len:2>.
+*)
+let "bc" =
+  .! .<StringLabels.sub ?pos:1 ?len:2 "abc">.;;
+
+.<StringLabels.sub ~len:2 ~pos:1 "abc">.;;
+(*
+- : ('cl, string) code = .<(StringLabels.sub "abc" ~pos:1 ~len:2>.
+*)
+let "bc" =
+  .! .<StringLabels.sub ~len:2 ~pos:1 "abc">.;;
+
+(* Nested brackets and escapes and run *)
+.<.<1>.>.;;
+(*
+- : ('cl, ('cl0, int) code) code = .<.<1>.>.
+*)
+.! .<.<1>.>.;;
+(* - : ('cl, int) code = .<1>. *)
+let 1 = .! (.! .<.<1>.>.);;)
+(* - : int = 1 *)
+.<.!.<1>.>.;;
+(*
+- : ('cl, int) code = .<.!.<1>.>.
+*)
+let 1 = .! .<.!.<1>.>.;;
+.<1 + .~(let x = 2 in .<x>.)>.;;
+(*
+- : ('cl, int) code = .<(1 + 2)>.
+*)
+let x = .< 2 + 4 >. in .< .~ x + .~ x >. ;;
+(*
+- : ('cl, int) code = .<((2 + 4) + (2 + 4))>.
+*)
+let 12 = .! (let x = .< 2 + 4 >. in .< .~ x + .~ x >. );;
+
+.<1 + .~(let x = 2 in .<.<x>.>.)>.;;
+(*
+Characters 24-29:
+  .<1 + .~(let x = 2 in .<.<x>.>.)>.;;
+                          ^^^^^
+Error: This expression has type ('cl, 'a) code
+       but an expression was expected of type int
+*)
+print_endline "Error was expected";;
+.<1 + .! .~(let x = 2 in .<.<x>.>.)>.;;
+(*
+- : ('cl, int) code = .<(1 + .!.<2>.)>.
+*)
+let 3 = .! .<1 + .! .~(let x = 2 in .<.<x>.>.)>.;;
+.! .<1 + .~ (.~(let x = 2 in .<.<x>.>.))>.;;
+(*
+Characters 12-40:
+  .! .<1 + .~ (.~(let x = 2 in .<.<x>.>.))>.;;
+              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Error: Wrong level: escape at level 0
+*)
+print_endline "Error was expected";;
+
+.<.<.~(.<1>.)>.>.;;
+(*
+- : ('cl, ('cl0, int) code) code = .<.<.~(.<1>.)>.>.
+*)
+.!.<.<.~(.<1>.)>.>.;;
+(*
+- : ('cl, int) code = .<1>.
+*)
+.<.<.~.~(.<.<1>.>.)>.>.;;
+(*
+- : ('cl, ('cl0, int) code) code = .<.<.~(.<1>.)>.>.
+*)
+
+(* Lazy *)
+.<lazy 1>.;;
+(*
+- : ('cl, int lazy_t) code = .<lazy 1>.
+*)
+let 1 = Lazy.force (.! .<lazy 1>.);;
+
+(* Tuples *)
+.<(1,"abc")>.;;
+(*
+- : ('cl, int * string) code = .<((1), ("abc"))>.
+*)
+.<(1,"abc",'d')>.;;
+(*
+- : ('cl, int * string * char) code = .<((1), ("abc"), ('d'))>.
+*)
+let "abc" =
+  match .! .<(1,"abc",'d')>. with (_,x,_) -> x;;
+
+(* Arrays *)
+.<[||]>.;;
+(*
+- : ('cl, 'a array) code = .<[||]>.
+*)
+let x = .<1+2>. in .<[|.~x;.~x|]>.;;
+(*
+- : ('cl, int array) code = .<[|(1 + 2); (1 + 2)|]>.
+*)
+
+(* Constructors and enforcing externality *)
+.<raise Not_found>.;;
+(*
+- : ('cl, 'a) code = .<(raise (Not_found)>.
+*)
+.<raise (Scan_failure "")>.;;
+(*
+Characters 8-25:
+  .<raise (Scan_failure "")>.;;
+          ^^^^^^^^^^^^^^^^^
+Error: Unbound constructor Scan_failure
+*)
+print_endline "Error was expected";;
+.<raise (Scanf.Scan_failure "")>.;;
+(*
+- : ('cl, 'a) code = .<(raise (Scanf.Scan_failure (""))>.
+*)
+open Scanf;;
+.<raise (Scan_failure "")>.;;
+(*
+- : ('cl, 'a) code = .<(raise (Scanf.Scan_failure (""))>.
+*)
+.! .<raise (Scan_failure "")>.;;
+(*
+Exception: Scanf.Scan_failure "".
+*)
+print_endline "Exception was expected";;
+
+
+.<true>.;;
+(*
+- : ('cl, bool) code = .<(true)>.
+*)
+.<Some 1>.;;
+(*
+- : ('cl, int option) code = .<(Some (1))>.
+*)
+.<Some [1]>.;;
+(*
+- : ('cl, int list option) code = .<(Some ([1]))>.
+*)
+.! .<Some [1]>.;;
+(*
+- : int list option = Some [1]
+*)
+.<None>.;;
+(*
+- : ('cl, 'a option) code = .<(None)>.
+*)
+.! .<None>.;;
+(*
+- : 'a option = None
+*)
+
+.<Genlex.Int 1>.;;
+(*
+- : ('cl, Genlex.token) code = .<(Genlex.Int (1))>.
+*)
+open Genlex;;
+.<Int 1>.;;
+(*
+- : ('cl, Genlex.token) code = .<(Genlex.Int (1))>.
+*)
+let Int 1 = .! .<Int 1>.;;
+
+module Foo = struct exception E end;;
+.<raise Foo.E>.;;
+(*
+Fatal error: exception Trx.TrxError("Exception Foo.E cannot be used within brackets. Put into a separate file.")
+*)
+print_endline "Error was expected";;
+
+type foo = Bar;;
+.<Bar>.;;
+(*
+Fatal error: exception Trx.TrxError("Constructor Bar cannot be used within brackets. Put into a separate file.")
+*)
+print_endline "Error was expected";;
+
+module Foo = struct type foo = Bar end;;
+.<Foo.Bar>.;;
+(*
+Fatal error: exception Trx.TrxError("Constructor Foo.Bar cannot be used within brackets. Put into a separate file.")
+*)
+print_endline "Error was expected";;
+
+(* Records *)
+
+.<{Complex.re = 1.0; im = 2.0}>.;;
+(*
+- : ('cl, Complex.t) code = .<{Complex.re = 1.0; Complex.im = 2.0}>.
+*)
+Complex.conj (.! .<{Complex.re = 1.0; im = 2.0}>.);;
+(*
+- : Complex.t = {Complex.re = 1.; Complex.im = -2.}
+*)
+let x = {Complex.re = 1.0; im = 2.0} in .<x.re>.;;
+(*
+Characters 42-46:
+  let x = {Complex.re = 1.0; im = 2.0} in .<x.re>.;;
+                                            ^^^^
+Error: Unbound record field label re
+*)
+print_endline "Error was expected";;
+
+let x = {Complex.re = 1.0; im = 2.0} in .<x.Complex.re>.;;
+(*
+- : ('cl, float) code =
+.<((* cross-stage persistent value (as id: x) *)).Complex.re>.
+*)
+let 1.0 = .!(let x = {Complex.re = 1.0; im = 2.0} in .<x.Complex.re>.);;
+let x = ref 1 in .<x.contents>.;;       (* Pervasive record *)
+(*
+- : ('cl, int) code =
+.<((* cross-stage persistent value (as id: x) *)).contents>.
+*)
+let 1 = .!(let x = ref 1 in .<x.contents>.);;
+let x = ref 1 in .<x.contents <- 2>.;;
+(*
+- : ('cl, unit) code =
+.<((* cross-stage persistent value (as id: x) *)).contents <- 2>.
+*)
+let x = ref 1 in (.! .<x.contents <- 2>.); x;;
+(* - : int ref = {contents = 2} *)
+
+open Complex;;
+.<{re = 1.0; im = 2.0}>.;;
+(*
+- : ('cl, Complex.t) code = .<{Complex.re = 1.0; Complex.im = 2.0}>.
+*)
+let 5.0 = norm (.! .<{re = 3.0; im = 4.0}>.);;
+let x = {re = 1.0; im = 2.0} in .<x.re>.;;
+(*
+- : ('cl, float) code =
+.<((* cross-stage persistent value (as id: x) *)).Complex.re>.
+*)
+let 1.0 = .!(let x = {re = 1.0; im = 2.0} in .<x.re>.);;
+
+type foo = {fool : int};;
+.<{fool = 1}>.;;
+(*
+Fatal error: exception Trx.TrxError("Label fool cannot be used within brackets. Put into a separate file.")
+*)
+print_endline "Error was expected";;
+
+(* Conditional *)
+
+.<if true then 1 else 2>.;;
+(* - : ('cl, int) code = .<if (true) then 1 else 2>. *)
+.<if Some 1 = None then print_string "weird">.;;
+(*
+- : ('cl, unit) code =
+.<if ((Some (1)) = (None)) then (print_string "weird">.
+*)
+let () = .! .<if Some 1 = None then print_string "weird">.;;
+
+(* Polymorphic variants *)
+.<`Foo>.;;
+(*
+- : ('cl, [> `Foo ]) code = .<`Foo>.
+*)
+.<`Bar 1>.;;
+(*
+- : ('cl, [> `Bar of int ]) code = .<`Bar 1>.
+*)
+let 1 = match .! .<`Bar 1>. with `Bar x -> x ;;
+
+(* Some support for modules *)
+let f = fun x -> .<x # foo>.;;
+(*
+val f : < foo : 'a; .. > -> ('cl, 'a) code = <fun>
+*)
+let x = object method foo = 1 end;;
+(*
+val x : < foo : int > = <obj>
+*)
+f x;;
+(*
+- : ('a, int) code =
+.<(((* cross-stage persistent value (as id: x) *))#foo)>.
+*)
+let 1 = .! (f x);;
+
+(* Local open *)
+let 5.0 = .! .<Complex.(norm {re=3.0; im = 4.0})>.;;
+
+let 5.0 = .! .<let open Complex in norm {re=4.0; im = 3.0}>.;;
+
+(* For-loop *)
+
+.<for i=1 to 5 do Printf.printf "ok %d %d\n" i (i+1) done>.;;
+(*
+- : ('cl, unit) code =
+.<for i_10 = 1 to 5 do Printf.printf "ok %d %d\n" i_10 (i_10 + 1) done>.
+*)
+.! .<for i=1 to 5 do Printf.printf "ok %d %d\n" i (i+1) done>.;;
+(*
+ok 1 2
+ok 2 3
+ok 3 4
+ok 4 5
+ok 5 6
+*)
+
+.<for i=5 downto 1 do Printf.printf "ok %d %d\n" i (i+1) done>.;;
+(*
+- : ('cl, unit) code =
+.<for i_8 = 5 downto 1 do Printf.printf "ok %d %d\n" i_8 (i_8 + 1) done>.
+*)
+.! .<for i=5 downto 1 do Printf.printf "ok %d %d\n" i (i+1) done>.;;
+(*
+ok 5 6
+ok 4 5
+ok 3 4
+ok 2 3
+ok 1 2
+*)
+
+.<for i=1 to 2 do for j=1 to 3 do Printf.printf "ok %d %d\n" i j done done>.;;
+(*
+- : ('cl, unit) code =
+.<for i_14 = 1 to 2 do
+   for j_15 = 1 to 3 do (Printf.printf "ok %d %d\n" i_14 j_15 done done>.
+*)
+.! .<for i=1 to 2 do 
+     for j=1 to 3 do Printf.printf "ok %d %d\n" i j done done>.;;
+(*
+ok 1 1
+ok 1 2
+ok 1 3
+ok 2 1
+ok 2 2
+ok 2 3
+*)
+
+let c = .<for i=1 to 2 do .~(let x = .<i>. in 
+             .<for i=1 to 3 do Printf.printf "ok %d %d\n" i .~x done>.) done>.;;
+(*
+val c : ('cl, unit) code =
+  .<for i_20 = 1 to 2 do
+     for i_21 = 1 to 3 do (Printf.printf "ok %d %d\n" i_21 i_20 done done>.
+*)
+.! c;;
+(*
+ok 1 1
+ok 2 1
+ok 3 1
+ok 1 2
+ok 2 2
+ok 3 2
+*)
+
+(* Scope extrusion test *)
+
+let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<0>.; .<()>.) done>.; 
+                     .<for i=1 to 5 do ignore (.~(!r)) done>.;;
+(*
+- : ('cl, unit) code = .<for i_2 = 1 to 5 do (ignore 0 done>.
+*)
+
+let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i>.; .<()>.) done>.; 
+                     .<for i=1 to 5 do ignore (.~(!r)) done>.;;
+(*
+Exception:
+Failure
+ "Scope extrusion at Characters 49-50:\n  let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i>.; .<()>.) done>.; .<for i=1 to 5 do ignore (.~(!r)) done>.;;\n                                                   ^\n for the identifier i_3 bound at Characters 27-28:\n  let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i>.; .<()>.) done>.; .<for i=1 to 5 do ignore (.~(!r)) done>.;;\n                             ^\n".
+*)
+print_endline "Error was expected";;
+
+(* Simple functions *)
+.<fun x -> x>.;;
+(*
+- : ('cl, 'a -> 'a) code = .<fun x_3 -> x_3>.
+*)
+let 42 = (.! .<fun x -> x>.) 42;;
+
+.<fun x y -> x + y>.;;
+(*
+- : ('cl, int -> int -> int) code = .<fun x_5 -> fun y_6 -> (x_5 + y_6)>.
+*)
+let 5 = (.! .<fun x y -> x + y>.) 2 3;;
+
+.<fun x -> fun x -> x + x >.;;
+(*
+- : ('cl, 'a -> int -> int) code = .<fun x_9 -> fun x_10 -> (x_10 + x_10)>.
+*)
+
+(* Testing hygiene  *)
+let eta f = .<fun x -> .~(f .<x>.)>.;;
+(*
+val eta : (('cl, 'a) code -> ('cl, 'b) code) -> ('cl, 'a -> 'b) code = <fun>
+*)
+eta (fun x -> .<1 + .~x>.);;
+(*
+- : ('cl, int -> int) code = .<fun x_11 -> (1 + x_11)>.
+*)
+eta (fun y -> .<fun x -> x + .~y>.);;
+(*
+- : ('cl, int -> int -> int) code = .<fun x_12 -> fun x_13 -> (x_13 + x_12)>.
+*)
+let 5 = (.! (eta (fun y -> .<fun x -> x + .~y>.))) 2 3;;
+
+(* new identifiers must be generated at run-time *)
+let rec fhyg = function
+  | 0 -> .<1>.
+  | n -> .<(fun x -> .~(fhyg (n-1)) + x) n>.;;
+(*
+val fhyg : int -> ('cl, int) code = <fun>
+*)
+fhyg 3;;
+(*
+- : ('a, int) code = .<
+((fun x_5 -> (((fun x_6 -> (((fun x_7 -> (1 + x_7)) 1) + x_6)) 2) + x_5)) 3)>.
+*)
+let 7 = .! (fhyg 3);;
+
+(* pattern-matching, general functions *)
+
+.<fun () -> 1>.;;
+(* - : ('cl, unit -> int) code = .<fun () -> 1>. *)
+.! .<fun () -> 1>.;;
+(* - : unit -> int = <fun> *)
+let 1 = (.! .<fun () -> 1>.) ();;
+
+.<function true -> 1 | false -> 0>.;;
+(*
+- : ('cl, bool -> int) code = .<function | true -> 1 | false -> 0>. 
+*)
+let 1 = (.! .<function true -> 1 | false -> 0>.) true;;
+
+.<fun (true,[]) -> 1>.;;
+(*
+- : ('cl, bool * 'a list -> int) code = .<fun (true, []) -> 1>. 
+*)
+(.! .<fun (true,[]) -> 1>.) (true,[1]);;
+(*
+Exception: Match_failure ("//toplevel//", 1, 6).
+*)
+print_endline "Error was expected";;
+let 1 = (.! .<fun (true,[]) -> 1>.) (true,[]);;
+
+.<fun [|true;false;false|] -> 1>.;;
+(*
+- : ('cl, bool array -> int) code = .<fun [|true; false; false|] -> 1>. 
+*)
+let 1 = (.! .<fun [|true;false;false|] -> 1>.) [|true;false;false|];;
+
+.<function `F 1 -> true | _ -> false>.;;
+(*
+- : ('cl, [> `F of int ] -> bool) code = .<
+function | (`F 1) -> true | _ -> false>. 
+*)
+let true = (.! .<function `F 1 -> true | _ -> false>.) (`F 1);;
+.<function `F 1 | `G 2 -> true | _ -> false>.;;
+(*
+- : ('cl, [> `F of int | `G of int ] -> bool) code = .<
+function | ((`F 1) | (`G 2)) -> true | _ -> false>. 
+*)
+
+.<function (1,"str") -> 1 | (2,_) -> 2>.;;
+(*
+- : ('cl, int * string -> int) code = .<
+function | (1, "str") -> 1 | (2, _) -> 2>. 
+*)
+let 1 = (.! .<function (1,"str") -> 1 | (2,_) -> 2>.) (1,"str");;
+let 2 = (.! .<function (1,"str") -> 1 | (2,_) -> 2>.) (2,"str");;
+let 1 = (.! .<fun [1;2] -> 1>.) [1;2];;
+
+let 2 = (.! .<function None -> 1 | Some [1] -> 2>.) (Some [1]);;
+
+let 2 = (.! .<function (Some (Some true)) -> 1 | _ -> 2>.) (Some None);;
+let 1 = (.! .<function (Some (Some true)) -> 1 | _ -> 2>.) (Some (Some true));;
+let 2 = (.! .<function (Some (Some true)) -> 1 | _ -> 2>.) (Some (Some false));;
+let 2 = (.! .<function (Some (Some true)) -> 1 | _ -> 2>.) None;;
+
+open Complex;;
+.<function {re=1.0} -> 1 | {im=2.0; re = 2.0} -> 2 | {im=_} -> 3>.;;
+(*
+- : ('cl, Complex.t -> int) code = .<
+function
+| {Complex.re = 1.0} -> 1
+| {Complex.re = 2.0; Complex.im = 2.0} -> 2
+| {Complex.im = _} -> 3>. 
+*)
+
+let 1 = (.! .<function {re=1.0} -> 1 | {im=2.0; re = 2.0} -> 2 | {im=_} -> 3>.)
+        {re=1.0; im=2.0};;
+let 2 = (.! .<function {re=1.0} -> 1 | {im=2.0; re = 2.0} -> 2 | {im=_} -> 3>.)
+        {re=2.0; im=2.0};;
+(* - : int = 2 *)
+let 3 = (.! .<function {re=1.0} -> 1 | {im=2.0; re = 2.0} -> 2 | {im=_} -> 3>.)
+        {re=2.0; im=3.0};;
+
+(* General functions *)
+
+.<fun (x,y) -> x + y>.;;
+(*
+- : ('cl, int * int -> int) code = .<fun (x_2, y_3) -> (x_2 + y_3)>. 
+*)
+let 5 = (.! .<fun (x,y) -> x + y>.) (2,3);;
+.<function (Some x) as y -> x | _ ->  2>.;;
+(*
+- : ('cl, int option -> int) code = .<
+function | (Some (x_6) as y_7) -> x_6 | _ -> 2>.
+*)
+let 1 = (.! .<function (Some x) as y -> x | _ ->  2>.) (Some 1);;
+let 2 = (.! .<function (Some x) as y -> x | _ ->  2>.) None;;
+.<function [x;y;z] -> x - y + z | [x;y] -> x - y>.;;
+(*
+- : ('cl, int list -> int) code = .<
+function
+| (x_12 :: y_13 :: z_14 :: []) -> ((x_12 - y_13) + z_14)
+| (x_15 :: y_16 :: []) -> (x_15 - y_16)>. 
+*)
+let 2 = (.! .<function [x;y;z] -> x - y + z | [x;y] -> x - y>.) [1;2;3];;
+
+ (* OR patterns *)
+.<function ([x;y] | [x;y;_]) -> x - y>.;;
+(*
+- : ('cl, int list -> int) code = .<
+fun ((x_1 :: y_2 :: []) | (x_1 :: y_2 :: _ :: [])) -> (x_1 - y_2)>. 
+*)
+let -1 = (.! .<function ([x;y] | [x;y;_]) -> x - y>.) [1;2];;
+let -1 = (.! .<function ([x;y] | [x;y;_]) -> x - y>.) [1;2;3];;
+(.! .<function ([x;y] | [x;y;_]) -> x - y>.) [1;2;3;4];;
+(* Exception: Match_failure ("//toplevel//", 1, 6). *)
+print_endline "Error was expected";;
+
+.<function ([x;y] | [x;y;_]| [y;x;_;_]) -> x - y>.;;
+(*
+- : ('cl, int list -> int) code = .<
+fun (((x_9 :: y_10 :: []) | (x_9 :: y_10 :: _ :: []))
+     | (y_10 :: x_9 :: _ :: _ :: [])) ->
+ (x_9 - y_10)>.
+*)
+let -1 = (.! .<function ([x;y] | [x;y;_]| [y;x;_;_]) -> x - y>.) [1;2];;
+let -1 = (.! .<function ([x;y] | [x;y;_]| [y;x;_;_]) -> x - y>.) [1;2;3];;
+let  1 = (.! .<function ([x;y] | [x;y;_]| [y;x;_;_]) -> x - y>.) [1;2;3;4];;
+
+.<function (`F x | `G x) -> x | `E x -> x>.;;
+(*
+- : ('cl, [< `E of 'a | `F of 'a | `G of 'a ] -> 'a) code = .<
+function | ((`F x_17) | (`G x_17)) -> x_17 | (`E x_18) -> x_18>. 
+*)
+let 2 = (.! .<function (`F x | `G x) -> x | `E x -> x>.) (`F 2);;
+open Complex;;
+.<function {re=x} -> x | {im=x; re=y} -> x -. y>.;;
+(*
+Characters 25-37:
+  .<function {re=x} -> x | {im=x; re=y} -> x -. y>.;;
+                           ^^^^^^^^^^^^
+Warning 11: this match case is unused.
+- : ('cl, Complex.t -> float) code = .<
+function
+| {Complex.re = x_21} -> x_21
+| {Complex.re = y_22; Complex.im = x_23} -> (x_23 -. y_22)>. 
+*)
+.<function {re=x; im=2.0} -> x | {im=x; re=y} -> x -. y>.;;
+(*
+- : ('cl, Complex.t -> float) code = .<
+function
+| {Complex.re = x_24; Complex.im = 2.0} -> x_24
+| {Complex.re = y_25; Complex.im = x_26} -> (x_26 -. y_25)>. 
+*)
+let 0. = (.! .<function {re=x; im=2.0} -> x | {im=x; re=y} -> x -. y>.) 
+         {re=1.0; im=1.0};;
+(* - : float = 0. *)
+.<function (Some x) as y when x  > 0 -> y | _ -> None>.;;
+(*
+- : ('cl, int option -> int option) code = .<
+function | (Some (x_30) as y_31) when (x_30 > 0) -> y_31 | _ -> None>. 
+*)
+let Some 1 = (.! .<function (Some x) as y when x  > 0 -> y | _ -> None>.)
+             (Some 1);;
+let None = (.! .<function (Some x) as y when x  > 0 -> y | _ -> None>.)
+           (Some 0);;
+
+(* pattern-matching *)
+.<match 1 with 1 -> true>.;;
+(*
+- : ('cl, bool) code = .<(match 1 with 1 -> true)>. 
+*)
+let true = .! .<match 1 with 1 -> true>.;;
+
+.<match (1,2) with (1,x) -> true | x -> false>.;;
+(*
+- : ('cl, bool) code = .<
+(match ((1), (2)) with | (1, x_3) -> true | x_4 -> false)>. 
+*)
+.<match [1;2] with [x] -> x | [x;y] -> x + y>.;;
+(*
+- : ('cl, int) code = .<
+(match [1; 2] with | (x_5 :: []) -> x_5 | (x_6 :: y_7 :: []) -> (x_6 + y_7))>.
+*)
+let 3 = 
+  .! .<match [1;2] with [x] -> x | [x;y] -> x + y>.;;
+
+(* OR patterns *)
+.<match [1;2] with [x] -> x | [x;y] | [x;y;_] -> x + y>.;;
+(*
+- : ('cl, int) code = .<
+(match [1; 2] with
+ | (x_11 :: []) -> x_11
+ | ((x_12 :: y_13 :: []) | (x_12 :: y_13 :: _ :: [])) -> (x_12 + y_13))>.
+*)
+let 3 = .! .<match [1;2] with [x] -> x | [x;y] | [x;y;_] -> x + y>.;;
+
+.<match [1;2;3;4] with [x] -> x | [x;y] | [x;y;_] | [y;x;_;_] -> x - y>.;;
+(*
+- : ('cl, int) code = .<
+(match [1; 2; 3; 4] with
+ | (x_17 :: []) -> x_17
+ | (((x_18 :: y_19 :: []) | (x_18 :: y_19 :: _ :: []))
+    | (y_19 :: x_18 :: _ :: _ :: [])) ->
+    (x_18 - y_19))>.
+*)
+let 1 =
+  .! .<match [1;2;3;4] with [x] -> x | [x;y] | [x;y;_] | [y;x;_;_] -> x - y>.;;
+
+.<fun x -> match x with (`F x | `G x) -> x | `E x -> x>.;;
+(*
+- : ('cl, [< `E of 'a | `F of 'a | `G of 'a ] -> 'a) code = .<
+fun x_23 ->
+ (match x_23 with | ((`F x_24) | (`G x_24)) -> x_24 | (`E x_25) -> x_25)>.
+*)
+
+let 1 = (.! .<fun x -> match x with (`F x | `G x) -> x | `E x -> x>.) (`G 1);;
+
+open Complex;;
+.<fun x -> match x with {re=x; im=2.0} -> x | {im=x; re=y} -> x -. y>.;;
+(*
+- : ('cl, Complex.t -> float) code = .<
+fun x_29 ->
+ (match x_29 with
+  | {Complex.re = x_30; Complex.im = 2.0} -> x_30
+  | {Complex.re = y_31; Complex.im = x_32} -> (x_32 -. y_31))>.
+*)
+
+let 1.0 =
+  (.! .<fun x -> match x with {re=x; im=2.0} -> x | {im=x; re=y} -> x -. y>.)
+    {im=2.0; re=1.0};;
+
+
+(* try *)
+.<fun x -> try Some (List.assoc x [(1,true); (2,false)]) with Not_found -> None>.;;
+(*
+- : ('cl, int -> bool option) code = .<
+fun x_1 ->
+ (try Some(List.assoc x_1 [((1), (true)); ((2), (false))])) with
+  Not_found -> None)>.
+*)
+let Some true =
+  (.! .<fun x -> try Some (List.assoc x [(1,true); (2,false)]) with Not_found -> None>.) 1;;
+let Some false =
+(.! .<fun x -> try Some (List.assoc x [(1,true); (2,false)]) with Not_found -> None>.) 2;;
+let None =
+(.! .<fun x -> try Some (List.assoc x [(1,true); (2,false)]) with Not_found -> None>.) 3;;
+
+.<fun x -> let open Scanf in try sscanf x "%d" (fun x -> string_of_int x) with Scan_failure x -> "fail " ^ x>.;;
+(*
+- : ('cl, string -> string) code = .<
+fun x_5 ->
+ let open Scanf in
+ (try (Scanf.sscanf x_5 "%d" (fun x_7 -> (string_of_int x_7))) with
+  Scanf.Scan_failure (x_6) -> ("fail " ^ x_6))>.
+*)
+
+let "1" = 
+  (.! .<fun x -> let open Scanf in try sscanf x "%d" (fun x -> string_of_int x) with Scan_failure x -> "fail " ^ x>.) "1";;
+let "fail scanf: bad input at char number 0: ``character 'x' is not a decimal digit''" =
+(.! .<fun x -> let open Scanf in try sscanf x "%d" (fun x -> string_of_int x) with Scan_failure x -> "fail " ^ x>.) "xxx";;
+
+(* Simple let *)
+
+.<let x = 1 in x>.;;
+(*
+- : ('cl, int) code = .<let x_1 = 1 in x_1>. 
+*)
+let 1 = 
+  .! .<let x = 1 in x>.;;
+.<let x = 1 in let x = x + 1 in x>.;;
+(*
+- : ('cl, int) code = .<let x_7 = 1 in let x_8 = (x_7 + 1) in x_8>. 
+*)
+let 2 = 
+  .! .<let x = 1 in let x = x + 1 in x>.;;
+.<let rec f = fun n -> if n = 0 then 1 else n * f (n-1) in f 5>.;;
+(*
+- : ('cl, int) code = .<
+let rec f_11 =
+ fun n_12 -> if (n_12 = 0) then 1 else (n_12 * (f_11 (n_12 - 1))) in
+(f_11 5)>. 
+*)
+let 120 =
+  .! .<let rec f = fun n -> if n = 0 then 1 else n * f (n-1) in f 5>.;;
+
+(* Recursive vs. non-recursive bindings *)
+.<let f = fun x -> x in 
+  let rec f = fun n -> if n = 0 then 1 else n * f (n-1) in f 5>.;;
+(*
+Characters 6-7:
+  .<let f = fun x -> x in let rec f = fun n -> if n = 0 then 1 else n * f (n-1) in f 5>.;;
+        ^
+Warning 26: unused variable f.
+- : ('cl, int) code = .<
+let f_19 = fun x_22 -> x_22 in
+let rec f_20 =
+ fun n_21 -> if (n_21 = 0) then 1 else (n_21 * (f_20 (n_21 - 1))) in
+(f_20 5)>. 
+*)
+
+let 120 = .! .<let f = fun x -> x in 
+               let rec f = fun n -> if n = 0 then 1 else n * f (n-1) in f 5>.;;
+
+.<let f = fun x -> x in 
+  let f = fun n -> if n = 0 then 1 else n * f (n-1) in f 5>.;;
+(*
+- : ('cl, int) code = .<
+let f_31 = fun x_34 -> x_34 in
+let f_32 = fun n_33 -> if (n_33 = 0) then 1 else (n_33 * (f_31 (n_33 - 1))) in
+(f_32 5)>. 
+*)
+let 20 = .! .<let f = fun x -> x in 
+              let f = fun n -> if n = 0 then 1 else n * f (n-1) in f 5>.;;
+
+
+(* General let *)
+.<let x = 1 and y = 2 in x + y>.;;
+(*
+- : ('cl, int) code = .<let x_1 = 1 and y_2 = 2 in (x_1 + y_2)>. 
+*)
+let 3 = .! .<let x = 1 and y = 2 in x + y>.;;
+
+.<let x = 1 in let x = x+1 and y = x+1 in x + y>.;;
+(*
+- : ('cl, int) code = .<
+let x_3 = 1 in let x_4 = (x_3 + 1) and y_5 = (x_3 + 1) in (x_4 + y_5)>. 
+*)
+let 4 = .! .<let x = 1 in let x = x+1 and y = x+1 in x + y>.;;
+(*
+.<fun x -> let (Some x) = x in x + 1>.;;
+Characters 15-23:
+  .<fun x -> let (Some x) = x in x + 1>.;;
+                 ^^^^^^^^
+Warning 8: this pattern-matching is not exhaustive.
+Here is an example of a value that is not matched:
+None
+- : ('cl, int option -> int) code = .<
+fun x_11 -> let Some (x_12) = x_11 in (x_12 + 1)>. 
+*)
+let 3 = (.! .<fun x -> let (Some x) = x in x + 1>.) (Some 2);;
+(.! .<fun x -> let (Some x) = x in x + 1>.) None;;
+(*
+Characters 19-27:
+  (.! .<fun x -> let (Some x) = x in x + 1>.) None;;
+                     ^^^^^^^^
+Warning 8: this pattern-matching is not exhaustive.
+Here is an example of a value that is not matched:
+None
+Exception: Match_failure ("//toplevel//", 1, 19).
+*)
+print_endline "Error was expected";;
+
+.<fun x -> let rec even = function 0 -> true | x -> odd (x-1) and 
+                   odd  = function 0 -> false | x -> even (x-1) in even x>.;;
+(*
+- : ('cl, int -> bool) code = .<
+fun x_17 ->
+ let rec even_18 = function | 0 -> true | x_21 -> (odd_19 (x_21 - 1))
+ and odd_19 = function | 0 -> false | x_20 -> (even_18 (x_20 - 1)) in
+ (even_18 x_17)>.
+*)
+let true = (.! .<fun x -> let rec even = function 0 -> true | x -> odd (x-1) and odd = function 0 -> false | x -> even (x-1) in even x>.) 42;;
+let false = (.! .<fun x -> let rec even = function 0 -> true | x -> odd (x-1) and odd = function 0 -> false | x -> even (x-1) in even x>.) 43;;
+
+
+(* testing scope extrusion *)
+let r = ref .<0>. in let _ = .<fun x -> .~(r := .<1>.; .<0>.)>. in !r ;;
+(* - : ('cl, int) code = .<1>.  *)
+let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in !r ;;
+(* shown code is a bit funny -- but instructive! *)
+(*
+- : ('cl, int) code = .<x_10 <- x_10>.
+
+Failure("Scope extrusion at Characters 50-51:\n  let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in !r ;;\n                                                    ^\n for the identifier x_10 bound at Characters 35-36:\n  let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in !r ;;\n                                     ^\n")
+*)
+print_endline "Error was expected";;
+
+let c = let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in (!r) in .! c;;
+(*
+Exception:
+Failure
+ "Scope extrusion at Characters 58-59:\n  let c = let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in (!r) in .! c;;\n                                                            ^\n for the identifier x_11 bound at Characters 43-44:\n  let c = let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in (!r) in .! c;;\n                                             ^\n".
+*)
+print_endline "Error was expected";;
+
+let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in !r ;;
+(*
+- : ('cl, '_a -> '_a) code = .<x_13 <- fun y_14 -> x_13>.
+
+Failure("Scope extrusion at Characters 57-67:\n  let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in !r ;;\n                                                           ^^^^^^^^^^\n for the identifier x_13 bound at Characters 42-43:\n  let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in !r ;;\n                                            ^\n")
+*)
+print_endline "Error was expected";;
+
+(* Error message is reported on splice *)
+let r = ref .<fun y->y>. in 
+let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in .<fun x -> .~(!r) 1>. ;;
+(*
+Failure
+ "Scope extrusion at Characters 58-68:\n  let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in .<fun x -> .~(!r) 1>. ;;\n                               ^^^^^^^^^^\n for the identifier x_34 bound at Characters 43-44:\n  let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in .<fun x -> .~(!r) 1>. ;;\n                ^\n".
+*)
+print_endline "Error was expected";;
+
+(* The test is approximate: it is sound but overflagging *)
+let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> y>.; .<0>.)>. in !r ;;
+(*
+- : ('cl, '_a -> '_a) code = .<x_16 <- fun y_17 -> y_17>.
+
+Failure("Scope extrusion at Characters 57-67:\n  let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> y>.; .<0>.)>. in !r ;;\n                                                           ^^^^^^^^^^\n for the identifier x_16 bound at Characters 42-43:\n  let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> y>.; .<0>.)>. in !r ;;\n                                            ^\n")
+*)
+print_endline "Error was expected";;
+
+(* The following are OK though *)
+let r = ref .<fun y->y>. in .<fun x -> .~(r := .<fun y -> y>.; !r)>.;;
+(*
+- : ('cl, '_a -> '_b -> '_b) code = .<fun x_22 -> fun y_23 -> y_23>. 
+*)
+let r = ref .<fun y->y>. in .<fun x -> .~(r := .<fun y -> x>.; !r)>.;;
+(*
+- : ('cl, '_a -> '_a -> '_a) code = .<fun x_25 -> fun y_26 -> x_25>. 
+*)
+
+print_endline "\nAll done\n";;
diff -N -u -r ocaml-4.00.1.orig/ber-metaocaml-100/trivial.ref ocaml-4.00.1/ber-metaocaml-100/trivial.ref
--- ocaml-4.00.1.orig/ber-metaocaml-100/trivial.ref	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/ber-metaocaml-100/trivial.ref	2013-02-25 17:55:31.000000000 +0100
@@ -0,0 +1,346 @@
+BER MetaOCaml toplevel, version N 100
+        OCaml version 4.00.1
+
+#     - : int = 5
+#   val fact : int -> int = <fun>
+#   #   - : ('cl, int) code = .<1>. 
+#   - : ('cl, string) code = .<"aaa">. 
+#   #       Characters 42-43:
+  .<fun x -> .~(let y = x in y)>.;;
+                        ^
+Error: Wrong level: variable bound at level 1 and used at level 0
+# * * * * *   Error was expected
+- : unit = ()
+#   Characters 21-25:
+  .<fun x -> 1 + .~(.<true>.)>.;;
+                      ^^^^
+Error: This expression has type bool but an expression was expected of type
+         int
+# * * * * * *   Error was expected
+- : unit = ()
+#   Characters 15-23:
+  .<fun x -> .~(.! .<x>.; .<1>.)>.;;
+                ^^^^^^^^
+Error: .! error: 'cl not generalizable in ('cl, 'a) code
+
+# * * * * *   Error was expected
+- : unit = ()
+#       - : ('cl, int) code = .<1>. 
+# * *   - : ('cl, float) code = .<1.>. 
+# * *   - : ('cl, bool) code = .<true>. 
+# * *   - : ('cl, string) code = .<"aaa">. 
+# * *   - : ('cl, char) code = .<'a'>. 
+# * *   - : ('cl, char list) code = .<(* cross-stage persistent value (id: x) *)>. 
+# * *     val l : 'a -> ('cl, 'a) code = <fun>
+#   - : ('a, int) code = .<(* cross-stage persistent value (id: x) *)>. 
+# * *   # - : ('a, float) code = .<1.>. 
+# * *   #   - : ('cl, 'a list -> 'a list) code = .<List.rev>. 
+# * *     - : ('cl, 'a array -> int -> 'a) code = .<Array.get>. 
+# * *   - : ('cl, int -> int -> int) code = .<(+)>. 
+# * *       - : ('cl, unit) code = .<assert true>. 
+# * *       - : ('cl, int) code = .<(succ 1)>. 
+# * *     #   - : ('cl, int) code = .<(1 + 2)>. 
+# * *   #   - : ('cl, int) code = .<(String.length "abc")>. 
+# * *     #   - : ('cl, string) code = .<(StringLabels.sub "abc" ~pos:1 ~len:2)>. 
+# * *     #   - : ('cl, string) code = .<(StringLabels.sub "abc" ~pos:1 ~len:2)>. 
+# * *     #     - : ('cl, ('cl0, int) code) code = .<.<1>.>. 
+# * *   - : ('cl, int) code = .<1>. 
+#   #   - : ('cl, int) code = .<.!.<1>.>. 
+# * *   # - : ('cl, int) code = .<(1 + 2)>. 
+# * *   - : ('cl, int) code = .<((2 + 4) + (2 + 4))>. 
+# * *   #   Characters 25-30:
+  .<1 + .~(let x = 2 in .<.<x>.>.)>.;;
+                          ^^^^^
+Error: This expression has type ('cl, 'a) code
+       but an expression was expected of type int
+# * * * * * *   Error was expected
+- : unit = ()
+# - : ('cl, int) code = .<(1 + .!.<2>.)>. 
+# * *   # Characters 12-40:
+  .! .<1 + .~ (.~(let x = 2 in .<.<x>.>.))>.;;
+              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Error: Wrong level: escape at level 0
+# * * * * *   Error was expected
+- : unit = ()
+#   - : ('cl, ('cl0, int) code) code = .<.<.~(.<1>.)>.>. 
+# * *   - : ('cl, int) code = .<1>. 
+# * *   - : ('cl, ('cl0, int) code) code = .<.<.~(.<1>.)>.>. 
+# * *       - : ('cl, int lazy_t) code = .<lazy 1>. 
+# * *   #     - : ('cl, int * string) code = .<((1), ("abc"))>. 
+# * *   - : ('cl, int * string * char) code = .<((1), ("abc"), ('d'))>. 
+# * *     #     - : ('cl, 'a array) code = .<[||]>. 
+# * *   - : ('cl, int array) code = .<[|(1 + 2); (1 + 2)|]>. 
+# * *       - : ('cl, 'a) code = .<(raise Not_found)>. 
+# * *   Characters 58-75:
+  .<raise (Scan_failure "")>.;;
+          ^^^^^^^^^^^^^^^^^
+Error: Unbound constructor Scan_failure
+# * * * * *   Error was expected
+- : unit = ()
+# - : ('cl, 'a) code = .<(raise Scanf.Scan_failure("")))>. 
+# * *   # - : ('cl, 'a) code = .<(raise Scanf.Scan_failure("")))>. 
+# * *   Exception: Scanf.Scan_failure "".
+# * *   Exception was expected
+- : unit = ()
+#     - : ('cl, bool) code = .<true>. 
+# * *   - : ('cl, int option) code = .<Some(1))>. 
+# * *   - : ('cl, int list option) code = .<Some([1]))>. 
+# * *   - : int list option = Some [1]
+# * *   - : ('cl, 'a option) code = .<None>. 
+# * *   - : 'a option = None
+# * *     - : ('cl, Genlex.token) code = .<Genlex.Int(1))>. 
+# * *   # - : ('cl, Genlex.token) code = .<Genlex.Int(1))>. 
+# * *   #   module Foo : sig exception E end
+# Characters 8-13:
+  .<raise Foo.E>.;;
+          ^^^^^
+Error: Exception Foo.E cannot be used within brackets. Put into a separate file.
+# * *   Error was expected
+- : unit = ()
+#   type foo = Bar
+# Characters 2-5:
+  .<Bar>.;;
+    ^^^
+Error: Constructor Bar cannot be used within brackets. Put into a separate file.
+# * *   Error was expected
+- : unit = ()
+#   module Foo : sig type foo = Bar end
+# Characters 2-9:
+  .<Foo.Bar>.;;
+    ^^^^^^^
+Error: Constructor Foo.Bar cannot be used within brackets. Put into a separate file.
+# * *   Error was expected
+- : unit = ()
+#       - : ('cl, Complex.t) code = .<{Complex.re = 1.0; Complex.im = 2.0}>. 
+# * *   - : Complex.t = {Complex.re = 1.; Complex.im = -2.}
+# * *   Characters 100-104:
+  let x = {Complex.re = 1.0; im = 2.0} in .<x.re>.;;
+                                            ^^^^
+Error: Unbound record field label re
+# * * * * *   Error was expected
+- : unit = ()
+#   - : ('cl, float) code = .<
+((* cross-stage persistent value (id: x) *)).Complex.re>. 
+# * * *   # - : ('cl, int) code = .<
+((* cross-stage persistent value (id: x) *)).contents>. 
+# * * *   # - : ('cl, unit) code = .<
+((* cross-stage persistent value (id: x) *)).contents <- 2>. 
+# * * *   - : int ref = {contents = 2}
+#     # - : ('cl, Complex.t) code = .<{Complex.re = 1.0; Complex.im = 2.0}>. 
+# * *   # - : ('cl, float) code = .<
+((* cross-stage persistent value (id: x) *)).Complex.re>. 
+# * * *   #   type foo = { fool : int; }
+# Characters 3-7:
+  .<{fool = 1}>.;;
+     ^^^^
+Error: Label fool cannot be used within brackets. Put into a separate file.
+# * *   Error was expected
+- : unit = ()
+#       - : ('cl, int) code = .<if true then 1 else 2>. 
+#   - : ('cl, unit) code = .<if (Some(1)) = None) then (print_string "weird")>. 
+# * * *   #     - : ('cl, [> `Foo ]) code = .<`Foo>. 
+# * *   - : ('cl, [> `Bar of int ]) code = .<`Bar 1>. 
+# * *   #     val f : < foo : 'a; .. > -> ('cl, 'a) code = <fun>
+# * *   val x : < foo : int > = <obj>
+# * *   - : ('a, int) code = .<(((* cross-stage persistent value (id: x) *))#foo)>. 
+# * * *   #     #   #       - : ('cl, unit) code = .<
+for i_1 = 1 to 5 do (Printf.printf "ok %d %d\n" i_1 (i_1 + 1)) done>. 
+# * * *   ok 1 2
+ok 2 3
+ok 3 4
+ok 4 5
+ok 5 6
+- : unit = ()
+# * * * * * *     - : ('cl, unit) code = .<
+for i_3 = 5 downto 1 do (Printf.printf "ok %d %d\n" i_3 (i_3 + 1)) done>. 
+# * * *   ok 5 6
+ok 4 5
+ok 3 4
+ok 2 3
+ok 1 2
+- : unit = ()
+# * * * * * *     - : ('cl, unit) code = .<
+for i_5 = 1 to 2 do
+ for j_6 = 1 to 3 do (Printf.printf "ok %d %d\n" i_5 j_6) done
+done>. 
+# * * * *     ok 1 1
+ok 1 2
+ok 1 3
+ok 2 1
+ok 2 2
+ok 2 3
+- : unit = ()
+# * * * * * * *       val c : ('cl, unit) code = .<
+  for i_9 = 1 to 2 do
+   for i_10 = 1 to 3 do (Printf.printf "ok %d %d\n" i_10 i_9) done
+  done>. 
+# * * * *   ok 1 1
+ok 2 1
+ok 3 1
+ok 1 2
+ok 2 2
+ok 3 2
+- : unit = ()
+# * * * * * * *           - : ('cl, unit) code = .<for i_12 = 1 to 5 do (ignore 0) done>. 
+# * *       Exception:
+Failure
+ "Scope extrusion at Characters 118-119:\n  let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i>.; .<()>.) done>.; \n                                                   ^\n for the identifier i_13 bound at Characters 96-97:\n  let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i>.; .<()>.) done>.; \n                             ^\n".
+# * * * *   Error was expected
+- : unit = ()
+#     - : ('cl, 'a -> 'a) code = .<fun x_15 -> x_15>. 
+# * *   #   - : ('cl, int -> int -> int) code = .<fun x_17 -> fun y_18 -> (x_17 + y_18)>. 
+# * *   #   - : ('cl, 'a -> int -> int) code = .<fun x_21 -> fun x_22 -> (x_22 + x_22)>. 
+# * *       val eta : (('cl, 'a) code -> ('cl, 'b) code) -> ('cl, 'a -> 'b) code = <fun>
+# * *   - : ('cl, int -> int) code = .<fun x_23 -> (1 + x_23)>. 
+# * *   - : ('cl, int -> int -> int) code = .<fun x_24 -> fun x_25 -> (x_25 + x_24)>. 
+# * *   #         val fhyg : int -> ('cl, int) code = <fun>
+# * *   - : ('a, int) code = .<
+((fun x_28 ->
+   (((fun x_29 -> (((fun x_30 -> (1 + x_30)) 1) + x_29)) 2) + x_28)) 3)>.
+
+# * * *   #       - : ('cl, unit -> int) code = .<fun () -> 1>. 
+#   - : unit -> int = <fun>
+#   #   - : ('cl, bool -> int) code = .<function | true -> 1 | false -> 0>. 
+# * *   #   - : ('cl, bool * 'a list -> int) code = .<fun (true, []) -> 1>. 
+# * *   Exception: Match_failure ("//toplevel//", 416, 6).
+# * *   Error was expected
+- : unit = ()
+# #   - : ('cl, bool array -> int) code = .<fun [|true; false; false|] -> 1>. 
+# * *   #   - : ('cl, [> `F of int ] -> bool) code = .<
+function | (`F 1) -> true | _ -> false>. 
+# * * *   # - : ('cl, [> `F of int | `G of int ] -> bool) code = .<
+function | ((`F 1) | (`G 2)) -> true | _ -> false>. 
+# * * *     - : ('cl, int * string -> int) code = .<
+function | (1, "str") -> 1 | (2, _) -> 2>. 
+# * * *   # # #   #   # # # #   # - : ('cl, Complex.t -> int) code = .<
+function
+| {Complex.re = 1.0} -> 1
+| {Complex.re = 2.0; Complex.im = 2.0} -> 2
+| {Complex.im = _} -> 3>. 
+# * * * * * *       #   #     #       - : ('cl, int * int -> int) code = .<fun (x_34, y_35) -> (x_34 + y_35)>. 
+# * *   # - : ('cl, int option -> int) code = .<
+function | (Some (x_38) as y_39) -> x_38 | _ -> 2>. 
+# * * *   # # - : ('cl, int list -> int) code = .<
+function
+| [x_44 ; y_45 ; z_46] -> ((x_44 - y_45) + z_46)
+| [x_47 ; y_48] -> (x_47 - y_48)>. 
+# * * * * *   #     - : ('cl, int list -> int) code = .<
+fun ([x_54 ; y_55] | [x_54 ; y_55 ; _]) -> (x_54 - y_55)>. 
+# * * *   # # Exception: Match_failure ("//toplevel//", 474, -106).
+#   Error was expected
+- : unit = ()
+#   - : ('cl, int list -> int) code = .<
+fun (([x_62 ; y_63] | [x_62 ; y_63 ; _]) | [y_63 ; x_62 ; _ ; _]) ->
+ (x_62 - y_63)>.
+
+# * * * * *   # # #   - : ('cl, [< `E of 'a | `F of 'a | `G of 'a ] -> 'a) code = .<
+function | ((`F x_70) | (`G x_70)) -> x_70 | (`E x_71) -> x_71>. 
+# * * *   # # - : ('cl, Complex.t -> float) code = .<
+function
+| {Complex.re = x_74} -> x_74
+| {Complex.re = y_75; Complex.im = x_76} -> (x_76 -. y_75)>. 
+# * * * * * * * * *   - : ('cl, Complex.t -> float) code = .<
+function
+| {Complex.re = x_77; Complex.im = 2.0} -> x_77
+| {Complex.re = y_78; Complex.im = x_79} -> (x_79 -. y_78)>. 
+# * * * * *     #   - : ('cl, int option -> int option) code = .<
+function | (Some (x_83) as y_84) when (x_83 > 0) -> y_84 | _ -> None>. 
+# * * *     #   #     - : ('cl, bool) code = .<(match 1 with 1 -> true)>. 
+# * *   #   - : ('cl, bool) code = .<
+(match ((1), (2)) with | (1, x_89) -> true | x_90 -> false)>. 
+# * * *   - : ('cl, int) code = .<
+(match [1; 2] with | [x_91] -> x_91 | [x_92 ; y_93] -> (x_92 + y_93))>. 
+# * * *     #     - : ('cl, int) code = .<
+(match [1; 2] with
+ | [x_97] -> x_97
+ | ([x_98 ; y_99] | [x_98 ; y_99 ; _]) -> (x_98 + y_99))>.
+
+# * * * * *   #   - : ('cl, int) code = .<
+(match [1; 2; 3; 4] with
+ | [x_103] -> x_103
+ | (([x_104 ; y_105] | [x_104 ; y_105 ; _]) | [y_105 ; x_104 ; _ ; _]) ->
+    (x_104 - y_105))>.
+
+# * * * * * * *     #   - : ('cl, [< `E of 'a | `F of 'a | `G of 'a ] -> 'a) code = .<
+fun x_109 ->
+ (match x_109 with | ((`F x_110) | (`G x_110)) -> x_110 | (`E x_111) -> x_111)>.
+
+# * * * *     #   # - : ('cl, Complex.t -> float) code = .<
+fun x_115 ->
+ (match x_115 with
+  | {Complex.re = x_116; Complex.im = 2.0} -> x_116
+  | {Complex.re = y_117; Complex.im = x_118} -> (x_118 -. y_117))>.
+
+# * * * * * *         #       - : ('cl, int -> bool option) code = .<
+fun x_123 ->
+ (try Some(List.assoc x_123 [((1), (true)); ((2), (false))])) with
+  Not_found -> None)>.
+
+# * * * * *     #   #   #   - : ('cl, string -> string) code = .<
+fun x_127 ->
+ let open Scanf in
+ (try (Scanf.sscanf x_127 "%d" (fun x_129 -> (string_of_int x_129))) with
+  Scanf.Scan_failure (x_128) -> ("fail " ^ x_128))>.
+
+# * * * * * *       #   #       - : ('cl, int) code = .<let x_136 = 1 in x_136>. 
+# * *     # - : ('cl, int) code = .<let x_138 = 1 in let x_139 = (x_138 + 1) in x_139>. 
+# * *     # - : ('cl, int) code = .<
+let rec f_142 =
+ fun n_143 -> if (n_143 = 0) then 1 else (n_143 * (f_142 (n_143 - 1))) in
+(f_142 5)>. 
+# * * * * *     #       - : ('cl, int) code = .<
+let f_146 = fun x_149 -> x_149 in
+let rec f_147 =
+ fun n_148 -> if (n_148 = 0) then 1 else (n_148 * (f_147 (n_148 - 1))) in
+(f_147 5)>. 
+# * * * * * * * * * *       #     - : ('cl, int) code = .<
+let f_154 = fun x_157 -> x_157 in
+let f_155 =
+ fun n_156 -> if (n_156 = 0) then 1 else (n_156 * (f_154 (n_156 - 1))) in
+(f_155 5)>. 
+# * * * * *     #       - : ('cl, int) code = .<let x_162 = 1 and y_163 = 2 in (x_162 + y_163)>. 
+# * *   #   - : ('cl, int) code = .<
+let x_166 = 1 in
+let x_167 = (x_166 + 1) and y_168 = (x_166 + 1) in (x_167 + y_168)>. 
+# * * *   # * * * * * * * * * *   # Exception: Match_failure ("//toplevel//", 650, -314).
+# * * * * * * * *   Error was expected
+- : unit = ()
+#     - : ('cl, int -> bool) code = .<
+fun x_176 ->
+ let rec even_177 = function | 0 -> true | x_180 -> (odd_178 (x_180 - 1))
+ and odd_178 = function | 0 -> false | x_179 -> (even_177 (x_179 - 1)) in
+ (even_177 x_176)>.
+
+# * * * * * *   # #       - : ('cl, int) code = .<1>. 
+#   - : ('cl, int) code = .<x_192 <- x_192>.
+
+Failure("Scope extrusion at Characters 85-86:\n  let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in !r ;;\n                                                    ^\n for the identifier x_192 bound at Characters 70-71:\n  let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in !r ;;\n                                     ^\n")
+#   * * * *   Error was expected
+- : unit = ()
+#   Exception:
+Failure
+ "Scope extrusion at Characters 59-60:\n  let c = let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in (!r) in .! c;;\n                                                            ^\n for the identifier x_193 bound at Characters 44-45:\n  let c = let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in (!r) in .! c;;\n                                             ^\n".
+# * * * *   Error was expected
+- : unit = ()
+#   - : ('cl, '_a -> '_a) code = .<x_195 <- fun y_196 -> x_195>.
+
+Failure("Scope extrusion at Characters 58-68:\n  let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in !r ;;\n                                                           ^^^^^^^^^^\n for the identifier x_195 bound at Characters 43-44:\n  let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in !r ;;\n                                            ^\n")
+# * * * *   Error was expected
+- : unit = ()
+#       Exception:
+Failure
+ "Scope extrusion at Characters 101-111:\n  let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in .<fun x -> .~(!r) 1>. ;;\n                               ^^^^^^^^^^\n for the identifier x_198 bound at Characters 86-87:\n  let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in .<fun x -> .~(!r) 1>. ;;\n                ^\n".
+# * * *   Error was expected
+- : unit = ()
+#     - : ('cl, '_a -> '_a) code = .<x_202 <- fun y_203 -> y_203>.
+
+Failure("Scope extrusion at Characters 118-128:\n  let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> y>.; .<0>.)>. in !r ;;\n                                                           ^^^^^^^^^^\n for the identifier x_202 bound at Characters 103-104:\n  let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> y>.; .<0>.)>. in !r ;;\n                                            ^\n")
+# * * * *   Error was expected
+- : unit = ()
+#     - : ('cl, '_a -> '_b -> '_b) code = .<fun x_205 -> fun y_206 -> y_206>. 
+# * *   - : ('cl, '_a -> '_a -> '_a) code = .<fun x_208 -> fun y_209 -> x_208>. 
+# * *     
+All done
+
+- : unit = ()
+# 
diff -N -u -r ocaml-4.00.1.orig/bytecomp/lambda.ml ocaml-4.00.1/bytecomp/lambda.ml
--- ocaml-4.00.1.orig/bytecomp/lambda.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/bytecomp/lambda.ml	2013-02-20 17:25:22.000000000 +0100
@@ -116,6 +116,7 @@
   | Const_block of int * structured_constant list
   | Const_float_array of string list
   | Const_immstring of string
+  | Const_csp_value of Obj.t                   (* NNN: immediate CSP *)
 
 type function_kind = Curried | Tupled
 
diff -N -u -r ocaml-4.00.1.orig/bytecomp/lambda.mli ocaml-4.00.1/bytecomp/lambda.mli
--- ocaml-4.00.1.orig/bytecomp/lambda.mli	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/bytecomp/lambda.mli	2013-02-20 17:25:22.000000000 +0100
@@ -116,6 +116,7 @@
   | Const_block of int * structured_constant list
   | Const_float_array of string list
   | Const_immstring of string
+  | Const_csp_value of Obj.t                   (* NNN: immediate CSP *)
 
 type function_kind = Curried | Tupled
 
diff -N -u -r ocaml-4.00.1.orig/bytecomp/printlambda.ml ocaml-4.00.1/bytecomp/printlambda.ml
--- ocaml-4.00.1.orig/bytecomp/printlambda.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/bytecomp/printlambda.ml	2013-02-20 17:25:22.000000000 +0100
@@ -41,6 +41,8 @@
       let floats ppf fl =
         List.iter (fun f -> fprintf ppf "@ %s" f) fl in
       fprintf ppf "@[<1>[|@[%s%a@]|]@]" f1 floats fl
+  | Const_csp_value _ ->                        (* NNN *)
+      fprintf ppf "(CSP_value)"(* NNN; or use print_obj from tools/dumpobj.ml *)
 
 let boxed_integer_name = function
   | Pnativeint -> "nativeint"
diff -N -u -r ocaml-4.00.1.orig/bytecomp/symtable.ml ocaml-4.00.1/bytecomp/symtable.ml
--- ocaml-4.00.1.orig/bytecomp/symtable.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/bytecomp/symtable.ml	2013-02-20 17:25:22.000000000 +0100
@@ -217,6 +217,7 @@
       block
   | Const_float_array fields ->
       Obj.repr(Array.of_list(List.map (fun f -> float_of_string f) fields))
+  | Const_csp_value v -> v                                  (* NNN *)
 
 (* Build the initial table of globals *)
 
diff -N -u -r ocaml-4.00.1.orig/bytecomp/translcore.ml ocaml-4.00.1/bytecomp/translcore.ml
--- ocaml-4.00.1.orig/bytecomp/translcore.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/bytecomp/translcore.ml	2013-02-20 17:25:22.000000000 +0100
@@ -836,6 +836,13 @@
           cl_loc = e.exp_loc;
           cl_type = Cty_signature cty;
           cl_env = e.exp_env }
+  | Texp_cspval (v,_) ->  Lconst(Const_csp_value v)         (* NNN *)
+  | Texp_run _ | Texp_escape _  | Texp_bracket _ ->         (* NNN begin *)
+      Printtyped.implementation Format.err_formatter
+        {str_type = []; str_final_env = e.exp_env;
+         str_items = [{str_env = e.exp_env; str_loc = Location.none; 
+                       str_desc =Tstr_eval e}]};
+      fatal_error "Translcore.trans_exp with meta stuff"    (* NNN end *)
 
 and transl_list expr_list =
   List.map transl_exp expr_list
diff -N -u -r ocaml-4.00.1.orig/ocamldoc/Makefile ocaml-4.00.1/ocamldoc/Makefile
--- ocaml-4.00.1.orig/ocamldoc/Makefile	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/ocamldoc/Makefile	2013-02-20 17:25:22.000000000 +0100
@@ -139,6 +139,7 @@
 LIBCMIFILES= $(LIBCMOFILES:.cmo=.cmi)
 
 # Les cmo et cmx de la distrib OCAML
+# NNN added trx.cmo printtyped.cmo
 OCAMLCMOFILES=$(OCAMLSRCDIR)/parsing/printast.cmo \
 	$(OCAMLSRCDIR)/typing/ident.cmo \
 	$(OCAMLSRCDIR)/utils/tbl.cmo \
@@ -166,6 +167,7 @@
 	$(OCAMLSRCDIR)/typing/primitive.cmo \
 	$(OCAMLSRCDIR)/typing/oprint.cmo \
 	$(OCAMLSRCDIR)/typing/printtyp.cmo \
+	$(OCAMLSRCDIR)/typing/printtyped.cmo \
 	$(OCAMLSRCDIR)/typing/includecore.cmo \
 	$(OCAMLSRCDIR)/typing/typetexp.cmo \
 	$(OCAMLSRCDIR)/typing/typedtree.cmo \
@@ -173,6 +175,7 @@
 	$(OCAMLSRCDIR)/typing/stypes.cmo \
 	$(OCAMLSRCDIR)/typing/cmt_format.cmo \
 	$(OCAMLSRCDIR)/typing/typecore.cmo \
+	$(OCAMLSRCDIR)/typing/trx.cmo \
 	$(OCAMLSRCDIR)/typing/includeclass.cmo \
 	$(OCAMLSRCDIR)/typing/typedecl.cmo \
 	$(OCAMLSRCDIR)/typing/typeclass.cmo \
diff -N -u -r ocaml-4.00.1.orig/parsing/lexer.mll ocaml-4.00.1/parsing/lexer.mll
--- ocaml-4.00.1.orig/parsing/lexer.mll	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/parsing/lexer.mll	2013-02-20 17:25:22.000000000 +0100
@@ -235,6 +235,8 @@
   ['A'-'Z' 'a'-'z' '_' '\192'-'\214' '\216'-'\246' '\248'-'\255' '\'' '0'-'9']
 let symbolchar =
   ['!' '$' '%' '&' '*' '+' '-' '.' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~']
+let symbolcharnodot =                                                  (* NNN *)
+ ['!' '$' '%' '&' '*' '+' '-' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~'] (* NNN *)
 let decimal_literal =
   ['0'-'9'] ['0'-'9' '_']*
 let hex_literal =
@@ -257,6 +259,10 @@
       }
   | blank +
       { token lexbuf }
+  | ".<" { DOTLESS }     (* NNN *)
+  | ">." { GREATERDOT }  (* NNN *)
+  | ".~" { DOTTILDE }    (* NNN *)
+  | ".!" { DOTBANG }     (* NNN *)
   | "_"
       { UNDERSCORE }
   | "~"
@@ -412,8 +418,10 @@
             { PREFIXOP(Lexing.lexeme lexbuf) }
   | ['~' '?'] symbolchar +
             { PREFIXOP(Lexing.lexeme lexbuf) }
-  | ['=' '<' '>' '|' '&' '$'] symbolchar *
+  | ['=' '<' '|' '&' '$'] symbolchar *	         (* NNN: ">." is not INFIXOP0 *)
             { INFIXOP0(Lexing.lexeme lexbuf) }
+  | ['>'] symbolcharnodot symbolchar *           (* NNN exclude ">." case *)
+            { INFIXOP0(Lexing.lexeme lexbuf) }   (* NNN *)
   | ['@' '^'] symbolchar *
             { INFIXOP1(Lexing.lexeme lexbuf) }
   | ['+' '-'] symbolchar *
@@ -422,6 +430,8 @@
             { INFIXOP4(Lexing.lexeme lexbuf) }
   | ['*' '/' '%'] symbolchar *
             { INFIXOP3(Lexing.lexeme lexbuf) }
+  | "let" symbolchar*                            (* NNN *)
+            { LETOP(Lexing.lexeme lexbuf) }      (* NNN *)
   | eof { EOF }
   | _
       { raise (Error(Illegal_character (Lexing.lexeme_char lexbuf 0),
diff -N -u -r ocaml-4.00.1.orig/parsing/parser.mly ocaml-4.00.1/parsing/parser.mly
--- ocaml-4.00.1.orig/parsing/parser.mly	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/parsing/parser.mly	2013-02-20 17:25:22.000000000 +0100
@@ -291,10 +291,26 @@
   in
   (exp, ghtyp(Ptyp_poly(newtypes,varify_constructors newtypes core_type)))
 
+    (* NNN: the whole definition *)
+let let_operator op bindings cont =
+  let pat, expr =
+    match List.rev bindings with
+    | []  -> assert false
+    | [x] -> x
+    | l   ->
+        let pats, exprs = List.split l in
+        ghpat (Ppat_tuple pats), ghexp (Pexp_tuple exprs)
+    in
+      mkexp(Pexp_apply(op, [("", expr); 
+                            ("", ghexp(Pexp_function("", None, [pat, cont])))]))
 %}
 
 /* Tokens */
 
+%token DOTLESS     /* NNN */
+%token GREATERDOT  /* NNN */
+%token DOTTILDE    /* NNN */
+%token DOTBANG     /* NNN */
 %token AMPERAMPER
 %token AMPERSAND
 %token AND
@@ -358,6 +374,7 @@
 %token LESS
 %token LESSMINUS
 %token LET
+%token <string> LETOP /* NNN */
 %token <string> LIDENT
 %token LPAREN
 %token MATCH
@@ -435,6 +452,7 @@
 %nonassoc below_SEMI
 %nonassoc SEMI                          /* below EQUAL ({lbl=...; lbl=...}) */
 %nonassoc LET                           /* above SEMI ( ...; let ... in ...) */
+%nonassoc LETOP           /* NNN */
 %nonassoc below_WITH
 %nonassoc FUNCTION WITH                 /* below BAR  (match ... with ...) */
 %nonassoc AND             /* above WITH (module rec A: SIG with ... and ...) */
@@ -459,6 +477,7 @@
 %nonassoc prec_unary_minus prec_unary_plus /* unary - */
 %nonassoc prec_constant_constructor     /* cf. simple_expr (C versus C x) */
 %nonassoc prec_constr_appl              /* above AS BAR COLONCOLON COMMA */
+%left	  prec_escape    /* NNN */
 %nonassoc below_SHARP
 %nonassoc SHARP                         /* simple_expr/toplevel_directive */
 %nonassoc below_DOT
@@ -961,6 +980,8 @@
       { mkexp(Pexp_apply($1, List.rev $2)) }
   | LET rec_flag let_bindings IN seq_expr
       { mkexp(Pexp_let($2, List.rev $3, $5)) }
+  | let_operator let_bindings IN seq_expr     /* NNN */
+      { let_operator $1 $2 $4 }               /* NNN */
   | LET MODULE UIDENT module_binding IN seq_expr
       { mkexp(Pexp_letmodule(mkrhs $3 3, $4, $6)) }
   | LET OPEN mod_longident IN seq_expr
@@ -1069,6 +1090,12 @@
       { reloc_exp $2 }
   | LPAREN seq_expr error
       { unclosed "(" 1 ")" 3 }
+  | DOTLESS expr GREATERDOT                 /* NNN */
+      { mkexp(Pexp_bracket $2) }            /* NNN */
+  | DOTTILDE simple_expr %prec prec_escape  /* NNN */
+      { mkexp(Pexp_escape $2) }             /* NNN */
+  | DOTBANG expr %prec prec_escape          /* NNN */
+      { mkexp(Pexp_run $2) }                /* NNN */
   | BEGIN seq_expr END
       { reloc_exp $2 }
   | BEGIN END
@@ -1676,6 +1703,7 @@
   | INFIXOP2                                    { $1 }
   | INFIXOP3                                    { $1 }
   | INFIXOP4                                    { $1 }
+  | LETOP                                       { $1 } /* NNN */
   | BANG                                        { "!" }
   | PLUS                                        { "+" }
   | PLUSDOT                                     { "+." }
@@ -1691,6 +1719,15 @@
   | AMPERAMPER                                  { "&&" }
   | COLONEQUAL                                  { ":=" }
 ;
+    /* NNN: the whole definition */
+let_operator:
+    LETOP                                   { mkexp (Pexp_ident(
+                                                     mkloc (Lident $1)
+                                                           (symbol_rloc ()))) }
+  | mod_longident DOT LETOP                 { mkexp (Pexp_ident(
+                                                     mkloc (Ldot($1,$3))
+                                                           (symbol_rloc ()))) }
+;
 constr_ident:
     UIDENT                                      { $1 }
 /*  | LBRACKET RBRACKET                           { "[]" } */
diff -N -u -r ocaml-4.00.1.orig/parsing/parsetree.mli ocaml-4.00.1/parsing/parsetree.mli
--- ocaml-4.00.1.orig/parsing/parsetree.mli	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/parsing/parsetree.mli	2013-02-20 17:25:22.000000000 +0100
@@ -120,6 +120,10 @@
   | Pexp_newtype of string * expression
   | Pexp_pack of module_expr
   | Pexp_open of Longident.t loc * expression
+  | Pexp_bracket of expression (* NNN *)
+  | Pexp_escape of expression  (* NNN *)
+  | Pexp_run of expression     (* NNN *)
+  | Pexp_cspval of Obj.t * Longident.t loc (* NNN *)
 
 (* Value descriptions *)
 
diff -N -u -r ocaml-4.00.1.orig/parsing/printast.ml ocaml-4.00.1/parsing/printast.ml
--- ocaml-4.00.1.orig/parsing/printast.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/parsing/printast.ml	2013-02-20 17:25:22.000000000 +0100
@@ -329,6 +329,18 @@
   | Pexp_open (m, e) ->
       line i ppf "Pexp_open \"%a\"\n" fmt_longident m;
       expression i ppf e
+(* NNN through the end of the case *)
+  | Pexp_bracket (e) ->
+      line i ppf "Pexp_bracket\n";
+      expression i ppf e;
+  | Pexp_escape (e) ->
+      line i ppf "Pexp_escape\n";
+      expression i ppf e;
+  | Pexp_run (e) ->
+      line i ppf "Pexp_run\n";
+      expression i ppf e;
+  | Pexp_cspval (v,li) ->
+      line i ppf "Pexp_cspval <compiled_code> (as id: %a)" fmt_longident li
 
 and value_description i ppf x =
   line i ppf "value_description\n";
diff -N -u -r ocaml-4.00.1.orig/tools/addlabels.ml ocaml-4.00.1/tools/addlabels.ml
--- ocaml-4.00.1.orig/tools/addlabels.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/tools/addlabels.ml	2013-02-20 17:25:22.000000000 +0100
@@ -294,6 +294,9 @@
   | Pexp_ident _ | Pexp_constant _ | Pexp_construct _ | Pexp_variant _
   | Pexp_new _ | Pexp_assertfalse | Pexp_object _ | Pexp_pack _ ->
       ()
+ (* NNN through the rest of the pattern-match *)
+  | Pexp_bracket e | Pexp_escape e | Pexp_run e -> add_labels_rec e
+  | Pexp_cspval _ -> ()
 
 let rec add_labels_class ~text ~classes ~values ~methods cl =
   match cl.pcl_desc with
diff -N -u -r ocaml-4.00.1.orig/tools/depend.ml ocaml-4.00.1/tools/depend.ml
--- ocaml-4.00.1.orig/tools/depend.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/tools/depend.ml	2013-02-20 17:25:22.000000000 +0100
@@ -180,6 +180,10 @@
   | Pexp_newtype (_, e) -> add_expr bv e
   | Pexp_pack m -> add_module bv m
   | Pexp_open (m, e) -> addmodule bv m; add_expr bv e
+(* NNN through the rest of the pattern-match *)
+  | Pexp_bracket e -> add_expr bv e
+  | Pexp_escape e  -> add_expr bv e
+  | Pexp_cspval _ | Pexp_run _ -> ()
 
 and add_pat_expr_list bv pel =
   List.iter (fun (p, e) -> let bv = add_pattern bv p in add_expr bv e) pel
diff -N -u -r ocaml-4.00.1.orig/tools/dumpobj.ml ocaml-4.00.1/tools/dumpobj.ml
--- ocaml-4.00.1.orig/tools/dumpobj.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/tools/dumpobj.ml	2013-02-20 17:25:22.000000000 +0100
@@ -108,6 +108,8 @@
       printf "[|";
       List.iter (fun f -> print_float f; printf "; ") a;
       printf "|]"
+  | Const_csp_value obj ->                    (* NNN *)
+      printf "CSP_value"  (* print_obj obj *)    (* NNN *)
 
 (* Print an obj *)
 
diff -N -u -r ocaml-4.00.1.orig/tools/ocamlprof.ml ocaml-4.00.1/tools/ocamlprof.ml
--- ocaml-4.00.1.orig/tools/ocamlprof.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/tools/ocamlprof.ml	2013-02-20 17:25:22.000000000 +0100
@@ -288,6 +288,9 @@
   | Pexp_newtype (_, sexp) -> rewrite_exp iflag sexp
   | Pexp_open (_, e) -> rewrite_exp iflag e
   | Pexp_pack (smod) -> rewrite_mod iflag smod
+(* NNN through the rest of the pattern-match *)
+  | Pexp_bracket e | Pexp_escape e | Pexp_run e -> rewrite_exp iflag e
+  | Pexp_cspval _ -> ()
 
 and rewrite_ifbody iflag ghost sifbody =
   if !instr_if && not ghost then
diff -N -u -r ocaml-4.00.1.orig/tools/typedtreeIter.ml ocaml-4.00.1/tools/typedtreeIter.ml
--- ocaml-4.00.1.orig/tools/typedtreeIter.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/tools/typedtreeIter.ml	2013-02-20 17:25:22.000000000 +0100
@@ -325,6 +325,10 @@
             iter_class_structure cl
         | Texp_pack (mexpr) ->
             iter_module_expr mexpr
+        | Texp_bracket e -> iter_expression e               (* NNN *)
+        | Texp_escape e  -> iter_expression e               (* NNN *)
+        | Texp_run e     -> iter_expression e               (* NNN *)
+        | Texp_cspval (v,li) -> ()                          (* NNN *)
       end;
       Iter.leave_expression exp;
 
diff -N -u -r ocaml-4.00.1.orig/tools/untypeast.ml ocaml-4.00.1/tools/untypeast.ml
--- ocaml-4.00.1.orig/tools/untypeast.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/tools/untypeast.ml	2013-02-20 17:25:22.000000000 +0100
@@ -287,6 +287,10 @@
         Pexp_object (untype_class_structure cl)
     | Texp_pack (mexpr) ->
         Pexp_pack (untype_module_expr mexpr)
+    | Texp_bracket e -> Pexp_bracket (untype_expression e) (* NNN *)
+    | Texp_escape e  -> Pexp_escape (untype_expression e)  (* NNN *)
+    | Texp_run e     -> Pexp_run (untype_expression e)     (* NNN *)
+    | Texp_cspval (v,li) -> Pexp_cspval (v,li)             (* NNN *)
   in
   List.fold_right untype_extra exp.exp_extra
     { pexp_loc = exp.exp_loc;
diff -N -u -r ocaml-4.00.1.orig/typing/cmt_format.ml ocaml-4.00.1/typing/cmt_format.ml
--- ocaml-4.00.1.orig/typing/cmt_format.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/typing/cmt_format.ml	2013-02-20 17:25:22.000000000 +0100
@@ -505,6 +505,13 @@
             Texp_object (map_class_structure cl, string_list)
           | Texp_pack (mexpr) ->
             Texp_pack (map_module_expr mexpr)
+          | Texp_bracket exp ->         (* NNN through the rest of the clause *)
+              Texp_bracket (map_expression exp)
+          | Texp_escape exp ->
+              Texp_escape (map_expression exp)
+          | Texp_run exp ->
+              Texp_run (map_expression exp)
+          | Texp_cspval (_, _) -> exp.exp_desc (* NNN end *)
       in
       let exp_extra = List.map map_exp_extra exp.exp_extra in
       Map.leave_expression {
diff -N -u -r ocaml-4.00.1.orig/typing/env.ml ocaml-4.00.1/typing/env.ml
--- ocaml-4.00.1.orig/typing/env.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/typing/env.ml	2013-02-20 17:25:22.000000000 +0100
@@ -94,6 +94,19 @@
 
 end
 
+(* NNN added a new component of the environment: stage.
+   It maps a term variable to a list of type_expr -- actually, the list
+   of type variables, that is, env classifiers.
+   The length of the list is the stage level of a variable.
+   We only care about stage level for term variables.
+   Every key in the 'stage' map (the Ident) must occur in
+   the 'values' map.
+*)
+(* NNN
+  The list of active classifiers. The length of the list
+  is the stage level of a variable.
+*)
+type stage = type_expr list	(* NNN *)
 
 type summary =
     Env_empty
@@ -105,6 +118,7 @@
   | Env_class of summary * Ident.t * class_declaration
   | Env_cltype of summary * Ident.t * class_type_declaration
   | Env_open of summary * Path.t
+  | Env_stage of summary * Ident.t * stage (* NNN *)
 
 module EnvTbl =
   struct
@@ -154,6 +168,7 @@
   classes: (Path.t * class_declaration) EnvTbl.t;
   cltypes: (Path.t * class_type_declaration) EnvTbl.t;
   summary: summary;
+  stage: (Path.t * stage) EnvTbl.t;		(* NNN *)
   local_constraints: bool;
   gadt_instances: (int * TypeSet.t ref) list;
   in_signature: bool;
@@ -166,6 +181,9 @@
     Structure_comps of structure_components
   | Functor_comps of functor_components
 
+(* NNN there are no stage levels here: modules must occur at the 0 level.
+   No modules in brackets.
+*)
 and structure_components = {
   mutable comp_values: (string, (value_description * int)) Tbl.t;
   mutable comp_annotations: (string, (Annot.ident * int)) Tbl.t;
@@ -200,6 +218,7 @@
   modules = EnvTbl.empty; modtypes = EnvTbl.empty;
   components = EnvTbl.empty; classes = EnvTbl.empty;
   cltypes = EnvTbl.empty;
+  stage = EnvTbl.empty;                 (* NNN *)
   summary = Env_empty; local_constraints = false; gadt_instances = [];
   in_signature = false;
  }
@@ -271,6 +290,7 @@
       (fun (name, crc) -> Consistbl.check crc_units name crc filename)
       crcs
   with Consistbl.Inconsistency(name, source, auth) ->
+    Printf.eprintf "failed check_consistency %s %s %s\n" name source auth; (* NNNN *)
     raise(Error(Inconsistent_import(name, auth, source)))
 
 (* Reading persistent structures from .cmi files *)
@@ -400,6 +420,14 @@
   find (fun env -> env.classes) (fun sc -> sc.comp_classes)
 and find_cltype =
   find (fun env -> env.cltypes) (fun sc -> sc.comp_cltypes)
+(* NNN there is no comp_stage since all modules are at stage 0 *)
+let find_stage path env =			(* NNN entire function *)
+  match path with
+  | Pident id -> 
+      let (p, data) = EnvTbl.find_same id env.stage
+      in data
+  | _         -> raise Not_found
+
 
 (* Find the manifest type associated to a type when appropriate:
    - the type should be public or should have a private row,
@@ -573,6 +601,9 @@
   lookup (fun env -> env.classes) (fun sc -> sc.comp_classes)
 and lookup_cltype =
   lookup (fun env -> env.cltypes) (fun sc -> sc.comp_cltypes)
+(* NNN there is no comp_stage since all modules are at stage 0 *)
+let lookup_stage =			(* NNN *)
+  lookup_simple (fun env -> env.stage) (fun sc -> raise Not_found) (* NNN *)
 
 let mark_value_used name vd =
   try Hashtbl.find value_declarations (name, vd.val_loc) ()
@@ -1027,6 +1058,11 @@
     cltypes = EnvTbl.add id (path, desc) env.cltypes;
     summary = Env_cltype(env.summary, id, desc) }
 
+and store_stage id path st env =	       (* NNN whole clause *)
+  { env with
+    stage = EnvTbl.add id (path, st) env.stage;
+    summary = Env_stage(env.summary, id, st) } (* NNN end *)
+
 (* Compute the components of a functor application in a path. *)
 
 let components_of_functor_appl f p1 p2 =
@@ -1074,6 +1110,9 @@
 and add_cltype id ty env =
   store_cltype id (Pident id) ty env
 
+let add_stage id st env =		(* NNN *)
+  store_stage id (Pident id) st env     (* NNN *)
+
 let add_local_constraint id info elv env =
   match info with
     {type_manifest = Some ty; type_newtype_level = Some (lv, _)} ->
diff -N -u -r ocaml-4.00.1.orig/typing/env.mli ocaml-4.00.1/typing/env.mli
--- ocaml-4.00.1.orig/typing/env.mli	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/typing/env.mli	2013-02-20 17:25:22.000000000 +0100
@@ -16,6 +16,8 @@
 
 open Types
 
+type stage = type_expr list	(* NNN *)
+
 type summary =
     Env_empty
   | Env_value of summary * Ident.t * value_description
@@ -26,6 +28,7 @@
   | Env_class of summary * Ident.t * class_declaration
   | Env_cltype of summary * Ident.t * class_type_declaration
   | Env_open of summary * Path.t
+  | Env_stage of summary * Ident.t * stage (* NNN *)
 
 type t
 
@@ -43,6 +46,7 @@
 val find_modtype: Path.t -> t -> modtype_declaration
 val find_class: Path.t -> t -> class_declaration
 val find_cltype: Path.t -> t -> class_type_declaration
+val find_stage: Path.t -> t -> stage	(* NNN *)
 
 val find_type_expansion:
     ?level:int -> Path.t -> t -> type_expr list * type_expr * int option
@@ -69,6 +73,7 @@
 val lookup_modtype: Longident.t -> t -> Path.t * modtype_declaration
 val lookup_class: Longident.t -> t -> Path.t * class_declaration
 val lookup_cltype: Longident.t -> t -> Path.t * class_type_declaration
+val lookup_stage: Longident.t -> t -> Path.t * stage (* NNN *)
 
 (* Insertion by identifier *)
 
@@ -82,6 +87,7 @@
 val add_class: Ident.t -> class_declaration -> t -> t
 val add_cltype: Ident.t -> class_type_declaration -> t -> t
 val add_local_constraint: Ident.t -> type_declaration -> int -> t -> t
+val add_stage: Ident.t -> stage -> t -> t (* NNN *)
 
 (* Insertion of all fields of a signature. *)
 
diff -N -u -r ocaml-4.00.1.orig/typing/predef.ml ocaml-4.00.1/typing/predef.ml
--- ocaml-4.00.1.orig/typing/predef.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/typing/predef.ml	2013-02-20 17:25:22.000000000 +0100
@@ -44,6 +44,7 @@
 and ident_int32 = ident_create "int32"
 and ident_int64 = ident_create "int64"
 and ident_lazy_t = ident_create "lazy_t"
+and ident_code = ident_create "code"    (* NNN *)
 
 let path_int = Pident ident_int
 and path_char = Pident ident_char
@@ -60,6 +61,7 @@
 and path_int32 = Pident ident_int32
 and path_int64 = Pident ident_int64
 and path_lazy_t = Pident ident_lazy_t
+and path_code   = Pident ident_code   (* NNN *)
 
 let type_int = newgenty (Tconstr(path_int, [], ref Mnil))
 and type_char = newgenty (Tconstr(path_char, [], ref Mnil))
@@ -75,6 +77,7 @@
 and type_int32 = newgenty (Tconstr(path_int32, [], ref Mnil))
 and type_int64 = newgenty (Tconstr(path_int64, [], ref Mnil))
 and type_lazy_t t = newgenty (Tconstr(path_lazy_t, [t], ref Mnil))
+and type_code t1 t2 = newgenty (Tconstr(path_code, [t1;t2], ref Mnil)) (* NNN *)
 
 let ident_match_failure = ident_create_predef_exn "Match_failure"
 and ident_out_of_memory = ident_create_predef_exn "Out_of_memory"
@@ -196,6 +199,17 @@
      type_manifest = None;
      type_variance = [true, false, false];
      type_newtype_level = None}
+ (* NNN added decl_code *)
+  and decl_code =
+    let (tvar1,tvar2) = (newgenvar(),newgenvar()) in
+    {type_params = [tvar1;tvar2];
+     type_arity = 2;
+     type_kind = Type_abstract;
+     type_loc = Location.none;
+     type_private = Public;
+     type_manifest = None;
+     type_variance = [true, false, false; true, false, false];
+     type_newtype_level = None}
   in
 
   let add_exception id l =
@@ -219,6 +233,7 @@
   add_type ident_int32 decl_abstr (
   add_type ident_nativeint decl_abstr (
   add_type ident_lazy_t decl_lazy_t (
+  add_type ident_code decl_code (     (* NNN *)
   add_type ident_option decl_option (
   add_type ident_format6 decl_format6 (
   add_type ident_list decl_list (
@@ -230,7 +245,7 @@
   add_type ident_string decl_abstr (
   add_type ident_char decl_abstr (
   add_type ident_int decl_abstr (
-    empty_env)))))))))))))))))))))))))))
+    empty_env))))))))))))))))))))))))))) )   (* NNN extra parenthesis *)
 
 let builtin_values =
   List.map (fun id -> Ident.make_global id; (Ident.name id, id))
diff -N -u -r ocaml-4.00.1.orig/typing/predef.mli ocaml-4.00.1/typing/predef.mli
--- ocaml-4.00.1.orig/typing/predef.mli	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/typing/predef.mli	2013-02-20 17:25:22.000000000 +0100
@@ -30,6 +30,7 @@
 val type_int32: type_expr
 val type_int64: type_expr
 val type_lazy_t: type_expr -> type_expr
+val type_code: type_expr ->  type_expr -> type_expr (* NNN *)
 
 val path_int: Path.t
 val path_char: Path.t
@@ -46,6 +47,7 @@
 val path_int32: Path.t
 val path_int64: Path.t
 val path_lazy_t: Path.t
+val path_code: Path.t  (* NNN *)
 
 val path_match_failure: Path.t
 val path_assert_failure : Path.t
diff -N -u -r ocaml-4.00.1.orig/typing/printtyped.ml ocaml-4.00.1/typing/printtyped.ml
--- ocaml-4.00.1.orig/typing/printtyped.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/typing/printtyped.ml	2013-02-20 17:25:22.000000000 +0100
@@ -355,6 +355,18 @@
   | Texp_pack me ->
       line i ppf "Pexp_pack";
       module_expr i ppf me
+        (* NNN: through the rest of the expression *)
+  | Texp_bracket e ->
+      line i ppf "Pexp_bracket";
+      expression i ppf e;
+  | Texp_escape e ->
+      line i ppf "Pexp_escape";
+      expression i ppf e;
+  | Texp_run e ->
+      line i ppf "Pexp_run";
+      expression i ppf e;
+  | Texp_cspval (_, li) ->
+      line i ppf "Pexp_cspval %a\n" fmt_longident li
 
 and value_description i ppf x =
   line i ppf "value_description\n";
diff -N -u -r ocaml-4.00.1.orig/typing/trx.ml ocaml-4.00.1/typing/trx.ml
--- ocaml-4.00.1.orig/typing/trx.ml	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/typing/trx.ml	2013-01-30 05:03:56.000000000 +0100
@@ -0,0 +1,1950 @@
+(*
+  This file is to post-process the Typedtree built by the type checker
+  before it is passed to the code generator -- to get rid of bracket,
+  escape and run. The main function is trx_structure, which initiates the
+  traversal and transforms every found expression with trx_exp. The
+  real transformation is done by trx_bracket.
+
+  For example,
+     <succ 1> 
+  gets transformed to 
+     mkApp <succ> <1> 
+  and eventually to
+     mkApp (mkIdent "succ") (mkConst 1)
+  One may say that we `push the brackets inside'.  We replace brackets
+  with calls to functions that will construct, at run-time, a
+  Parsetree, which is the representation of values of the code type.
+
+  Generally, the Parsetree is constructed when the program is run.
+  In some cases we can construct the Parsetree at compile time,
+  that is, when this trx.ml is run. Constants like <1> is such a case.
+  If we see <1>, or, in terms of trees,
+      Texp_bracket (Texp_constant (Constant_int 1))
+  we can immediately construct the Parsetree:
+      Pexp_constant (Constant_int 1)
+  After we construct the Parsetree at compile time, we use CSP to
+  pass it over to run-time. At run-time, we merely use the compiled constant.
+  This mechanism of building Parsetree at compile-time whenever possible
+  is one of the large differences from previous versions of MetaOCaml.
+
+  Future-stage Bindings.
+  Future-stage bindings are introduced by patterns in let, fun,
+  match, try and for forms. Global bindings are always at present-stage.
+  Since local modules in brackets are not allowed, all future bindings are
+  unqualified (i.e., simple names, without the module path).
+  The principal rule of translating binding forms is
+     <fun x -> e> ---> let x = gensym "x" in mkLAM x <e>
+  Emphatically, gensym cannot be generated at compile time!
+  Reason: consider the recursive invocation:
+     let rec f z = <fun y -> ~( ... f 1 ... )>
+
+  Thus, at run-time, we generate new names for bound variables and
+  use the OCaml's evaluator (the `run-time') to substitute these
+  new names in <e>. Therefore, a future-stage bound variable after
+  the translation becomes a present-stage bound variable,
+  but at a different type: string loc. We use string loc rather
+  than Longident.t loc since all, at present, future-stage bindings
+  are simple names.
+
+  We now check for scope extrusion: we enforce the region discipline
+  for generated identifiers. To make it easier to impose checks,
+  the translation rule is modified as follows
+     <fun x -> e> ---> with_binding_region "x" (fun x -> mkLAM x <e>)
+  For more complicated binding patterns, we iterate
+     <fun (x1,x2) -> e> ---> 
+       with_binding_region "x1" (fun x1 ->
+       with_binding_region "x2" (fun x2 ->
+         mkLAM (x1,x2) <e>))
+  etc.
+
+  Here are the main patterns of scope extrusion
+  let r = <0> in 
+  <fun x -> ~(r := <x + 1>; <()>)>
+
+  let r = <0> in
+  <fun x -> .~(<fun x -> ~(let v = <x> in r := <fun x -> ~v>; <()>)>; !r)>
+
+  exception E of int code
+  try <fun x -> ~(raise (E <x>)> with E x -> x
+  (actually we need a local polymorphic exception, but the idea is the same)
+
+  and similar using control effects.
+
+  The most obvious method of detecting the scope extrusion is traversing
+  the generated code looking for unbound identifiers. We can do
+  such a check when we are about to show or run the code, or
+  about to splice (in the latter case, we have to maintain
+  the dynamic environment of gensym'ed names generated by 
+  with_binding_region). However, reporting the scope
+  extrusion upon printing or running the code is reporting it too
+  late. Doing the check on each escape (since only splices can incorporate
+  scope-extruded code) means many repeated traversals of the generated
+  code.
+
+  We use a different method: we mark each piece of the generated code
+  with the `timestamp' of the latest free variable the code contains.
+  The partial order of free variables is the partial order of their
+  regions (nesting of with_binding_region calls).
+  If the timestamp is missing, the code is closed.
+  The function with_binding_region generates timestamps and
+  this function also checks that the generated binding form is
+  timestamped with exactly the timestamp of that 
+  particular with_binding_region (or the timestamp is missing).
+  After the checks, with_binding_region adjusts the time stamp
+  to that of the parent with_binding_region function.
+  Every code building function ( build_* ) checks to see that the timestamps
+  of incorporated fragments correspond to the timestamps of currently
+  alive variables.
+
+  Generally speaking, a single timestamp does not suffice. We should maintain
+  the full list of free variables for each piece of code. The AST building
+  functions will merge the lists; with_binding_region will check the list
+  and remove the gensym that with_binding_region has created.
+  A single timestamp is a sound approximation. It presupposes that a code
+  that contains a free variable also contains all earlier free variables.
+  Therefore, the safe code
+    let r = .<0> in 
+    let _ = .<fun x -> .~(r := .<fun y -> y>.; !r)>. in !r
+  will be flagged as scope-extruding. We go with the single timestamp
+  approximation for now as being simper.
+
+  Alas Parsetree doesn't have a dedicated field for marking expressions
+  with timestamps. Therefore, in an ad hoc and hacking way re-purpose
+  the Pexp_setinstvar node. To designate that a code expression 'e'
+  has a free variable 'x : string loc' we create a wrapper node
+   {pexp_loc = timestamp_loc;
+    pexp_desc = Pexp_setinstvar (x,e)}
+  We distinguish such special timestamp nodes by their unique pexp_loc,
+  being physically equal to timestamp_loc. Although a hack, this
+  convention avoids modifying the Parsetree data structure and makes it
+  easy to add, check and remove the timestamp.
+
+This file is based on trx.ml from the original MetaOCaml, but it is
+completely re-written from scratch and has many comments. The
+traversal algorithm, the way of compiling Parsetree builders, dealing
+with CSP and many other algorithms are all different.
+
+*)
+
+open Parsetree
+open Asttypes
+open Misc
+open Typedtree
+open Types
+
+(* BER MetaOCaml version string *)
+let meta_version  = "N 100"
+
+(* Co-opt Camlp4 class of warnings *)
+let debug_print : string -> unit = fun msg ->
+ ignore(Warnings.print Format.err_formatter 
+          (Warnings.Camlp4 msg))
+
+(* Emit a translation-time error *)
+let trx_error ?(loc = Location.none) fn =
+  raise (Typecore.Error (loc, Typecore.Trx_error fn))
+
+let not_supported loc msg =
+  trx_error ~loc:loc (fun ppf -> Format.fprintf ppf 
+      "%s is not yet supported within brackets" msg)
+
+(* left-to-right accumulating map *)
+let rec map_accum : ('accum -> 'a -> 'b * 'accum) -> 'accum -> 'a list ->
+  'b list * 'accum = fun f acc -> function
+    | []   -> ([],acc)
+    | h::t -> 
+        let (h,acc) = f acc h in
+        let (t,acc) = map_accum f acc t in
+        (h::t, acc)
+
+(* ------------------------------------------------------------------------ *)
+(* Path utilities *)
+
+(* We always use path when available, and convert it to Longident
+   when needed -- even if the Typedtree already carries the longident.
+   The path is preferred because it is fully qualified for
+   external identifiers and it is unambiguous.
+   If we open a module, its components can be referred to without
+   qualification -- the path will be qualified nevertheless.
+   When we build a Parsetree representing the generated code,
+   we have to use fully qualified identifiers since the open statement
+   in the original code won't be represented in the generated
+   Parsetree.
+*)
+
+(* Check to see if a path refers to an identifier, exception, or
+   constructor that is available from an external module. If so, the run-time
+   compiler invoked by .! can get the definition for the identifier from
+   a .cmi file. The value of an external identifier can be obtained from
+   a .cmo file.
+*)
+let is_external = function
+  | Path.Pident id -> Ident.persistent id              (* not qualified *)
+  | Path.Papply _  -> false
+  | Path.Pdot(Path.Pident id, _,_) -> Ident.persistent id
+  | _             -> false
+
+(* Convert a path to an identifier. Since the path is assumed to be
+   `global', time stamps don't matter and we can use just strings.
+*)
+let rec path_to_lid : Path.t -> Longident.t = function
+  | Path.Pident i       -> Longident.Lident (Ident.name i)
+  | Path.Pdot (p,s,_)   -> Longident.Ldot (path_to_lid p, s)
+  | Path.Papply (p1,p2) ->
+      Longident.Lapply(path_to_lid p1, path_to_lid p2)
+
+(* Replace the last component of p1 with p2, which should be a Pident
+   path 
+*)
+let path_replace_last : Path.t -> Path.t -> Path.t = fun p1 p2 ->
+ match (p1,p2) with
+  | (Path.Pident _,x) -> x
+  | (Path.Pdot(p1,_,s),Path.Pident id) -> Path.Pdot(p1,Ident.name id,s)
+  | _ -> assert false
+
+(* Check to make sure a constructor, label, exception, etc.
+   have the name that we can put into AST (Parsetree).
+   Local names can't be put into the Parsetree since the type env in which
+   they are declared is not represented in the Parsetree.
+*)
+let check_path_quotable msg path =
+  if not (is_external path) then
+    trx_error (fun ppf ->
+      Format.fprintf ppf 
+        "%s %s cannot be used within brackets. Put into a separate file."
+        msg (Path.name path))
+
+(* Check to see that a constructor belongs to a type defined
+   in a persistent module or in the initial environment.
+   Return the fully qualified name to put into AST 
+   (Pervasive constructors remain unqualified however).
+
+   We have nothing to do if the constructor is already fully qualified
+   with a persistent module identifier: for example, Scanf.Scan_failure.
+   The major complexity comes from this scenario:
+      open Scanf
+      .<raise (Scan_failure "xx")>.
+   The Texp_construct node of Typedtree contains the lid and the
+   path that refer to "Scan_failure" without any module qualifications.
+   We have to find the fully qualified path and check
+   that it is external. We do that by finding the path for the _type_
+   constructor, for the type of which the data constructor is a member.
+   That type_path is fully qualified. We can ascertain the later fact
+   from Typecore.constructors_of_type, which puts the complete path
+   into the type of the constructor, which is always of the form
+   Tconstr(ty_path,_,_). The function constructors_of_type is used
+   within store_type, which is used when opening a module.
+
+   Alternatively we could've used Env.lookup_constuctor, which also
+   returns the qualified path? Searching the environment is costly
+   though.
+ *)
+let qualify_ctor : Location.t -> Path.t -> constructor_description -> 
+  Longident.t loc = 
+ fun loc p cdesc ->
+  (fun lid -> Location.mkloc lid loc) (
+  let lid = path_to_lid p in
+  if is_external p then lid
+  else if try ignore (Env.lookup_constructor lid Env.initial); true
+          with Not_found -> false
+       then lid
+  else match (cdesc.cstr_tag, Ctype.repr cdesc.cstr_res) with
+  | (Cstr_exception (p,_),_) ->
+      if is_external p then path_to_lid p else
+       trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
+       "Exception %s cannot be used within brackets. Put into a separate file."
+        (Path.name p))
+  | (_,{desc = Tconstr(ty_path, _, _)}) ->
+      if is_external ty_path then
+        path_to_lid (path_replace_last ty_path p)
+      else
+      trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
+      "Constructor %s cannot be used within brackets. Put into a separate file."
+          (Path.name p))
+  | _ -> Printtyp.type_expr Format.err_formatter cdesc.cstr_res;
+           failwith ("qualify_ctor: cannot determine type_ctor from data_ctor "^
+                     Path.name p)
+  )
+
+(* Check to see that a record label belongs to a record defined
+   in a persistent module or in the initial environment.
+   This is a label version of qualify_ctor
+*)
+let qualify_label : Location.t -> Path.t -> label_description -> 
+  Longident.t loc =
+ fun loc p ldesc ->
+  (fun lid -> Location.mkloc lid loc) (
+  let lid = path_to_lid p in
+  if is_external p then lid
+  else if try ignore (Env.lookup_label lid Env.initial); true
+          with Not_found -> false
+       then lid
+  else match (Ctype.repr ldesc.lbl_res) with
+  | {desc = Tconstr(ty_path, _, _)} ->
+      if is_external ty_path then
+        path_to_lid (path_replace_last ty_path p)
+      else
+        trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
+          "Label %s cannot be used within brackets. Put into a separate file."
+          (Path.name p))
+  | _ -> Printtyp.type_expr Format.err_formatter ldesc.lbl_res;
+           failwith ("qualify_label: cannot determine type from label "^
+                     Path.name p)
+ )
+
+(* Test if we should refer to a CSP value by name rather than by
+   value
+*)
+(* Module identifiers for the modules that are expected to be
+   present at run-time -- that is, will be available for
+   dynamic linking of the run-time generated code.
+*)
+
+let ident_can_be_quoted = is_external
+
+
+let dummy_lid : string -> Longident.t loc = fun name ->
+  Location.mknoloc (Longident.Lident name)
+
+(* Exported. Used as a template for constructing lid expressions *)
+let sample_lid = dummy_lid "*sample*"
+
+(* Exported. Used as a template for constructing name expression *)
+let sample_name : string loc = mknoloc "*sample*"
+
+(* Exported. Used as a template for constructing Location.t expressions *)
+let sample_loc = Location.none
+
+(* Exported. Used as a template for constructing pattern lists expressions *)
+let sample_pat_list : Parsetree.pattern list = []
+
+(* Exported. Used as a template for passing the Asttypes.rec_flag *)
+let sample_rec_flag : Asttypes.rec_flag = Nonrecursive
+
+(* ------------------------------------------------------------------------ *)
+(* Building Texp nodes *)
+(* Env.initial is used for all look-ups. Unqualified identifiers
+   must be found there. For qualified identifiers, Env.lookup
+   functions look things up in the persistent structures, loading them
+   up as needed.
+*)
+
+let mk_texp : ?env:Env.t -> Typedtree.expression_desc -> type_expr -> 
+  Typedtree.expression =
+  fun ?(env=Env.initial) desc ty ->
+  { exp_desc = desc; exp_type = ty;
+    exp_loc  = Location.none; exp_extra = [];
+    exp_env  = env }
+
+(* TODO: add memoization? *)
+
+(* Compiling an identifier with a given (qualified) name *)
+let texp_ident : string -> expression = fun name ->
+  let lid     = Longident.parse name in
+  let (p, vd) = try Env.lookup_value lid Env.initial 
+                with Not_found -> fatal_error ("Trx.find_value: " ^ name) in
+  mk_texp (Texp_ident (p,mknoloc lid, vd))
+          (Ctype.instance Env.initial vd.val_type)
+
+
+(* Building an application *)
+let texp_apply : Typedtree.expression -> Typedtree.expression list -> 
+ Typedtree.expression_desc = fun f args ->
+   Texp_apply(f, List.map (fun arg -> ("",Some arg, Required)) args)
+
+(* Compiling location data *)
+let texp_loc : Location.t -> Typedtree.expression = fun loc ->
+  let loc_exp = texp_ident "Trx.sample_loc" in (* this fills in the type, etc.*)
+  {loc_exp with exp_desc = Texp_cspval (Obj.repr loc, dummy_lid "*loc*")}
+
+(* Compiling longident with location data *)
+let texp_lid : Longident.t loc -> Typedtree.expression = fun lid ->
+  let lid_exp = texp_ident "Trx.sample_lid" in (* this fills in the type, etc.*)
+  {lid_exp with exp_desc = Texp_cspval (Obj.repr lid, dummy_lid "*lid*")}
+
+(* Compiling a string constant *)
+let texp_string : string -> Typedtree.expression = fun str ->
+  mk_texp (Texp_constant (Const_string str))
+          (Ctype.instance_def Predef.type_string)
+
+(* Compiling a boolean *)
+(* For prototype, see Typecore.option_none *)
+let texp_bool : bool -> Typedtree.expression = fun b ->
+  let lid = Longident.Lident (if b then "true" else "false") in
+  let (path, cdec) = Env.lookup_constructor lid Env.initial in
+  mk_texp (Texp_construct(path, mknoloc lid, cdec, [], false))
+          (Ctype.instance_def Predef.type_bool)
+
+(* Compiling an option *)
+(* For prototype, see Typecore.option_none *)
+let texp_option : Typedtree.expression option -> Typedtree.expression = 
+  function
+    | None -> 
+        let lid = Longident.Lident "None" in
+        let (path, cnone) = Env.lookup_constructor lid Env.initial in
+        mk_texp (Texp_construct(path, mknoloc lid, cnone, [], false))
+                (Btype.newgenvar ())
+    | Some e ->
+        let lid = Longident.Lident "Some" in
+        let (path, csome) = Env.lookup_constructor lid Env.initial in
+        mk_texp (Texp_construct(path, mknoloc lid , csome, [e],false))
+                (Ctype.instance_def (Predef.type_option e.exp_type)) 
+                ~env:e.exp_env
+
+(* Compiling a tuple *)
+let texp_tuple : Typedtree.expression list -> Typedtree.expression = fun el ->
+  mk_texp (Texp_tuple el)
+          (Ctype.newty (Ttuple (List.map (fun e -> e.exp_type) el)))
+
+(* Compiling an array *)
+(* We use this function for grouping trx_bracket-transformed expressions,
+   which have the same representation type (but may be different
+   code type). We ignore the differences in the code type, since
+   the representation type is the same.
+
+   We don't use lists since they are harder to compile, and more
+   fragile. Texp_construct has more arguments, we have to locate
+   constructor information, etc.
+*)
+let texp_array : Typedtree.expression list -> Typedtree.expression = function
+  | [] -> 
+      mk_texp (Texp_array []) 
+	      (Ctype.instance_def (Predef.type_array (Btype.newgenvar ())))
+  | (h::_) as el ->
+      mk_texp (Texp_array el) 
+	      (Ctype.instance_def (Predef.type_array h.exp_type))
+
+(* ------------------------------------------------------------------------ *)
+(* Bindings in the future stage *)
+(* Recall, all bindings at the future stage are introduced by
+   patterns, and hence are simple names, without any module qualifications.
+*)
+let gensym_count = ref 0
+
+(* Generate a fresh name with a given base name *)
+let gensym : string -> string = fun s ->
+  incr gensym_count;
+  s ^ "_" ^ string_of_int !gensym_count
+
+let reset_gensym_counter () = gensym_count := 0
+
+(* Make a simple identifier unique *)
+let genident : string loc -> string loc = fun name ->
+  {name with txt = gensym name.txt}
+
+(* This is a run-time error, rather than a translation-time error *)
+let scope_extrusion_error : Location.t -> string loc -> 'a = fun l var ->
+  Format.fprintf Format.str_formatter
+    "Scope extrusion at %a for the identifier %s bound at %a"
+    Location.print l var.txt Location.print var.loc;
+  failwith (Format.flush_str_formatter ())
+
+(* The names of gensym'd future stage bindings currently in scope,
+   of new_binding_region.
+   We use physical equality to search the list.
+   Therefore, we may reset_gensym_counter on each top-level phrase.
+*)
+let bindings_in_scope : string loc list ref = ref []
+
+(* Return the index of a given free variable in bindings_in_scope:
+   essentially the de Bruijn index.
+   Report a scope extrusion error if any.
+*)
+let fvar_dB_index : Location.t -> string loc -> int = fun l var ->
+  let rec loop n = function
+    | h::t -> if h == var then n        (* physical equality! *)
+              else loop (succ n) t
+    | []   -> scope_extrusion_error l var
+  in loop 0 !bindings_in_scope
+
+(* Dedicated Location.t for the identification of timestamp nodes 
+   We test the comparison with timestamp_loc using physical equality.
+*)
+let timestamp_loc =
+  let open Lexing in
+  let loc = dummy_pos in
+  let loc = {loc with pos_fname = "**timestamp**"} in
+  {Location.loc_start = loc; loc_end = loc; loc_ghost=true}
+
+
+(* check to see if an expression has a time-stamp. If so, remove it
+   and return the un-timestamped expression. Return the latest of the
+   removed timestamp and the given as the argument.
+   The timestamp is just the variable name.
+*)
+let remove_tstamp : string loc option -> Parsetree.expression -> 
+  Parsetree.expression * string loc option = fun old_tstamp -> function
+  | {pexp_loc = tloc; pexp_desc = Pexp_setinstvar (var,e)} 
+    when tloc == timestamp_loc -> 
+     let vi = fvar_dB_index e.pexp_loc var in (* also checks that vi is alive *)
+     begin match old_tstamp with
+      | None      -> (e,Some var)
+      | Some var' -> 
+         if var == var' then (e,Some var) else (* common case *)
+         let vi' = fvar_dB_index e.pexp_loc var' in
+         (e, Some (if vi' > vi then var else var'))
+     end
+  |  e -> (e,old_tstamp)
+
+     
+(* Add a timestamp to an expression *)
+let add_timestamp : string loc option -> Parsetree.expression -> 
+  Parsetree.expression = fun var e ->
+  match var with 
+  | None     -> e
+  | Some var -> 
+  {pexp_loc  = timestamp_loc;
+   pexp_desc = Pexp_setinstvar (var,e)}
+
+let remove_tstamp_option : string loc option -> 
+  Parsetree.expression option -> 
+  Parsetree.expression option * string loc option = fun var -> function
+    | None   -> (None,var)
+    | Some e -> let (e,var) = remove_tstamp var e in (Some e,var)
+
+(* Generate a gensym with a given base name and enter a new region 
+   in which this gensym will live
+*)
+let with_binding_region : string loc -> 
+  (string loc -> Parsetree.expression) -> Parsetree.expression =
+  fun name_base body ->
+    let old_bindings = !bindings_in_scope in
+    let new_var = genident name_base in
+    let () = bindings_in_scope := new_var :: old_bindings in
+    try 
+      let r = body new_var in
+      let remr = remove_tstamp None r in (* checks tstamp *) 
+      let () = bindings_in_scope := old_bindings in
+      match remr with
+      | (e,None) -> e
+      | (e,Some var) when var == new_var ->
+          add_timestamp (match old_bindings with h::_ -> Some h | _ -> None) e
+      | (e,Some var) ->
+          let _ = fvar_dB_index e.pexp_loc var  (* check that var is current *)
+          in r
+    with e -> bindings_in_scope := old_bindings; raise e
+
+let check_scope_extrusion : Parsetree.expression -> Parsetree.expression = 
+  fun exp -> fst (remove_tstamp None exp)
+
+(* Convert the meta-level (fun var -> body) to the Typedtree.expression
+   representing the same function, and use the result generate the call to
+   with_binding_region
+*)
+let texp_binding_simple : 
+  Ident.t * string loc -> (Typedtree.expression -> Typedtree.expression) ->
+  Typedtree.expression_desc = fun (id,name) fbody ->
+  let name_exp = texp_ident "Trx.sample_name" in
+  let base_name_exp = 
+    {name_exp with
+     exp_desc = Texp_cspval (Obj.repr name, dummy_lid "*name*")} in
+  let pat = { pat_desc = Tpat_var (id,name);
+              pat_loc  = name.loc; pat_extra = [];
+              pat_type = name_exp.exp_type;
+              pat_env  = name_exp.exp_env }(* not including the binding to id!*)
+  in
+  let name_vd = match name_exp.exp_desc with
+                  | Texp_ident (_,_,vd) -> vd
+                  | _ -> assert false in
+  let gensymed_exp =                (* translated var *)
+    {name_exp with exp_desc = 
+       Texp_ident (Path.Pident id,
+                    (mkloc (Longident.Lident name.txt) name.loc),name_vd)} in
+  let body = fbody gensymed_exp in 
+  let fun_body_exp = 
+        { body with
+          exp_desc = Texp_function ("",[(pat,body)],Total); 
+          exp_type = Ctype.newty (Tarrow("", name_exp.exp_type, 
+                                             body.exp_type, Cok)) }
+  in
+  texp_apply (texp_ident "Trx.with_binding_region")
+    [base_name_exp; fun_body_exp]
+
+(* ------------------------------------------------------------------------ *)
+(* Building Parsetree nodes *)
+
+(* Handle timestamp for builders of the type 
+      Parsetree.expression -> Parsetree.expression
+*)
+let timestamp_wrapper : 
+    (Location.t -> Parsetree.expression -> Parsetree.expression) ->
+    (Location.t -> Parsetree.expression -> Parsetree.expression) =
+fun f l e ->
+  let (e,var) = remove_tstamp None e in
+  add_timestamp var (f l e)
+
+(* building a typical Parsetree node: Pexp_assert of expression*)
+let build_assert : Location.t -> Parsetree.expression -> Parsetree.expression = 
+  timestamp_wrapper
+  (fun l e -> {pexp_loc = l; pexp_desc = Pexp_assert e})
+
+(* When we translate the typed-tree, we have to manually compile
+   the above code 
+First, to see the AST for the phrase, invoke the top-level with the flag
+-dparsetree. Then
+   {pexp_loc  = l; pexp_desc = Pexp_assert e}
+
+gives the parsetree:
+let build_assert_ast : Location.t -> Parsetree.expression -> Parsetree.expression = 
+{pexp_loc = l1;
+ pexp_desc = 
+  Pexp_record
+        ([(Location.mknoloc (Longident.parse "Parsetree.pexp_loc"), 
+           Pexp_ident "l");
+         (Location.mknoloc (Longident.parse "Parsetree.pexp_desc"),
+           {pexp_loc  = Location.none;
+            pexp_desc = Pexp_construct 
+                          ((Location.mknoloc (Longident.parse 
+                                                "Parsetree.Pexp_assert")),
+              Some {pexp_loc = Location.none;
+                    pexp_desc = Pexp_ident "e"},
+              false)})
+        ],
+        None)}
+type_expression
+
+If building the parsetree on our own, beware! For example, labels in
+Texp_record must be sorted, in their declared order!
+*)
+
+(* Other similar builders *)
+let build_lazy : Location.t -> Parsetree.expression -> Parsetree.expression = 
+  timestamp_wrapper
+    (fun l e -> {pexp_loc = l; pexp_desc = Pexp_lazy e})
+let build_bracket : Location.t -> Parsetree.expression -> Parsetree.expression= 
+  timestamp_wrapper
+    (fun l e -> {pexp_loc = l; pexp_desc = Pexp_bracket e})
+let build_escape : Location.t -> Parsetree.expression -> Parsetree.expression = 
+  timestamp_wrapper
+    (fun l e -> {pexp_loc = l; pexp_desc = Pexp_escape e})
+let build_run : Location.t -> Parsetree.expression -> Parsetree.expression = 
+  timestamp_wrapper
+    (fun l e -> {pexp_loc = l; pexp_desc = Pexp_run e})
+
+let build_sequence : 
+  Location.t -> Parsetree.expression -> Parsetree.expression -> 
+  Parsetree.expression = 
+  fun l e1 e2 -> 
+    let (e1,var) = remove_tstamp None e1 in
+    let (e2,var) = remove_tstamp var  e2 in
+    add_timestamp var
+    {pexp_loc = l; pexp_desc = Pexp_sequence (e1,e2) }
+let build_while : 
+  Location.t -> Parsetree.expression -> Parsetree.expression -> 
+  Parsetree.expression = 
+  fun l e1 e2 -> 
+    let (e1,var) = remove_tstamp None e1 in
+    let (e2,var) = remove_tstamp var  e2 in
+    add_timestamp var
+    {pexp_loc = l; pexp_desc = Pexp_while (e1,e2) }
+let build_when : 
+  Location.t -> Parsetree.expression -> Parsetree.expression -> 
+  Parsetree.expression = 
+  fun l e1 e2 -> 
+    let (e1,var) = remove_tstamp None e1 in
+    let (e2,var) = remove_tstamp var  e2 in
+    add_timestamp var
+      {pexp_loc = l; pexp_desc = Pexp_when (e1,e2) }
+
+(* Build the application. The first element in the array is the
+   function. The others are arguments. *)
+let build_apply : Location.t -> (label * Parsetree.expression) array -> 
+  Parsetree.expression = 
+  fun l ea -> 
+    assert (Array.length ea > 1);
+    let (el,var) = map_accum 
+        (fun var (l,e) -> let (e,var) = remove_tstamp var e in ((l,e),var))
+        None (Array.to_list ea) in
+    add_timestamp var
+    {pexp_loc  = l; 
+     pexp_desc = Pexp_apply (snd (List.hd el),List.tl el)}
+
+let build_tuple : 
+  Location.t -> Parsetree.expression array -> Parsetree.expression =
+  fun l ea -> 
+    let (el,var) = map_accum remove_tstamp None (Array.to_list ea) in
+    add_timestamp var
+      {pexp_loc = l; pexp_desc = Pexp_tuple el }
+
+let build_array : 
+  Location.t -> Parsetree.expression array -> Parsetree.expression =
+  fun l ea -> 
+    let (el,var) = map_accum remove_tstamp None (Array.to_list ea) in
+    add_timestamp var
+      {pexp_loc = l; pexp_desc = Pexp_array el }
+
+let build_ifthenelse : 
+  Location.t -> 
+  Parsetree.expression -> Parsetree.expression -> Parsetree.expression option ->
+  Parsetree.expression =
+  fun l e1 e2 eo -> 
+    let (e1,var) = remove_tstamp None e1 in
+    let (e2,var) = remove_tstamp var  e2 in
+    let (eo,var) = remove_tstamp_option var eo in
+    add_timestamp var
+      {pexp_loc = l; pexp_desc = Pexp_ifthenelse (e1,e2,eo) }
+
+let build_construct :
+ Location.t -> Longident.t loc -> Parsetree.expression array -> bool ->
+ Parsetree.expression =
+ fun loc lid args explicit_arity ->
+   let (args,var) = map_accum remove_tstamp None (Array.to_list args) in
+   add_timestamp var
+  {pexp_loc  = loc;
+   pexp_desc = Pexp_construct (lid,
+     begin
+      match args with
+      | []  -> None
+      | [x] -> Some x
+      | xl  -> Some { pexp_loc  = loc; pexp_desc = Pexp_tuple xl }
+     end,
+     explicit_arity) }
+
+let build_record :
+ Location.t -> (Longident.t loc * Parsetree.expression) array ->
+ Parsetree.expression option -> Parsetree.expression =
+ fun loc lel eo ->
+    let (lel,var) = map_accum 
+        (fun var (l,e) -> let (e,var) = remove_tstamp var e in ((l,e),var))
+        None (Array.to_list lel) in
+   let (eo,var) = remove_tstamp_option var eo in
+   add_timestamp var
+      {pexp_loc  = loc; pexp_desc = Pexp_record (lel,eo)}
+
+let build_field :
+ Location.t -> Parsetree.expression -> Longident.t loc -> Parsetree.expression =
+ fun loc e lid ->
+   let (e,var) = remove_tstamp None e in
+   add_timestamp var
+     {pexp_loc  = loc;
+      pexp_desc = Pexp_field (e,lid)}
+
+let build_setfield :
+ Location.t -> Parsetree.expression -> Longident.t loc -> 
+   Parsetree.expression -> Parsetree.expression =
+ fun loc e1 lid e2 ->
+   let (e1,var) = remove_tstamp None e1 in
+   let (e2,var) = remove_tstamp var  e2 in
+   add_timestamp var
+     {pexp_loc  = loc;
+      pexp_desc = Pexp_setfield (e1,lid,e2)}
+
+let build_variant :
+ Location.t -> string -> Parsetree.expression option -> Parsetree.expression =
+ fun loc l eo ->
+   let (eo,var) = remove_tstamp_option None eo in
+   add_timestamp var
+     {pexp_loc  = loc;
+      pexp_desc = Pexp_variant (l,eo)}
+
+let build_send :
+ Location.t -> Parsetree.expression -> string -> Parsetree.expression =
+ fun loc e l ->
+   let (e,var) = remove_tstamp None e in
+   add_timestamp var
+     {pexp_loc  = loc;
+      pexp_desc = Pexp_send (e,l)}
+
+let build_open :
+ Location.t -> Longident.t loc -> Parsetree.expression -> Parsetree.expression =
+ fun loc l e ->
+   let (e,var) = remove_tstamp None e in
+   add_timestamp var
+     {pexp_loc  = loc;
+      pexp_desc = Pexp_open (l,e)}
+
+
+(* Build a Parsetree for a future-stage identifier
+   It is always in scope of with_binding_region:
+   Bound variables are always in scope of their binders;
+   A well-typed code has no unbound variables.
+*)
+let build_ident : Location.t -> string loc -> Parsetree.expression =
+ fun loc l ->
+  add_timestamp (Some l)
+   {pexp_loc  = loc;
+    pexp_desc = Pexp_ident (mkloc (Longident.Lident l.txt) l.loc)}
+
+let build_for : 
+  Location.t -> string loc -> Parsetree.expression -> Parsetree.expression -> 
+  bool -> Parsetree.expression -> Parsetree.expression =
+  fun l name elo ehi dir ebody -> 
+  let (elo,var)   = remove_tstamp None elo in
+  let (ehi,var)   = remove_tstamp var  ehi in
+  let (ebody,var) = remove_tstamp var  ebody in
+  add_timestamp var
+  {pexp_loc = l; 
+   pexp_desc = Pexp_for (name,elo,ehi,(if dir then Upto else Downto), ebody) }
+
+let build_fun_simple : 
+  Location.t -> string -> string loc -> Parsetree.expression -> 
+  Parsetree.expression =
+  fun l label name ebody -> 
+  let (ebody,var) = remove_tstamp None ebody in
+  let pat = {ppat_loc  = l; ppat_desc = Ppat_var name} in
+  add_timestamp var
+  {pexp_loc = l; 
+   pexp_desc = Pexp_function (label,None,[(pat,ebody)])}
+
+let build_let_simple : 
+  Location.t -> rec_flag -> string loc -> Parsetree.expression -> 
+  Parsetree.expression -> Parsetree.expression =
+  fun l recf name e ebody -> 
+  let (e,var)     = remove_tstamp None e in
+  let (ebody,var) = remove_tstamp var  ebody in
+  let pat = {ppat_loc  = l; ppat_desc = Ppat_var name} in
+  add_timestamp var
+  {pexp_loc = l; 
+   pexp_desc = Pexp_let (recf,[(pat,e)],ebody)}
+
+(* All simple Pext_ident must use alive gensym'd names  *)
+(*
+let rec check_scope_extrusion : Parsetree.expression -> unit = fun exp ->
+  let check = check_scope_extrusion in
+  let check_option = function 
+    | None -> () 
+    | Some e -> check e in
+  let check_list = List.iter check in
+  let check_xl l   = List.iter (fun (_,e) -> check e) l in
+  match exp.pexp_desc with
+  | Pexp_ident ({txt = Longident.Lident s} as l) ->
+      if not (BVar.mem (mkloc s l.loc) !bindings_in_scope) then
+        (* This is a run-time error, rather than translation-time error *)
+        (Format.fprintf Format.str_formatter
+            "Scope extrusion at %a for the identifier %s bound at %a"
+             Location.print exp.pexp_loc s Location.print l.loc;
+         failwith (Format.flush_str_formatter ()))
+  | Pexp_ident _    -> ()
+  | Pexp_constant _ -> ()
+  | Pexp_let (_,pel,e)       -> check_xl pel; check e
+  | Pexp_function (_,None,pel) -> ()
+  | Pexp_apply (e,lel)       -> check e; check_xl lel
+  | Pexp_match (e,pel)       -> check e; check_xl pel
+  | Pexp_try (e,pel)         -> check e; check_xl pel
+  | Pexp_tuple el            -> check_list el
+  | Pexp_construct (_,eo,_)  -> check_option eo
+  | Pexp_variant (_,eo)      -> check_option eo
+  | Pexp_record (lel,eo)     -> check_xl lel; check_option eo
+  | Pexp_field (e,_)         -> check e
+  | Pexp_setfield (e1,_,e2)  -> check e1; check e2
+  | Pexp_array el            -> check_list el 
+  | Pexp_ifthenelse (e1,e2,eo) -> check e1; check e2; check_option eo
+  | Pexp_sequence (e1,e2)    -> check e1; check e2
+  | Pexp_while (e1,e2)       -> check e1; check e2
+  | Pexp_for (_,e1,e2,_,e3)  -> ()      (* we run when construct *)
+  | Pexp_constraint (e,_,_)  -> check e
+  | Pexp_when (e1,e2)        -> check e1; check e2
+  | Pexp_send (e,_)          -> check e
+  | Pexp_new _               -> ()
+  | Pexp_setinstvar (_,e)    -> check e
+  | Pexp_override lel        -> check_xl lel
+  | Pexp_assert e            -> check e
+  | Pexp_assertfalse         -> ()
+  | Pexp_lazy e              -> check e
+  | Pexp_poly (e,_)          -> check e
+  | Pexp_object _            -> ()
+  | Pexp_newtype (_,e)       -> check e
+  | Pexp_pack _              -> ()
+  | Pexp_open (_,e)          -> check e
+  | Pexp_bracket e           -> check e
+  | Pexp_escape e            -> check e
+  | Pexp_run e               -> check e
+  | Pexp_cspval _            -> ()
+  | _                        -> assert false (* can't occur in generated code *)
+*)
+
+
+(* ------------------------------------------------------------------------ *)
+(* Dealing with CSP *)
+
+exception CannotLift
+
+(* Analyze the type of the expression and figure out if we can lift it.
+   Raise CannotLift if cannot (e.g., the type is polymorphic), or it is too
+   much to bother.
+   TODO: lists, arrays, option types of liftable types are themselves
+   liftable. We can lift many more types. For arrays, check their length.
+   If the array is short, it should be lifted. For long arrays,
+   building a CSP is better (although it make take a bit longer since
+   we will have to invoke dyn_quote at run-time).
+
+   TODO: currently we generate calls to run-time functions like 
+   lift_constant_int to do the Parsetree generation. In the future
+   we should `inline' those functions -- that is, obtain the Typedtree
+   for them and use the tree for building Texp_apply.
+*)
+let lift_as_literal : 
+  Typedtree.expression -> Path.t -> Longident.t loc -> 
+  Typedtree.expression_desc = fun exp p li ->
+  let exp_ty =
+        Ctype.expand_head exp.exp_env (Ctype.correct_levels exp.exp_type) in
+  match Ctype.repr exp_ty with
+    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_int ->
+        texp_apply (texp_ident "Trx.lift_constant_int") [exp]
+    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_char ->
+        texp_apply (texp_ident "Trx.lift_constant_char") [exp]
+    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_bool ->
+        texp_apply (texp_ident "Trx.lift_constant_bool") [exp]
+          (* double and string are handled by dyn_quote *)
+    | _ -> raise CannotLift
+
+(* TODO: similarly handle Const_nativeint, Const_int32, Const_int64 *)
+let lift_constant_int : int -> Parsetree.expression = fun x -> 
+  {pexp_loc  = Location.none;
+   pexp_desc = Pexp_constant (Const_int x)}
+
+let lift_constant_char : char -> Parsetree.expression = fun x -> 
+  {pexp_loc  = Location.none;
+   pexp_desc = Pexp_constant (Const_char x)}
+
+let lift_constant_bool : bool -> Parsetree.expression = fun x -> 
+  let b = if x then "true" else "false" in 
+  {pexp_loc  = Location.none;
+   pexp_desc = Pexp_construct (Location.mknoloc (Longident.Lident b), 
+                               None, false)}
+
+
+(* Lift the run-time value v into a Parsetree for the code that, when
+   run, will produce v.
+   We do not have the type information for v, but we can examine
+   its run-time representation, to decide if we lift it is a source
+   literal or as a CSP.
+
+  TODO: also check for double_array_tag
+   and create a (structured) constant for a double array
+*)
+let dyn_quote : Obj.t -> Longident.t loc -> Parsetree.expression =
+  fun v li ->
+   let dflt = Pexp_cspval(v,li) in        (* By default, we build CSP *)
+   let desc = 
+    match Obj.is_int v with
+    | true -> dflt  (* If v looks like an int, it can represent many things: *)
+                    (* can't lift *)
+    | false when Obj.tag v = Obj.double_tag ->
+      Pexp_constant (Const_float (string_of_float (Obj.obj v)))
+    | false when Obj.tag v = Obj.string_tag ->
+      Pexp_constant (Const_string (Obj.obj v))
+    | _   -> dflt
+   in 
+   {pexp_loc = li.loc; pexp_desc = desc}
+
+       
+(* Build the Typedtree that lifts the variable with the given path and type.
+   Since this code receives the type of the variable, we use the
+   type to generate the lifting code for that particular type.
+   For example, we build the code to convert a float
+   0.1 to the Parsetree node Pexp_constant(Const_float "0.1")).
+   If we cannot or would not do the type-dependent lifting and we cannot
+   refer to the variable by name (e.g., because it is local),
+   we generate the call to the dynamic quoter, dyn_quote.
+   The latter will receive the actual value to quote and will generate,
+   at run-time, a Parsetree constant or CSP, based on that value.
+ *)
+let trx_csp : 
+  Typedtree.expression -> Path.t -> Longident.t loc ->
+  Typedtree.expression_desc = fun exp p li ->
+  (* First we try lifting as a constant *)
+  try lift_as_literal exp p li 
+  with CannotLift ->
+  (* Then check if we can pass by reference *)
+  if ident_can_be_quoted p then
+     let ast = 
+         {pexp_loc = exp.exp_loc;
+          pexp_desc = Pexp_ident (Location.mkloc (path_to_lid p) li.loc)}
+      in Texp_cspval (Obj.repr ast, dummy_lid "*id*")
+  else
+  (* Otherwise, do the lifting at run-time *)
+  texp_apply (texp_ident "Trx.dyn_quote") [exp; texp_lid li]
+
+
+(* Analyze and translate a pattern:
+         Typedtree.pattern -> Parsetree.pattern
+  The function is somewhat similar to tools/untypeast.ml;untype_pattern
+
+  However, we also determine and return the list of bound variables.
+  The list is in the reverse of the order of variables occurring in the pattern.
+  Finally, we check that labels and constructors may be quoted.
+
+  The algorithm of determining the names of bound variables is based
+  on Typedtree.pat_bound_idents. There is one subtle issue.
+  Normally all variables within a pattern are unique (patterns are
+  always linear). Identically named variables within a list of patterns, like 
+      match ... with
+      | [x] -> 
+      | [x;y] ->
+  are _distinct_ variables. They have different Ident.t values, even though
+  their names may be the same. However, components of an OR pattern 
+  bind exactly the same identifiers. Don't count them twice!
+*)
+
+
+(* The first argument is a list of identifiers. Found identifiers are
+   prepended to that list. The order of identifiers is important!
+   If you change the traversal order, be sure to modify pattern_subst below!
+*)
+let rec trx_pattern : 
+    (Ident.t * string loc) list -> Typedtree.pattern -> 
+     Parsetree.pattern * (Ident.t * string loc) list = fun acc pat ->
+ if not (pat.pat_extra = []) then
+   not_supported pat.pat_loc
+    "patterns with unpack, constraints, and other pat_extra";
+  let (pd,acc) = match pat.pat_desc with
+  | Tpat_any -> (Ppat_any, acc)
+  | Tpat_var (id, name) when 
+      (match (Ident.name id).[0] with 'A'..'Z' -> true | _ -> false) ->
+        (Ppat_unpack name,acc)        (* We don't handle modules though...*)
+  | Tpat_var (id, name) ->
+      (Ppat_var name, (id,name)::acc)
+  | Tpat_alias (p, id, name) ->
+      let (p,acc) = trx_pattern acc p in
+      (Ppat_alias (p, name),(id,name)::acc)
+  | Tpat_constant cst -> (Ppat_constant cst, acc)
+  | Tpat_tuple lst ->
+    let (pl,acc) = map_accum trx_pattern acc lst
+    in (Ppat_tuple pl, acc)
+  | Tpat_construct (p, li, cdesc, args, explicit_arity) ->
+      let lid = qualify_ctor li.loc p cdesc in
+      let (args,acc) = map_accum trx_pattern acc args in
+      (Ppat_construct (lid,
+          (match args with
+          | []  -> None 
+          | [x] -> Some x 
+          | _   -> Some {ppat_desc = Ppat_tuple args; ppat_loc = pat.pat_loc}),
+          explicit_arity),
+       acc)
+  | Tpat_variant (label, None, _) -> (Ppat_variant (label,None),acc)
+  | Tpat_variant (label, Some p, _) ->
+      let (p,acc) = trx_pattern acc p 
+      in (Ppat_variant (label,Some p),acc)
+  | Tpat_record (lst, closed) ->
+      let dolab acc (p,li,ldesc,pat) =
+        let lid = qualify_label li.loc p ldesc in
+        let (pat,acc) = trx_pattern acc pat in
+        ((lid,pat),acc)
+      in
+      let (lpl,acc) = map_accum dolab acc lst in
+      (Ppat_record (lpl,closed),acc)
+  | Tpat_array lst -> 
+    let (pl,acc) = map_accum trx_pattern acc lst
+    in (Ppat_array pl, acc)
+  | Tpat_or (p1, p2, _) -> 
+      (* Invariant : both arguments bind the same variables *)
+      let (p1,acc) = trx_pattern acc p1 in
+      let (p2,_)   = trx_pattern acc p2 in (* ignore vars in p2 *)
+      (Ppat_or (p1,p2),acc)
+  | Tpat_lazy p -> 
+      let (p,acc) = trx_pattern acc p in (Ppat_lazy p,acc)
+  in
+  ({ ppat_desc = pd; ppat_loc = pat.pat_loc}, acc)
+
+(* Process all patterns in the pattern-expression list *)
+(* Patterned are processed left-to-right. The found bound identifiers
+   are added to lst, in strict reverse order. The last identifier added
+   by the last (right-most) pattern in the list is at the head
+   of the list of identifiers.
+*)
+let trx_pel : 
+    (Ident.t * string loc) list -> 
+     (Typedtree.pattern * Typedtree.expression) list -> 
+     Parsetree.pattern list * (Ident.t * string loc) list = 
+   map_accum (fun acc (p,_) -> trx_pattern acc p)
+
+(* Substitute the names of bound variables in the pattern.
+   The new names are given in the string loc list. We
+   take advantage of the fact that patterns are linear and
+   the list of new names is ordered, in the order the bound
+   variables occur in the pattern. Therefore, we substitute based
+   on position.
+   OR-patterns bring complexity however: both branches of an OR
+   pattern bind exactly the same variables (but the order of
+   variable occurrence within branches may be different).
+   So for OR patterns we substitute by name, taking advantage
+   of the fact the new names differ from the old ones in _nnn
+   suffix. OR patterns are uncommon, so the complication of their processing
+   is not that bad.
+
+   This function is closely related to trx_pattern; It relies on the
+   same pattern traversal order as trx_pattern.
+ *)
+
+         (* two strings are the same up to (and including) n *)
+let rec same_upto s1 s2 n =
+  n < 0 || (s1.[n] = s2.[n] && same_upto s1 s2 (n-1))
+
+let rec pattern_subst : ?by_name:bool ->
+    string loc list -> Parsetree.pattern -> 
+     Parsetree.pattern * string loc list = fun ?(by_name=false) acc pat ->
+ if acc = [] then (pat,acc) else           (* no more variables to subst *)
+ let subst old_name acc =
+   if by_name then begin
+     let new_name =
+       try List.find (fun n -> 
+         same_upto old_name.txt n.txt (String.rindex n.txt '_' - 1)) acc 
+       with _ ->
+         begin
+           Format.fprintf Format.str_formatter "old_name %s %a\n"
+             old_name.txt Location.print old_name.loc;
+           List.iter (fun n -> Format.fprintf Format.str_formatter
+               "new name %s %a\n" n.txt Location.print n.loc) acc;
+           failwith (Format.flush_str_formatter ())
+         end
+     in
+     (new_name, acc)                       (* don't bother removing from acc*)
+   end
+   else match acc with
+   | h::t -> (h,t)
+   | _    -> assert false
+ in
+ let (desc,acc) = match pat.ppat_desc with
+  | Ppat_any as x -> (x,acc)
+  | Ppat_var old_name ->
+      let (new_name,acc) = subst old_name acc in (Ppat_var new_name,acc)
+  | Ppat_alias (p,old_name) ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     let (new_name,acc) = subst old_name acc in 
+     (Ppat_alias (p,new_name),acc)
+  | Ppat_constant _ as x -> (x,acc)
+  | Ppat_tuple pl ->
+      let (pl,acc) = map_accum (pattern_subst ~by_name) acc pl in
+      (Ppat_tuple pl,acc)
+  | Ppat_construct (_,None,_) as x -> (x,acc)
+  | Ppat_construct (lid,Some p,b) ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     (Ppat_construct (lid,Some p,b),acc)
+  | Ppat_variant (_,None) as x -> (x,acc)
+  | Ppat_variant (l,Some p) ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     (Ppat_variant (l,Some p),acc)
+  | Ppat_record (pl,cf) ->
+      let (pl,acc) = map_accum (fun acc (l,p) -> 
+          let (p,acc) = pattern_subst ~by_name acc p in ((l,p),acc)) acc pl in
+      (Ppat_record (pl,cf),acc)
+  | Ppat_array pl ->
+      let (pl,acc) = map_accum (pattern_subst ~by_name) acc pl in
+      (Ppat_array pl,acc)
+  | Ppat_or (p1,p2) ->
+     let (p1,acc') = pattern_subst ~by_name acc p1 in
+     let (p2,_)   = pattern_subst ~by_name:true acc p2 in
+     (Ppat_or (p1,p2), acc')
+  | Ppat_constraint (p,cty) ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     (Ppat_constraint (p,cty), acc)
+  | Ppat_type _ as x -> (x,acc)
+  | Ppat_lazy p ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     (Ppat_lazy p, acc)
+  | Ppat_unpack _ as x -> (x,acc)
+ in
+ ({pat with ppat_desc = desc}, acc)
+
+
+let pattern_subst_list :
+    string loc list -> Parsetree.pattern list -> 
+     Parsetree.pattern list * string loc list = fun acc pl ->
+ map_accum (pattern_subst ~by_name:false) acc pl
+
+
+(* Generalization of texp_binding_simple to the general binding pattern:
+   Convert the meta-level (fun vars pats exps -> body) to the 
+   Typedtree.expression
+   representing the same function, and use the result generate the call to
+   with_binding_region
+*)
+let texp_binding_pattern : 
+    (Typedtree.pattern * Typedtree.expression) list ->
+    Typedtree.expression -> (* the template for the result: the exp that fbody
+                               will construct, with correct
+                               exp_loc, exp_type slots; exp_desc will be
+                               replaced
+                             *)
+    (Typedtree.expression list -> Typedtree.expression -> 
+     Typedtree.expression list -> Typedtree.expression) ->
+  Typedtree.expression_desc = fun pel exp fbody ->
+  let (pl,idents) = trx_pel [] pel in
+  let idents = List.rev idents in (* idents ordered as pl *)
+  let pl_exp = texp_ident "Trx.sample_pat_list" in
+  let pats   = {pl_exp with
+                exp_desc = Texp_cspval (Obj.repr pl, dummy_lid "*pl*")} in
+  let rec loop acc = function
+    | [] -> fbody (List.rev acc) pats (List.map snd pel)
+    | idname::rest ->
+        {exp with exp_desc =
+         texp_binding_simple idname (fun gensymed_var ->
+           loop (gensymed_var::acc) rest)}
+  in (loop [] idents).exp_desc
+
+(* Build the general fun Parsetree *)
+let build_fun : 
+  Location.t -> string -> string loc array -> 
+  Parsetree.pattern list -> Parsetree.expression array ->
+  Parsetree.expression =
+  fun l label names pats ebodies -> 
+    let (ebodies,var) = map_accum remove_tstamp None (Array.to_list ebodies) in
+    let pats = 
+      if names = [||] then pats else
+      let (pats,acc) = pattern_subst_list (Array.to_list names) pats in
+      assert (acc = []); pats
+    in
+    add_timestamp var
+      {pexp_loc = l; 
+       pexp_desc = Pexp_function (label,None,
+                                  List.map2 (fun p e -> (p,e)) pats ebodies)}
+
+(* The second argument to build_match is the Parsetree representing
+   the expression to match. Since the expression is evaluated
+   outside the bindings, its timestamp should be earlier than those
+   corresponding to the expressions in the branch. 
+  TODO: implement this check. So far, we don't discriminate.
+*)
+let build_match : 
+  Location.t -> Parsetree.expression -> string loc array -> 
+  Parsetree.pattern list -> Parsetree.expression array ->
+  Parsetree.expression =
+  fun l exp names pats ebodies -> 
+    let (exp,var)     = remove_tstamp None exp in (* must be an earlier tstamp*)
+    let (ebodies,var) = map_accum remove_tstamp var (Array.to_list ebodies) in
+    let pats = 
+      if names = [||] then pats else
+      let (pats,acc) = pattern_subst_list (Array.to_list names) pats in
+      assert (acc = []); pats
+    in
+    add_timestamp var
+      {pexp_loc = l; 
+       pexp_desc = Pexp_match (exp, List.map2 (fun p e -> (p,e)) pats ebodies)}
+
+(* Essentially the same as build_match.
+   TODO: implement the same check on the timestamp of the expression to try
+*)
+let build_try : 
+  Location.t -> Parsetree.expression -> string loc array -> 
+  Parsetree.pattern list -> Parsetree.expression array ->
+  Parsetree.expression =
+  fun l exp names pats ebodies -> 
+    let (exp,var)     = remove_tstamp None exp in (* must be an earlier tstamp*)
+    let (ebodies,var) = map_accum remove_tstamp var (Array.to_list ebodies) in
+    let pats = 
+      if names = [||] then pats else
+      let (pats,acc) = pattern_subst_list (Array.to_list names) pats in
+      assert (acc = []); pats
+    in
+    add_timestamp var
+      {pexp_loc = l; 
+       pexp_desc = Pexp_try (exp, List.map2 (fun p e -> (p,e)) pats ebodies)}
+
+(* Build the general let-Parsetree (like the fun-Parsetree) *)
+let build_let : 
+  Location.t -> rec_flag -> string loc array -> 
+  Parsetree.pattern list -> 
+  Parsetree.expression array ->         (* the first is the body of let *)
+  Parsetree.expression =
+  fun l recf names pats ebodies -> 
+    let (ebodies,var) = map_accum remove_tstamp None (Array.to_list ebodies) in
+    let pats = 
+      if names = [||] then pats else
+      let (pats,acc) = pattern_subst_list (Array.to_list names) pats in
+      assert (acc = []); pats
+    in
+    match ebodies with
+     | (body::el) ->
+        add_timestamp var
+          {pexp_loc = l; 
+           pexp_desc = 
+             Pexp_let (recf,List.map2 (fun p e -> (p,e)) pats el,body)}
+     | _ -> assert false
+
+(* ------------------------------------------------------------------------ *)
+(* The main function to translate away brackets. It receives
+   an expression at the level n > 0.
+
+   Since bracket-translation is somewhat similar to un-typechecking,
+   see tools/untypeast.ml for hints on mapping Typedtree.expression
+   to Parsetree.expression.
+
+TODO: an optimization idea. Consider <assert e> as a typical expression.
+We translate it to the invocation of build_assert that will construct
+the Parsetree node at run-time. However, of 'e' is simple (e.g., a constant)
+then we can construct the Parsetree node at compile time and pass it
+as a CSP. There are no longer any functions calls to make at run-time.
+So, we can modify the translation of <assert e> below to detect
+if the translation of e produced Texp_cspval. We extract the CSP value,
+invoke build_assert (at compile time, when trx.ml is run) to build
+the Pexp_assert node, and wrap it as a CSP.
+
+*)
+
+(* Given a type [ty], return [ty code code ... code] (n times code).
+   When we push the bracket in, expressions that had type ty before
+   will have the type ('cl,ty) code.
+   Here, ('cl,ty) code is an abstract type whose concrete representation
+   is Parsetree.
+   Generally speaking we don't have to adjust the types since the
+   type checking is finished. However, code generator may look
+   at types; it's better if we don't lie. Thus, as trx_bracket
+   translates the expression, it should also adjust the types.
+*)
+
+let rec wrap_ty_in_code : int -> type_expr -> type_expr = fun n ty ->
+  if n=0 then ty else
+  let clsfier = Btype.newgenvar () in
+  wrap_ty_in_code (n-1) (Predef.type_code clsfier ty)
+
+let map_option : ('a -> 'b) -> 'a option -> 'b option = fun f -> function
+  | None   -> None
+  | Some x -> Some (f x)
+
+
+let rec trx_bracket : 
+  (expression -> expression) -> (* 0-level traversal *)
+  int -> (expression -> expression) = fun trx_exp n exp ->
+  let new_desc = match exp.exp_desc with
+    (* Don't just do when vd.val_kind = Val_reg 
+       because (+) or Array.get are Val_prim *)
+  | Texp_ident (p,li,vd)  ->
+    let stage = try Env.find_stage p exp.exp_env
+	        with Not_found ->
+                  if false then
+                    debug_print ("Stage for var is set to implicit 0:" ^ 
+	                         Path.name p ^ "\n");  [] in
+    (* We make CSP only if the variable is bound at the stage 0.
+       Variables bound at stage > 0 are subject to renaming.
+       They are translated into stage 0 variable but of a different
+       type (string loc), as explained in the title comments.
+     *)
+    if stage = [] then trx_csp exp p li 
+    else
+      texp_apply (texp_ident "Trx.build_ident")
+        [texp_loc exp.exp_loc; 
+         (* Future-stage bound variable becomes the present-stage
+            bound-variable, but at a different type
+          *)
+         match texp_ident "Trx.sample_name" with (* fill in the type, etc.*)
+         | {exp_desc = Texp_ident (_,_,vd); exp_type = ty}  ->
+           {exp with exp_desc = Texp_ident(p,li,vd); exp_type = ty}
+         | _ -> assert false]
+
+  | Texp_constant cst ->
+    let ast = 
+      {pexp_loc = exp.exp_loc;
+       pexp_desc = Pexp_constant cst}
+    in Texp_cspval (Obj.repr ast, dummy_lid "*cst*")
+
+     (* The most common case of let-expressions: let x = e in body *)
+  | Texp_let (recf,[({pat_desc = Tpat_var (id,name)},e)],body) ->
+      let recf_exp = texp_ident "Trx.sample_rec_flag" in
+      let recf_exp = {recf_exp with exp_desc = 
+                        Texp_cspval (Obj.repr recf, dummy_lid "*recf*")} in
+      texp_binding_simple (id,name) (fun gensymed_var ->
+        { exp with
+          exp_type = wrap_ty_in_code n exp.exp_type; (* lifted type *)
+          exp_desc = 
+            texp_apply (texp_ident "Trx.build_let_simple") 
+            [texp_loc exp.exp_loc;
+             recf_exp;
+             gensymed_var;
+             trx_bracket trx_exp n e;
+             trx_bracket trx_exp n body] })
+
+  | Texp_let (recf,pel,body) ->         (* General case. Like Texp_function *)
+      let recf_exp = texp_ident "Trx.sample_rec_flag" in
+      let recf_exp = {recf_exp with exp_desc = 
+                        Texp_cspval (Obj.repr recf, dummy_lid "*recf*")} in
+      let exp = { exp with exp_type = wrap_ty_in_code n exp.exp_type } in
+      texp_binding_pattern pel exp
+       (fun gensyms pats exps ->
+        { exp with
+          exp_desc = 
+            texp_apply (texp_ident "Trx.build_let") 
+            [texp_loc exp.exp_loc;
+             recf_exp;
+             texp_array gensyms;
+             pats;
+             texp_array (trx_bracket trx_exp n body::
+                         (List.map (trx_bracket trx_exp n) exps))]
+        })
+
+
+     (* The most common case of functions: fun x -> body *)
+  | Texp_function (l,[({pat_desc = Tpat_var (id,name)},ebody)],_) ->
+      texp_binding_simple (id,name) (fun gensymed_var ->
+        { exp with
+          exp_type = wrap_ty_in_code n exp.exp_type; (* lifted type *)
+          exp_desc = 
+            texp_apply (texp_ident "Trx.build_fun_simple") 
+            [texp_loc exp.exp_loc;
+             texp_string l;
+             gensymed_var;
+             trx_bracket trx_exp n ebody] })
+
+  | Texp_function (l,pel,_) ->
+      let exp = { exp with exp_type = wrap_ty_in_code n exp.exp_type } in
+      texp_binding_pattern pel exp
+       (fun gensyms pats exps ->
+        { exp with
+          exp_desc = 
+            texp_apply (texp_ident "Trx.build_fun") 
+            [texp_loc exp.exp_loc;
+             texp_string l;
+             texp_array gensyms;
+             pats;
+             texp_array (List.map (trx_bracket trx_exp n) exps)]
+        })
+
+  | Texp_apply (e, el) ->
+     (* first, we remove from el the information added by the type-checker *)
+     let lel = List.fold_right (function                 (* keep the order! *)
+                | (_,None,_)   -> fun acc -> acc
+                | (l,Some e,_) -> fun acc -> (l,e)::acc) el [] in
+     let lel = ("",e) :: lel in          (* Add the operator *)
+      texp_apply (texp_ident "Trx.build_apply")
+        [texp_loc exp.exp_loc; 
+         texp_array (List.map (fun (l,e) ->
+           texp_tuple [texp_string l;trx_bracket trx_exp n e]) lel)]
+
+  (* Pretty much like a function *)
+  (* Since e and pel don't share any bindings (the type-checker appropriately
+     renamed all variables into timestamped Ident), there is no
+     harm done if we evaluate 'e' within the scope of with_binding_region.
+     Weakening is admissible. Old MetaOCaml did something similar.
+     What about the scope extrusion check? build_match should make sure
+     the expression to match has an earlier tstamp.
+   *)
+  | Texp_match (e,pel,_) ->
+      let exp = { exp with exp_type = wrap_ty_in_code n exp.exp_type } in
+      texp_binding_pattern pel exp
+       (fun gensyms pats exps ->
+        { exp with
+          exp_desc = 
+            texp_apply (texp_ident "Trx.build_match") 
+            [texp_loc exp.exp_loc;
+             trx_bracket trx_exp n e;
+             texp_array gensyms;
+             pats;
+             texp_array (List.map (trx_bracket trx_exp n) exps)]
+        })
+
+  | Texp_try (e,pel) ->                 (* same as Texp_match *)
+      let exp = { exp with exp_type = wrap_ty_in_code n exp.exp_type } in
+      texp_binding_pattern pel exp
+       (fun gensyms pats exps ->
+        { exp with
+          exp_desc = 
+            texp_apply (texp_ident "Trx.build_try") 
+            [texp_loc exp.exp_loc;
+             trx_bracket trx_exp n e;
+             texp_array gensyms;
+             pats;
+             texp_array (List.map (trx_bracket trx_exp n) exps)]
+        })
+
+  | Texp_tuple el ->
+      texp_apply (texp_ident "Trx.build_tuple")
+        [texp_loc exp.exp_loc; 
+	 texp_array (List.map (trx_bracket trx_exp n) el)]
+
+  | Texp_construct (p, li, cdesc, args, explicit_arity) ->
+      let lid = qualify_ctor li.loc p cdesc in
+      texp_apply (texp_ident "Trx.build_construct")
+        [texp_loc exp.exp_loc; 
+         texp_lid lid;
+	 texp_array (List.map (trx_bracket trx_exp n) args);
+         texp_bool explicit_arity]
+
+  | Texp_variant (l,eo) ->              (* polymorphic variant *)
+      texp_apply (texp_ident "Trx.build_variant")
+        [texp_loc exp.exp_loc; 
+         texp_string l;
+	 texp_option (map_option (trx_bracket trx_exp n) eo)]
+
+  | Texp_record (lel,eo) ->
+      texp_apply (texp_ident "Trx.build_record")
+        [texp_loc exp.exp_loc; 
+         texp_array (List.map (fun (p,li,ldesc,e) ->
+           texp_tuple [texp_lid (qualify_label li.loc p ldesc);
+                       trx_bracket trx_exp n e]) lel);
+         texp_option (map_option (trx_bracket trx_exp n) eo)]
+
+  | Texp_field (e,p,li,ldesc) ->
+      texp_apply (texp_ident "Trx.build_field")
+        [texp_loc exp.exp_loc; 
+         trx_bracket trx_exp n e;
+         texp_lid (qualify_label li.loc p ldesc)]
+
+  | Texp_setfield (e1,p,li,ldesc,e2) ->
+      texp_apply (texp_ident "Trx.build_setfield")
+        [texp_loc exp.exp_loc; 
+         trx_bracket trx_exp n e1;
+         texp_lid (qualify_label li.loc p ldesc);
+         trx_bracket trx_exp n e2]
+
+  | Texp_array el ->
+      texp_apply (texp_ident "Trx.build_array")
+        [texp_loc exp.exp_loc; 
+	 texp_array (List.map (trx_bracket trx_exp n) el)]
+
+  | Texp_ifthenelse (e,et,efo) ->
+      texp_apply (texp_ident "Trx.build_ifthenelse")
+        [texp_loc exp.exp_loc; 
+         trx_bracket trx_exp n e;
+         trx_bracket trx_exp n et;
+	 texp_option (map_option (trx_bracket trx_exp n) efo)]
+
+  | Texp_sequence (e1,e2) ->
+      texp_apply (texp_ident "Trx.build_sequence")
+        [texp_loc exp.exp_loc; 
+	 trx_bracket trx_exp n e1; trx_bracket trx_exp n e2]
+  | Texp_while (e1,e2) ->
+      texp_apply (texp_ident "Trx.build_while")
+        [texp_loc exp.exp_loc; 
+	 trx_bracket trx_exp n e1; trx_bracket trx_exp n e2]
+
+  | Texp_for (id, name, elo, ehi, dir, ebody) ->
+      texp_binding_simple (id,name) (fun gensymed_var ->
+        { exp with
+          exp_type = wrap_ty_in_code n exp.exp_type; (* lifted type of for *)
+          exp_desc = 
+            texp_apply (texp_ident "Trx.build_for") 
+            [texp_loc exp.exp_loc;
+             gensymed_var;
+             trx_bracket trx_exp n elo;
+             trx_bracket trx_exp n ehi;
+             texp_bool (dir = Upto);
+             trx_bracket trx_exp n ebody] })
+
+
+  | Texp_when (e1,e2) ->
+      texp_apply (texp_ident "Trx.build_when")
+        [texp_loc exp.exp_loc; 
+	 trx_bracket trx_exp n e1; trx_bracket trx_exp n e2]
+
+  | Texp_send (e,m,_) ->
+      (* We don't check the persistence of the method: after all,
+         a method name is somewhat like a polymorphic variant.
+         It's perfectly OK to have a function fun x -> x # foo
+      *)
+      texp_apply (texp_ident "Trx.build_send")
+        [texp_loc exp.exp_loc; 
+	 trx_bracket trx_exp n e;
+         texp_string (match m with
+                        | Tmeth_name name -> name
+                        | Tmeth_val id -> Ident.name id)]
+
+  | Texp_new (p,li,_) ->
+    check_path_quotable "Class" p;
+    let ast = 
+      {pexp_loc = exp.exp_loc;
+       pexp_desc = Pexp_new (Location.mkloc (path_to_lid p) li.loc)}
+    in Texp_cspval (Obj.repr ast, dummy_lid "*new*")
+
+  | Texp_instvar (p1,p2,s) ->
+     not_supported exp.exp_loc "Objects (Texp_instvar)"
+        (* Alternatively: since instance variables are always bound 
+           at level 0 (for now)
+           so this is like a csp variable 
+        call_trx_mkcsp exp None (path_to_lid p2)
+        *)
+  | Texp_setinstvar _ -> not_supported exp.exp_loc "Objects (Texp_setinstvar)"
+  | Texp_override  _  -> not_supported exp.exp_loc "Objects (Texp_override)"
+  | Texp_letmodule (id,s,me,e) -> not_supported exp.exp_loc "let module"
+
+  | Texp_assert e ->
+      texp_apply (texp_ident "Trx.build_assert")
+        [texp_loc exp.exp_loc; trx_bracket trx_exp n e]
+  | Texp_assertfalse ->
+    let ast = 
+      {pexp_loc = exp.exp_loc;
+       pexp_desc = Pexp_assertfalse}
+    in Texp_cspval (Obj.repr ast, dummy_lid "*af*")
+
+  | Texp_lazy e ->
+      texp_apply (texp_ident "Trx.build_lazy")
+        [texp_loc exp.exp_loc; trx_bracket trx_exp n e]
+
+  | Texp_object (cl,fl) -> not_supported exp.exp_loc "Objects"
+  | Texp_pack _         -> not_supported exp.exp_loc "First-class modules"
+
+  | Texp_bracket e ->
+      texp_apply (texp_ident "Trx.build_bracket")
+        [texp_loc exp.exp_loc; trx_bracket trx_exp (n+1) e]
+  | Texp_escape e ->
+      if n = 1 then (trx_exp e).exp_desc	(* switch to 0 level *)
+      else
+      texp_apply (texp_ident "Trx.build_escape")
+        [texp_loc exp.exp_loc; trx_bracket trx_exp (n-1) e]
+  | Texp_run e ->
+      texp_apply (texp_ident "Trx.build_run")
+        [texp_loc exp.exp_loc; trx_bracket trx_exp n e]
+  | Texp_cspval (v,li) ->               (* CSP is a sort of a constant *)
+    let ast = 
+      {pexp_loc = exp.exp_loc;
+       pexp_desc = Pexp_cspval(v,li)}
+    in Texp_cspval (Obj.repr ast, dummy_lid "*csp*")
+
+  in                               
+  let trx_extra (extra, loc) exp = (* See untype_extra in tools/untypeast.ml *)
+   let desc =
+    match extra with
+      (* Should check that cty1 and cty2 contain only globally declared
+         type components
+       *)
+    | Texp_constraint (cty1, cty2) -> 
+        not_supported loc "Texp_constraint"
+
+    | Texp_open (path, lid, _) -> 
+       check_path_quotable "Texp_open" path;
+       texp_apply (texp_ident "Trx.build_open")
+        [texp_loc exp.exp_loc; 
+         texp_lid (mkloc (path_to_lid path) lid.loc);
+         exp]      (* exp is the result of trx_bracket *)
+
+    | Texp_poly cto  -> not_supported loc "Texp_poly"
+    | Texp_newtype s -> not_supported loc "Texp_newtype"
+    in {exp with exp_loc = loc; exp_desc = desc} (* type is the same: code *)
+  in
+  List.fold_right trx_extra exp.exp_extra
+  {exp with exp_type = wrap_ty_in_code n exp.exp_type;
+            exp_desc = new_desc}
+
+
+(* ------------------------------------------------------------------------ *)
+(* Typedtree traversal to eliminate bracket/escapes *)
+
+(* Functions to help traverse and transform a tree.
+   We assume that every tree mapping function of the type 'a -> 'a
+   throws the exception Not_modified if the tree has not been
+   modified.
+   This protocol helps minimize garbage and prevent useless tree
+   duplication.
+*)
+
+exception Not_modified
+
+let replace_list : ('a -> 'a) -> 'a list -> 'a list = fun f l ->
+  let rec loop mdf = function
+  | [] -> if mdf then [] else raise Not_modified
+  | h::t -> match (try Some (f h) with Not_modified -> None) with
+             | Some h -> h :: loop true t
+             | None   -> h :: loop mdf  t
+  in loop false l
+
+let replace_pair : ('a -> 'a) -> ('b -> 'b) -> 'a * 'b -> 'a * 'b =
+  fun f g (x,y) ->
+  match ((try Some (f x) with Not_modified -> None),
+         (try Some (g y) with Not_modified -> None)) with
+  | (None,None)      -> raise Not_modified
+  | (Some x, None)   -> (x,y)
+  | (None, Some y)   -> (x,y)
+  | (Some x, Some y) -> (x,y)
+
+let replace_opt : ('a -> 'a) -> 'a option -> 'a option = fun f -> function
+  | Some e -> Some (f e)
+  | None   -> raise Not_modified
+
+(* The main function to scan the typed tree at the 0 level and
+   detect brackets 
+*)
+
+let rec trx_struct str =
+  {str with str_items = 
+  replace_list (fun si -> {si with str_desc = trx_struct_item si.str_desc})
+           str.str_items}
+
+and trx_struct_item = function
+| Tstr_eval e -> Tstr_eval (trx_exp e)
+| Tstr_value (rf,pel) ->
+    Tstr_value(rf, replace_list (fun (p,e) -> (p, trx_exp e)) pel)
+| Tstr_primitive (_,_,_) 
+| Tstr_type _
+| Tstr_exception (_,_,_)
+| Tstr_exn_rebind (_,_,_,_) -> raise Not_modified
+| Tstr_module (i,l,me) -> Tstr_module (i, l, trx_me me)
+| Tstr_recmodule l ->
+  Tstr_recmodule (replace_list (fun (i,l,mt,me) -> (i,l,mt,trx_me me)) l)
+| Tstr_modtype (_,_,_)
+| Tstr_open (_,_) -> raise Not_modified
+| Tstr_class l ->
+    Tstr_class (replace_list (fun (dcl,sl,vf) -> (trx_cdcl dcl,sl,vf)) l)
+| Tstr_class_type _ -> raise Not_modified
+| Tstr_include (me,il) -> Tstr_include (trx_me me, il)
+
+and trx_me me = 
+  {me with mod_desc = trx_me_desc me.mod_desc} 
+
+and trx_me_desc = function
+| Tmod_ident _ -> raise Not_modified
+| Tmod_structure str -> Tmod_structure (trx_struct str)
+| Tmod_functor (i,l,t,me) -> Tmod_functor (i,l,t, trx_me me)
+| Tmod_apply (me1,me2,mc) ->
+  let (me1,me2) = replace_pair trx_me trx_me (me1,me2) in
+  Tmod_apply (me1, me2, mc)
+| Tmod_constraint (me,mt,mtc,mc) -> Tmod_constraint (trx_me me, mt, mtc, mc)
+| Tmod_unpack (e,mt) -> Tmod_unpack (trx_exp e,mt)
+
+and trx_cdcl class_decl =
+  {class_decl with ci_expr = trx_ce class_decl.ci_expr}
+
+and trx_ce class_expr =
+  {class_expr with cl_desc = trx_ce_desc class_expr.cl_desc}
+
+and trx_cl_struct cs =
+  {cs with cstr_fields = 
+     replace_list (fun cf -> {cf with cf_desc = trx_cf cf.cf_desc})
+                  cs.cstr_fields}
+
+and trx_ce_desc = function
+| Tcl_ident (_,_,_) -> raise Not_modified
+| Tcl_structure cs ->
+  Tcl_structure (trx_cl_struct cs)
+| Tcl_fun (l,p,el,ce,pa) ->
+  let (el,ce) = 
+        replace_pair (replace_list (fun (i,l,e) -> (i,l,trx_exp e)))
+                     trx_ce (el,ce) in
+  Tcl_fun (l,p,el,ce,pa)
+| Tcl_apply (ce,el) ->
+  let repel (l,eo,o) = (l,replace_opt trx_exp eo,o) in
+  let (ce,el) = replace_pair trx_ce (replace_list repel) (ce,el) in
+  Tcl_apply (ce,el)
+| Tcl_let (rf,el1,el2,ce) ->
+  let repel1 = replace_list (fun (p,e) -> (p,trx_exp e)) in
+  let repel2 = replace_list (fun (i,l,e) -> (i,l,trx_exp e)) in
+  let ((el1,el2),ce) = replace_pair (replace_pair repel1 repel2) trx_ce
+                        ((el1,el2),ce)
+  in Tcl_let (rf,el1,el2,ce)
+| Tcl_constraint (ce,ct,sl1,sl2,cty) ->
+  Tcl_constraint (trx_ce ce,ct,sl1,sl2,cty)
+
+and trx_cf = function
+| Tcf_inher (ofl,ce,so,sl1,sl2) ->
+  Tcf_inher (ofl,trx_ce ce,so,sl1,sl2)
+| Tcf_val (_,_,_,_,Tcfk_virtual _,_) -> raise Not_modified
+| Tcf_val (s,l,mf,i,Tcfk_concrete e,b) ->
+  Tcf_val (s,l,mf,i,Tcfk_concrete (trx_exp e),b)
+| Tcf_meth (s,l,pf,Tcfk_virtual _,_) -> raise Not_modified
+| Tcf_meth (s,l,pf,Tcfk_concrete e,b) ->
+  Tcf_meth (s,l,pf,Tcfk_concrete (trx_exp e),b)
+| Tcf_constr (_,_) -> raise Not_modified
+| Tcf_init e -> Tcf_init (trx_exp e)
+
+and trx_exp exp =
+  {exp with exp_desc = trx_expression exp.exp_desc}
+
+and trx_pelist l = replace_list (fun (p,e) -> (p,trx_exp e)) l
+and trx_expression = function
+| Texp_ident (_,_,_)
+| Texp_constant _ -> raise Not_modified
+| Texp_let (rf, el, e) ->
+  let (el,e) = replace_pair trx_pelist trx_exp (el,e)
+  in Texp_let (rf, el, e)
+| Texp_function (l,el,p) ->
+  Texp_function (l,trx_pelist el,p)
+| Texp_apply (e,el) ->
+  let repl (l,eo,op) = (l,replace_opt trx_exp eo,op) in
+  let (e,el) = replace_pair trx_exp (replace_list repl) (e,el)
+  in Texp_apply (e,el)
+| Texp_match (e,el,p) ->
+  let (e,el) = replace_pair trx_exp trx_pelist (e,el)
+  in Texp_match (e,el,p)
+| Texp_try (e,el) ->
+  let (e,el) = replace_pair trx_exp trx_pelist (e,el)
+  in Texp_try (e,el)
+| Texp_tuple l -> Texp_tuple (replace_list trx_exp l)
+| Texp_construct (p,l,cd,el,b) ->
+  Texp_construct (p,l,cd,replace_list trx_exp el,b)
+| Texp_variant (l,eo) -> Texp_variant (l,replace_opt trx_exp eo)
+| Texp_record (ll,eo) ->
+  let repll (p,l,ld,e) = (p,l,ld,trx_exp e) in
+  let (ll,eo) = replace_pair (replace_list repll) (replace_opt trx_exp) (ll,eo)
+  in Texp_record (ll,eo)
+| Texp_field (e,p,l,ld) -> Texp_field (trx_exp e,p,l,ld)
+| Texp_setfield (e1,p,l,ld,e2) ->
+  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
+  in Texp_setfield (e1,p,l,ld,e2)
+| Texp_array el -> Texp_array (replace_list trx_exp el)
+| Texp_ifthenelse (e1,e2,eo) ->
+  let ((e1,e2),eo) = replace_pair (replace_pair trx_exp trx_exp) 
+                                  (replace_opt trx_exp) ((e1,e2),eo)
+  in Texp_ifthenelse (e1,e2,eo)
+| Texp_sequence (e1,e2) -> 
+  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
+  in Texp_sequence (e1,e2)
+| Texp_while (e1,e2) ->
+  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
+  in Texp_while (e1,e2)
+| Texp_for (i,l,e1,e2,df,e3) ->
+  let ((e1,e2),e3) = replace_pair (replace_pair trx_exp trx_exp) 
+                                  trx_exp ((e1,e2),e3)
+  in Texp_for (i,l,e1,e2,df,e3)
+| Texp_when (e1,e2) ->
+  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
+  in Texp_when (e1,e2)
+| Texp_send (e1,m,eo) ->
+  let (e1,eo) = replace_pair trx_exp (replace_opt trx_exp) (e1,eo)
+  in Texp_send (e1,m,eo)
+| Texp_new (_,_,_)
+| Texp_instvar (_,_,_) -> raise Not_modified
+| Texp_setinstvar (p1,p2,l,e) -> Texp_setinstvar (p1,p2,l,trx_exp e)
+| Texp_override (p, el) ->
+  Texp_override (p, replace_list (fun (p,l,e) -> (p,l,trx_exp e)) el)
+| Texp_letmodule (i,l,me,e) ->
+  let (me,e) = replace_pair trx_me trx_exp (me,e)
+  in Texp_letmodule (i,l,me,e)
+| Texp_assert e -> Texp_assert (trx_exp e)
+| Texp_assertfalse -> raise Not_modified
+| Texp_lazy e -> Texp_lazy (trx_exp e)
+| Texp_object (cs,sl) -> Texp_object (trx_cl_struct cs,sl)
+| Texp_pack me -> Texp_pack (trx_me me)
+
+| Texp_bracket e -> 
+   let trx_exp e = try trx_exp e with Not_modified -> e in
+  (trx_bracket trx_exp 1 e).exp_desc
+
+| Texp_escape _ -> assert false         (* Not possible in well-typed code *)
+| Texp_run e -> 
+    let trx_exp e = try trx_exp e with Not_modified -> e in
+    texp_apply (texp_ident "Runcode.run'") [trx_exp e]
+| Texp_cspval (_,_) -> raise Not_modified
+
+
+(* public interface *)
+let trx_structure str = 
+  try trx_struct str with Not_modified -> str
+
+  
+(* Obsolete: we never quite handled modules within the code
+
+and quote_me n exp me = match me.mod_desc with
+| Tmod_structure str -> (* @@@@ *)
+    mkParseModuleExpr exp
+      (Texp_construct(Lazy.force constr_pmod_structure,
+                           [quote_structure n exp str]))
+| _ -> fatal_error "Trx.quote_me: case not implemented yet"
+
+and quote_structure n exp str =
+  mkPexpList exp (List.map (quote_structure_item n exp) str)
+
+and quote_structure_item n exp si = match si with
+| Tstr_value (rf,pel) ->  (* similar to texp_let *)
+    begin
+      match rf with
+        Recursive ->
+          let idlist = List.fold_right (fun (p,e) -> boundinpattern p) pel []
+          and gensymexp id =  (* (gensym "x") *)
+            mkExp exp
+              type_longident_t
+              (Texp_apply
+                 (trx_gensymlongident exp,
+                  [(Some (quote_ident exp (Path.Pident id)),
+                    Required)]))
+          and idpat id =
+            {pat_desc = Tpat_var id;
+             pat_loc = exp.exp_loc;
+             pat_type = Lazy.force type_longident_t;
+             pat_env = exp.exp_env}
+          and translet =
+            mkParseStructureItem exp
+              (Texp_construct
+                 (Lazy.force constr_pstr_value, 
+                  [quote_rec_flag rf exp;
+                   mkPexpList exp 
+                     (mkNewPEL exp
+                        (List.map (map_pi2 (trx_e n)) pel))
+                 ]
+                 )
+              )
+          in let pel' = List.map (fun id -> (idpat id, gensymexp id)) idlist
+          in mkExp exp
+            type_parsetree_expression
+            (Texp_let
+               (Nonrecursive,
+                pel', 
+                translet))
+      | _ ->
+          let idlist = List.fold_right (fun (p,e) -> boundinpattern p) pel []
+          and peil = let genid () = Ident.create (gensymstring "fresh")
+          in List.map (fun (p,e) -> (p,e, genid())) pel
+          and gensymexp id =  (* (gensym "x") *)
+            mkExp exp
+              type_longident_t
+              (Texp_apply
+                 (trx_gensymlongident exp,
+                  [(Some (quote_ident exp (Path.Pident id)),
+                    Required)]))
+          in let idpat_t id t =
+            {pat_desc = Tpat_var id;
+             pat_loc = exp.exp_loc;
+             pat_type = Lazy.force t;
+             pat_env = exp.exp_env}
+          in let idpat id = idpat_t id type_longident_t
+          in let idexp e id =
+            {e with exp_desc =
+             (Texp_ident (Path.Pident id,
+                          {val_type = e.exp_type;
+                           val_kind = Val_reg}))}
+          in let pel' = List.map (fun (p,e,i) -> (p, idexp e i)) peil
+          in let translet =
+            mkParseStructureItem exp
+              (Texp_construct
+                 (Lazy.force constr_pstr_value, 
+                  [quote_rec_flag rf exp;
+                   mkPexpList exp (mkNewPEL exp pel')
+                 ]
+                 )
+              )
+          in let pel1 = List.map (fun id -> (idpat id, gensymexp id)) idlist
+          in let pel2 = List.map
+              (fun (p,e,i) -> (idpat_t i type_parsetree_expression,
+                               trx_e n e))
+              peil
+          in mkExp exp
+            type_parsetree_expression
+            (Texp_let
+               (Nonrecursive,
+                List.append pel1 pel2, 
+                translet))
+    end
+| _ -> fatal_error "Trx.quote_structure_item: case not implemented yet"
+
+let mkParseModuleExpr exp d =
+  mkExp exp
+    type_parsetree_module_expr
+    (Texp_record([Lazy.force label_pmod_desc,
+                  mkExp exp type_parsetree_module_expr_desc d;
+                  Lazy.force label_pmod_loc, quote_location exp],
+                 None))
+
+let mkParseStructureItem exp d =
+  mkExp exp
+    type_parsetree_structure_item
+    (Texp_record([Lazy.force label_pstr_desc,
+                  mkExp exp type_parsetree_structure_item_desc d;
+                  Lazy.force label_pstr_loc, quote_location exp],
+                 None))
+
+let label_pstr_desc = lazy (find_label "Parsetree.pstr_desc")
+*)
+
+(* Native mode is moved out to the `userland'
+
+let native_mode = ref false (* ZZZ
+  Should be a better way to detect native mode,
+  e.g., by the presence of some modules in asmcomp *)
+
+let remove_texp_cspval exp =
+  if !native_mode = false then exp else
+  failwith "native mode CSP are not impemented yet"
+
+   XXX old code
+  match exp.exp_desc with
+  | Texp_cspval (v,l) ->
+      let i = add_csp_value (v,l) in
+      let exp' = {exp with exp_desc = Texp_constant (Const_int i)} in
+      let desc = if !initial_native_compilation
+        then (Texp_apply (trx_array_get exp, [(Some !local_csp_arr_texp, Required);(Some exp', Required)]))
+	else (Texp_apply (trx_get_csp_value exp, [(Some exp', Required)])) in
+      {exp with exp_desc = desc}
+  | _ -> assert false
+
+let trx_execute_expression exp =
+  let (p, v) = Lazy.force pathval_trx_execute_expression in
+  { exp with exp_type = instance v.val_type;
+    exp_desc = Texp_ident(p, v) }
+*)
diff -N -u -r ocaml-4.00.1.orig/typing/trx.mli ocaml-4.00.1/typing/trx.mli
--- ocaml-4.00.1.orig/typing/trx.mli	1970-01-01 01:00:00.000000000 +0100
+++ ocaml-4.00.1/typing/trx.mli	2013-01-30 03:56:55.000000000 +0100
@@ -0,0 +1,119 @@
+(* BER MetaOCaml compilation
+   Transforming the Typedtree to eliminate brackets, escapes and
+   run, replacing them with calls to ordinary OCaml functions
+   to build the code representation (that is, Parsetree).
+*)
+
+val meta_version : string
+(** [meta_version] is the version of BER MetaOCaml*)
+
+(* The function to post-process the typed tree and translate away
+   brackets and escapes 
+*)
+val trx_structure: Typedtree.structure -> Typedtree.structure
+
+(* Call it whenever we run or print the code *)
+val check_scope_extrusion : Parsetree.expression -> Parsetree.expression
+
+(* The following names are used by Trx itself to construct a Parsetree
+   or as templates to build the Typedtree.
+   Trx may generate code the refers to the functions below.
+   Therefore, do NOT rename the functions or change their types!
+*)
+
+val sample_lid  : Longident.t Location.loc  (* A template for lid expressions *)
+val sample_loc  : Location.t
+val sample_name : string Location.loc
+val sample_pat_list : Parsetree.pattern list
+val sample_rec_flag : Asttypes.rec_flag
+
+        (* Run-time quotator *)
+val dyn_quote  : Obj.t -> Longident.t Location.loc -> Parsetree.expression
+
+val lift_constant_int  : int  -> Parsetree.expression
+val lift_constant_char : char -> Parsetree.expression
+val lift_constant_bool : bool -> Parsetree.expression
+
+(* Builders of the Parsetree *)
+val build_assert  : Location.t -> Parsetree.expression -> Parsetree.expression
+val build_lazy    : Location.t -> Parsetree.expression -> Parsetree.expression
+val build_bracket : Location.t -> Parsetree.expression -> Parsetree.expression
+val build_escape  : Location.t -> Parsetree.expression -> Parsetree.expression
+val build_run     : Location.t -> Parsetree.expression -> Parsetree.expression
+
+val build_sequence : 
+  Location.t -> Parsetree.expression -> Parsetree.expression -> 
+  Parsetree.expression
+val build_while : 
+  Location.t -> Parsetree.expression -> Parsetree.expression -> 
+  Parsetree.expression
+val build_when : 
+  Location.t -> Parsetree.expression -> Parsetree.expression -> 
+  Parsetree.expression
+
+val build_apply : Location.t -> 
+                    (Asttypes.label * Parsetree.expression) array -> 
+                    Parsetree.expression
+
+val build_tuple : 
+  Location.t -> Parsetree.expression array -> Parsetree.expression
+val build_array : 
+  Location.t -> Parsetree.expression array -> Parsetree.expression
+val build_ifthenelse : 
+  Location.t -> 
+  Parsetree.expression -> Parsetree.expression -> Parsetree.expression option ->
+  Parsetree.expression
+val build_construct :
+ Location.t -> Longident.t Location.loc -> Parsetree.expression array -> bool ->
+ Parsetree.expression
+val build_record :
+ Location.t -> (Longident.t Location.loc * Parsetree.expression) array ->
+ Parsetree.expression option -> Parsetree.expression
+val build_field :
+ Location.t -> Parsetree.expression -> Longident.t Location.loc -> 
+ Parsetree.expression
+val build_setfield :
+ Location.t -> Parsetree.expression -> Longident.t Location.loc -> 
+   Parsetree.expression -> Parsetree.expression
+val build_variant :
+ Location.t -> string -> Parsetree.expression option -> Parsetree.expression
+val build_send :
+ Location.t -> Parsetree.expression -> string -> Parsetree.expression
+val build_open :
+ Location.t -> Longident.t Location.loc -> Parsetree.expression -> 
+ Parsetree.expression
+
+val build_ident : Location.t -> string Location.loc -> Parsetree.expression
+val with_binding_region : 
+    string Location.loc -> (string Location.loc -> Parsetree.expression) -> 
+    Parsetree.expression
+val build_for : 
+  Location.t -> string Location.loc -> 
+  Parsetree.expression -> Parsetree.expression -> 
+  bool -> Parsetree.expression -> Parsetree.expression
+
+val build_fun_simple : 
+  Location.t -> string -> string Location.loc -> Parsetree.expression -> 
+  Parsetree.expression
+val build_fun : 
+  Location.t -> string -> string Location.loc array -> 
+  Parsetree.pattern list -> Parsetree.expression array ->
+  Parsetree.expression
+
+val build_match : 
+  Location.t -> Parsetree.expression -> string Location.loc array -> 
+  Parsetree.pattern list -> Parsetree.expression array ->
+  Parsetree.expression
+val build_try : 
+  Location.t -> Parsetree.expression -> string Location.loc array -> 
+  Parsetree.pattern list -> Parsetree.expression array ->
+  Parsetree.expression
+
+val build_let_simple : 
+  Location.t -> Asttypes.rec_flag -> string Location.loc -> 
+  Parsetree.expression -> Parsetree.expression -> Parsetree.expression
+val build_let : 
+  Location.t -> Asttypes.rec_flag -> string Location.loc array -> 
+  Parsetree.pattern list -> 
+  Parsetree.expression array ->         (* the first is the body of let *)
+  Parsetree.expression
diff -N -u -r ocaml-4.00.1.orig/typing/typecore.ml ocaml-4.00.1/typing/typecore.ml
--- ocaml-4.00.1.orig/typing/typecore.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/typing/typecore.ml	2013-02-20 17:25:22.000000000 +0100
@@ -61,6 +61,10 @@
   | Not_a_packed_module of type_expr
   | Recursive_local_constraint of (type_expr * type_expr) list
   | Unexpected_existential
+  | Wrong_stage of (type_expr list) * (type_expr list)    (* NNN *)
+  | Run_occur_check of type_expr * type_expr		  (* NNN *)
+  | Run_alpha_not_generalizable of type_expr * type_expr  (* NNN *)
+  | Trx_error of (Format.formatter -> unit)               (* NNN *)
 
 exception Error of Location.t * error
 
@@ -86,6 +90,60 @@
        Env.t -> Location.t -> Parsetree.class_structure ->
          Typedtree.class_structure * Types.class_signature * string list)
 
+(* NNN: begin
+  The list of active classifiers. The length of the list
+  is the level of an expression.
+  Type-checking the body of a bracket adds a type variable
+  to the list; type-checking of an escape removes the
+  top-most classifier.
+  Be sure to reset this list upon any exception;
+  alternatively; reset the list when beginning a new type-level
+  expression or binding
+  (whenever you do Typetexp.reset_type_variables();)
+*)
+let global_stage : Env.stage ref  = ref []
+
+(* Unify classifier lists, *right-to-left*
+   See the bug Tue Jan 20 12:18:00 GMTST 2004 in XXCC-BUG-OPEN-FIXED
+   why we need this order.
+   The current classifier is left-most, and the lists don't have
+   to have the same length.
+   Example:
+   .<fun x -> .< x >. >.
+   When type-checking the innermost bracket, the global_stage
+   will contain ['b,'a] and the level of x will be ['a]
+   The unification will succeed, without changing anything, as expected.
+*)
+
+let unify_stage env tl1 tl2 =
+   let rec loop = function
+   | (t1::tl1,t2::tl2) -> unify env t1 t2; loop (tl1,tl2)
+   | _ -> ()
+   in loop (List.rev tl1, List.rev tl2)
+
+let with_stage_up ty body =
+   let old_stage = !global_stage in
+   let () = global_stage := ty::!global_stage in
+   try 
+    let r = body () in
+    global_stage := old_stage; r
+   with e ->
+   global_stage := old_stage; raise e
+
+let with_stage_down loc body =
+   let old_stage = !global_stage in
+   let ty = 
+     match !global_stage with
+     | (ty::tl) -> global_stage := tl; ty
+     | [] -> raise (Error (loc, Wrong_stage (!global_stage,[])))
+   in
+   try 
+    let r = body ty in
+    global_stage := old_stage; r
+   with e ->
+   global_stage := old_stage; raise e
+(* NNN end *)
+
 (*
   Saving and outputting type information.
   We keep these function names short, because they have to be
@@ -149,6 +207,8 @@
     | Pexp_letmodule (_, me, e) -> expr e; module_expr me
     | Pexp_object { pcstr_fields = fs } -> List.iter class_field fs
     | Pexp_pack me -> module_expr me
+    | Pexp_bracket e | Pexp_escape e | Pexp_run e -> expr e (* NNN *)
+    | Pexp_cspval (_, _) -> ()                              (* NNN *)
 
   and module_expr me =
     match me.pmod_desc with
@@ -890,6 +950,7 @@
        let check = if as_var then check_as else check in
        let e1 = Env.add_value ?check id
            {val_type = ty; val_kind = Val_reg; Types.val_loc = loc} env in
+       let e1 = Env.add_stage id !global_stage e1 in  (* NNN *)
        Env.add_annot id (Annot.Iref_internal loc) e1)
     pv env,
    get_ref module_variables)
@@ -929,6 +990,9 @@
            else Warnings.Unused_var_strict s in
          let id' = Ident.create (Ident.name id) in
          ((id', name, id, ty)::pv,
+	  (* NNN we don't do Env.add_stage id' [] 
+	     since we don't handle classes within brackets.
+	   *)
           Env.add_value id' {val_type = ty;
                              val_kind = Val_ivar (Immutable, cl_num);
                              Types.val_loc = loc;
@@ -956,6 +1020,10 @@
   pattern_variables := [];
   let (val_env, met_env, par_env) =
     List.fold_right
+	  (* NNN we don't do Env.add_stage id [] for all
+	     Env.add_value below
+	     since we don't handle classes within brackets.
+	   *)
       (fun (id, ty, name, loc, as_var) (val_env, met_env, par_env) ->
          (Env.add_value id {val_type = ty;
                             val_kind = Val_unbound;
@@ -1039,6 +1107,9 @@
       is_nonexpansive_mod mexp && is_nonexpansive e
   | Texp_pack mexp ->
       is_nonexpansive_mod mexp
+  | Texp_bracket e -> is_nonexpansive e     (* NNN *)
+  | Texp_escape e -> is_nonexpansive e      (* NNN *)
+  | Texp_run e -> is_nonexpansive e         (* NNN *)
   | _ -> false
 
 and is_nonexpansive_mod mexp =
@@ -1497,6 +1568,11 @@
           with _ -> ()
         end;
         let (path, desc) = Typetexp.find_value env loc lid.txt in
+        let stage =				(* NNN begin *)
+              try snd (Env.lookup_stage lid.txt env)
+              with Not_found ->
+                [] in
+	unify_stage env stage !global_stage;		(* NNN end *)
         rue {
           exp_desc =
             begin match desc.val_kind with
@@ -1516,9 +1592,14 @@
             | Val_unbound ->
                 raise(Error(loc, Masked_instance_variable lid.txt))
             | _ ->
+              if (List.length stage) > (List.length !global_stage) (* NNN *)
+                 then raise (Error (loc,                           (* NNN *)
+                              Wrong_stage (stage, !global_stage))) (* NNN *)
+	         else                                              (* NNN *)
                 Texp_ident(path, lid, desc)
           end;
           exp_loc = loc; exp_extra = [];
+(* NNN:  Instantiates type scheme to a type *)
           exp_type = instance env desc.val_type;
           exp_env = env }
       end
@@ -1678,6 +1759,74 @@
         exp_loc = loc; exp_extra = [];
         exp_type = ty_res;
         exp_env = env }
+
+       (* NNN:  Typechecking bracket *)
+       (* follow Pexp_array or Pexp_lazy as a template *)
+       (* Expected type: (clsfier,ty) code where ty is the type
+           of the expression within brackets.
+        *)
+  | Pexp_bracket(sexp) ->   
+      let clsfier = newvar ?name:(Some "cl") () in   (* it will be generalized later *)
+      let ty = newgenvar() in
+      let to_unify = Predef.type_code clsfier ty in
+      unify_exp_types loc env to_unify ty_expected;
+      with_stage_up clsfier (fun () ->
+      let exp = type_expect env sexp ty in
+        re { 
+          exp_desc = Texp_bracket(exp);
+          exp_loc = loc; exp_extra = [];
+          exp_type = instance env ty_expected;
+          exp_env = env })
+       (* NNN:  Typechecking escapes *)
+       (* If ~e is expected to have the type ty then
+          e is expected to have the type (clsfier,ty) code
+        *)
+  | Pexp_escape(sexp) ->    
+      with_stage_down loc (fun clsfier ->
+       let sexp_ty_expected = Predef.type_code clsfier ty_expected in
+       let exp = type_expect env sexp sexp_ty_expected in
+       re { 
+         exp_desc = Texp_escape(exp);
+         exp_loc = loc; exp_extra = [];
+         exp_type = instance env ty_expected;
+         exp_env = env })
+       (* NNN Typechecking for Run *)
+       (* If .! e is expected to have the type ty, then
+          e is expected to have the type (clsfier,ty) code
+          where clsfier should be generalizable.
+        *)
+  | Pexp_run(sexp) ->
+      begin_def();    (* save level and increment, for generalization *)
+      let clsfier = newvar ?name:(Some "cl") () in
+      let codety  = Predef.type_code clsfier ty_expected in
+      let exp = type_expect env sexp codety in
+      end_def ();
+      if deep_occur clsfier ty_expected then
+          raise (Error (loc, Run_occur_check (clsfier,codety) ));
+      generalize clsfier;
+      if clsfier.level <> generic_level then
+          raise (Error (loc, Run_alpha_not_generalizable (clsfier,codety) ));
+      re { 
+        exp_desc = Texp_run(exp);
+        exp_loc = loc; exp_extra = [];
+        exp_type = instance env ty_expected;
+        exp_env = env }
+       (* NNN Typechecking for CSPVAL. *)
+       (* The rule says that CSP can have any desired type.
+          Pexp_cspval nodes are added only by the builder of
+          code expressions, by the builder of AST in trx.ml
+         At that time we know that the expression that gave
+         rise to CSP had the correct type. Therefore, we trust
+         that the type was correct the first time around.
+         The second argument, li, is used for identification only.
+        *)
+  | Pexp_cspval(obj,li) ->
+     re { 
+        exp_desc = Texp_cspval(obj,li);
+        exp_loc = loc; exp_extra = [];
+        exp_type = instance env ty_expected;
+        exp_env = env }
+       (* NNN end *)
   | Pexp_match(sarg, caselist) ->
       begin_def ();
       let arg = type_exp env sarg in
@@ -1886,6 +2035,8 @@
           val_kind = Val_reg; Types.val_loc = loc; } env
           ~check:(fun s -> Warnings.Unused_for_index s)
       in
+      let (id, new_env) =				  (* NNN *)
+          (id, Env.add_stage id !global_stage new_env) in (* NNN *)
       let body = type_statement new_env sbody in
       rue {
         exp_desc = Texp_for(id, param, low, high, dir, body);
@@ -2035,6 +2186,10 @@
                   let (obj_ty, res_ty) = filter_arrow env method_type "" in
                   unify env obj_ty desc.val_type;
                   unify env res_ty (instance env typ);
+                  (* NNN Texp_ident should've been accompanied by
+		     Env.add_level id !global_level
+		     But we don't support staging for objects.
+		   *)
                   let exp =
                     Texp_apply({exp_desc =
                                 Texp_ident(Path.Pident method_id, lid,
@@ -2105,6 +2260,8 @@
               exp_env = env }
         end
   | Pexp_setinstvar (lab, snewval) ->
+      if !global_stage != [] then                (* NNN *)
+         fatal_error "Setinstvar not supported in code."; (* NNN *)
       begin try
         let (path, desc) = Env.lookup_value (Longident.Lident lab.txt) env in
         match desc.val_kind with
@@ -2128,6 +2285,8 @@
           raise(Error(loc, Unbound_instance_variable lab.txt))
       end
   | Pexp_override lst ->
+      if !global_stage != [] then                (* NNN *)
+         fatal_error "Override not supported in code."; (* NNN *)
       let _ =
        List.fold_right
         (fun (lab, _) l ->
@@ -2165,6 +2324,8 @@
           assert false
       end
   | Pexp_letmodule(name, smodl, sbody) ->
+      if !global_stage != [] then                (* NNN *)
+         fatal_error "Letmodule not supported in code."; (* NNN *)
       let ty = newvar() in
       (* remember original level *)
       begin_def ();
@@ -2437,6 +2598,10 @@
       unify_exp env {texp with exp_type = ty_fun} ty_expected;
       if args = [] then texp else
       (* eta-expand to avoid side effects *)
+      (* NNN Every Texp_ident below should've been accompanied by
+	 Env.add_stage. But we don't support staging for
+	 optional and named parameters.
+       *)
       let var_pair name ty =
         let id = Ident.create name in
         {pat_desc = Tpat_var (id, mknoloc name); pat_type = ty;pat_extra=[];
@@ -3007,6 +3172,7 @@
 
 let type_binding env rec_flag spat_sexp_list scope =
   Typetexp.reset_type_variables();
+  global_stage := [];			(* NNN *)
   let (pat_exp_list, new_env, unpacks) =
     type_let
       ~check:(fun s -> Warnings.Unused_value_declaration s)
@@ -3024,6 +3190,7 @@
 
 let type_expression env sexp =
   Typetexp.reset_type_variables();
+  global_stage := [];			(* NNN *)
   begin_def();
   let exp = type_exp env sexp in
   end_def();
@@ -3208,6 +3375,27 @@
   | Unexpected_existential ->
       fprintf ppf
         "Unexpected existential"
+(* NNN through the end of the pattern-match *)
+  | Wrong_stage (n,m) -> 
+      begin 
+	match (m,n) with
+	| [],[] -> fprintf ppf "Wrong level: escape at level 0"
+	| _,_   -> fprintf ppf 
+              "Wrong level: variable bound at level %d and used at level %d" 
+	      (List.length n) (List.length m)  
+      end
+  | Run_occur_check (t1,t2) ->
+      reset_and_mark_loops t1;
+      reset_and_mark_loops t2;
+      fprintf ppf ".! occurs check error: %a occurs in %a"  
+	type_expr t1 type_expr t2
+  | Run_alpha_not_generalizable (t1,t2) ->
+      reset_and_mark_loops t1;
+      reset_and_mark_loops t2;
+      fprintf ppf ".! error: %a not generalizable in %a\n"  
+	type_expr t1 type_expr t2
+  | Trx_error fn -> fn ppf
+      
 
 let () =
   Env.add_delayed_check_forward := add_delayed_check
diff -N -u -r ocaml-4.00.1.orig/typing/typecore.mli ocaml-4.00.1/typing/typecore.mli
--- ocaml-4.00.1.orig/typing/typecore.mli	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/typing/typecore.mli	2013-02-20 17:25:22.000000000 +0100
@@ -103,6 +103,10 @@
   | Not_a_packed_module of type_expr
   | Recursive_local_constraint of (type_expr * type_expr) list
   | Unexpected_existential
+  | Wrong_stage of (type_expr list) * (type_expr list)    (* NNN *)
+  | Run_occur_check of type_expr * type_expr		  (* NNN *)
+  | Run_alpha_not_generalizable of type_expr * type_expr  (* NNN *)
+  | Trx_error of (Format.formatter -> unit)               (* NNN *)
 
 exception Error of Location.t * error
 
diff -N -u -r ocaml-4.00.1.orig/typing/typedtree.ml ocaml-4.00.1/typing/typedtree.ml
--- ocaml-4.00.1.orig/typing/typedtree.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/typing/typedtree.ml	2013-02-20 17:25:22.000000000 +0100
@@ -102,6 +102,11 @@
   | Texp_lazy of expression
   | Texp_object of class_structure * string list
   | Texp_pack of module_expr
+(* NNN through the rest of the definition of expression *)
+  | Texp_bracket of expression
+  | Texp_escape of expression
+  | Texp_run of expression
+  | Texp_cspval of Obj.t * Longident.t loc
 
 and meth =
     Tmeth_name of string
diff -N -u -r ocaml-4.00.1.orig/typing/typedtree.mli ocaml-4.00.1/typing/typedtree.mli
--- ocaml-4.00.1.orig/typing/typedtree.mli	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/typing/typedtree.mli	2013-02-20 17:25:22.000000000 +0100
@@ -101,6 +101,11 @@
   | Texp_lazy of expression
   | Texp_object of class_structure * string list
   | Texp_pack of module_expr
+(* NNN through the rest of the definition of expression *)
+  | Texp_bracket of expression
+  | Texp_escape of expression
+  | Texp_run of expression
+  | Texp_cspval of Obj.t * Longident.t loc
 
 and meth =
     Tmeth_name of string
diff -N -u -r ocaml-4.00.1.orig/typing/typemod.ml ocaml-4.00.1/typing/typemod.ml
--- ocaml-4.00.1.orig/typing/typemod.ml	2013-02-20 17:21:23.000000000 +0100
+++ ocaml-4.00.1/typing/typemod.ml	2013-02-20 17:25:22.000000000 +0100
@@ -1111,9 +1111,30 @@
     (Cmt_format.Partial_structure str :: previous_saved_types);
   str, sg, final_env
 
+(* NNN begin
+Hook up the Trx post-processing
+old
 let type_toplevel_phrase env s = type_structure ~toplevel:true false None env s Location.none
+*)
+let type_toplevel_phrase env s = 
+  let (str, sg, finalenv) = 
+    type_structure ~toplevel:true false None env s Location.none
+  in 
+  (Trx.trx_structure str, sg, finalenv)
+(* NNN end *)
+
 let type_module = type_module true false None
-let type_structure = type_structure false None
+(* NNN begin
+Hook up the Trx post-processing
+old
+ let type_structure = type_structure false None
+*)
+let type_structure env sstr scope = 
+  let (str, sg, finalenv) = type_structure false None env sstr scope
+  in 
+  (Trx.trx_structure str, sg, finalenv)
+(* NNN end *)
+
 
 (* Normalize types in a signature *)
 
