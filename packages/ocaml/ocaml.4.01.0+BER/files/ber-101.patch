diff --git a/.depend b/.depend
index 50b6337..8c2483e 100644
--- a/.depend
+++ b/.depend
@@ -112,6 +112,8 @@ typing/printtyped.cmi : typing/typedtree.cmi
 typing/stypes.cmi : typing/typedtree.cmi parsing/location.cmi \
     typing/annot.cmi
 typing/subst.cmi : typing/types.cmi typing/path.cmi typing/ident.cmi
+typing/trx.cmi : typing/typedtree.cmi parsing/parsetree.cmi \
+    parsing/longident.cmi parsing/location.cmi parsing/asttypes.cmi
 typing/typeclass.cmi : typing/types.cmi typing/typedtree.cmi \
     parsing/parsetree.cmi parsing/longident.cmi parsing/location.cmi \
     typing/ident.cmi typing/env.cmi typing/ctype.cmi parsing/asttypes.cmi
@@ -266,6 +268,16 @@ typing/subst.cmo : typing/types.cmi utils/tbl.cmi typing/path.cmi \
 typing/subst.cmx : typing/types.cmx utils/tbl.cmx typing/path.cmx \
     utils/misc.cmx parsing/location.cmx typing/ident.cmx typing/btype.cmx \
     typing/subst.cmi
+typing/trx.cmo : utils/warnings.cmi typing/types.cmi typing/typedtree.cmi \
+    typing/typecore.cmi typing/printtyp.cmi typing/predef.cmi typing/path.cmi \
+    parsing/parsetree.cmi utils/misc.cmi parsing/longident.cmi \
+    parsing/location.cmi typing/ident.cmi typing/env.cmi typing/ctype.cmi \
+    typing/btype.cmi parsing/asttypes.cmi typing/trx.cmi
+typing/trx.cmx : utils/warnings.cmx typing/types.cmx typing/typedtree.cmx \
+    typing/typecore.cmx typing/printtyp.cmx typing/predef.cmx typing/path.cmx \
+    parsing/parsetree.cmi utils/misc.cmx parsing/longident.cmx \
+    parsing/location.cmx typing/ident.cmx typing/env.cmx typing/ctype.cmx \
+    typing/btype.cmx parsing/asttypes.cmi typing/trx.cmi
 typing/typeclass.cmo : utils/warnings.cmi typing/typetexp.cmi \
     typing/types.cmi typing/typedtree.cmi typing/typedecl.cmi \
     typing/typecore.cmi typing/subst.cmi typing/stypes.cmi \
@@ -332,7 +344,7 @@ typing/typedtreeMap.cmx : typing/typedtree.cmx utils/misc.cmx \
     parsing/asttypes.cmi typing/typedtreeMap.cmi
 typing/typemod.cmo : utils/warnings.cmi typing/typetexp.cmi typing/types.cmi \
     typing/typedtree.cmi typing/typedecl.cmi typing/typecore.cmi \
-    typing/typeclass.cmi typing/subst.cmi typing/stypes.cmi \
+    typing/typeclass.cmi typing/trx.cmi typing/subst.cmi typing/stypes.cmi \
     typing/printtyp.cmi typing/path.cmi parsing/parsetree.cmi \
     typing/mtype.cmi utils/misc.cmi parsing/longident.cmi \
     parsing/location.cmi typing/includemod.cmi typing/ident.cmi \
@@ -341,7 +353,7 @@ typing/typemod.cmo : utils/warnings.cmi typing/typetexp.cmi typing/types.cmi \
     typing/typemod.cmi
 typing/typemod.cmx : utils/warnings.cmx typing/typetexp.cmx typing/types.cmx \
     typing/typedtree.cmx typing/typedecl.cmx typing/typecore.cmx \
-    typing/typeclass.cmx typing/subst.cmx typing/stypes.cmx \
+    typing/typeclass.cmx typing/trx.cmx typing/subst.cmx typing/stypes.cmx \
     typing/printtyp.cmx typing/path.cmx parsing/parsetree.cmi \
     typing/mtype.cmx utils/misc.cmx parsing/longident.cmx \
     parsing/location.cmx typing/includemod.cmx typing/ident.cmx \
@@ -522,15 +534,15 @@ bytecomp/translclass.cmx : typing/types.cmx bytecomp/typeopt.cmx \
     typing/btype.cmx parsing/asttypes.cmi bytecomp/translclass.cmi
 bytecomp/translcore.cmo : utils/warnings.cmi typing/types.cmi \
     bytecomp/typeopt.cmi typing/typedtree.cmi bytecomp/translobj.cmi \
-    typing/primitive.cmi typing/predef.cmi typing/path.cmi \
-    typing/parmatch.cmi utils/misc.cmi bytecomp/matching.cmi \
+    typing/printtyped.cmi typing/primitive.cmi typing/predef.cmi \
+    typing/path.cmi typing/parmatch.cmi utils/misc.cmi bytecomp/matching.cmi \
     parsing/longident.cmi parsing/location.cmi bytecomp/lambda.cmi \
     typing/ident.cmi typing/env.cmi utils/config.cmi utils/clflags.cmi \
     typing/btype.cmi parsing/asttypes.cmi bytecomp/translcore.cmi
 bytecomp/translcore.cmx : utils/warnings.cmx typing/types.cmx \
     bytecomp/typeopt.cmx typing/typedtree.cmx bytecomp/translobj.cmx \
-    typing/primitive.cmx typing/predef.cmx typing/path.cmx \
-    typing/parmatch.cmx utils/misc.cmx bytecomp/matching.cmx \
+    typing/printtyped.cmx typing/primitive.cmx typing/predef.cmx \
+    typing/path.cmx typing/parmatch.cmx utils/misc.cmx bytecomp/matching.cmx \
     parsing/longident.cmx parsing/location.cmx bytecomp/lambda.cmx \
     typing/ident.cmx typing/env.cmx utils/config.cmx utils/clflags.cmx \
     typing/btype.cmx parsing/asttypes.cmi bytecomp/translcore.cmi
diff --git a/Makefile b/Makefile
index 10c80d2..d3db812 100644
--- a/Makefile
+++ b/Makefile
@@ -19,6 +19,9 @@ CAMLC=boot/ocamlrun boot/ocamlc -nostdlib -I boot
 CAMLOPT=boot/ocamlrun ./ocamlopt -nostdlib -I stdlib -I otherlibs/dynlink
 COMPFLAGS=-strict-sequence -w +33..39 -warn-error A $(INCLUDES)
 LINKFLAGS=
+# For debugging
+# COMPFLAGS=-warn-error A -g $(INCLUDES) # NNN
+# LINKFLAGS=-g #NNN
 
 CAMLYACC=boot/ocamlyacc
 YACCFLAGS=-v
@@ -45,6 +48,7 @@ PARSING=parsing/location.cmo parsing/longident.cmo \
   parsing/pprintast.cmo \
   parsing/ast_mapper.cmo
 
+# NNN (trx)
 TYPING=typing/ident.cmo typing/path.cmo \
   typing/primitive.cmo typing/types.cmo \
   typing/btype.cmo typing/oprint.cmo \
@@ -57,6 +61,7 @@ TYPING=typing/ident.cmo typing/path.cmo \
   typing/typedtreeIter.cmo typing/typedtreeMap.cmo typing/cmt_format.cmo \
   typing/stypes.cmo typing/typecore.cmo \
   typing/typedecl.cmo typing/typeclass.cmo \
+  typing/trx.cmo \
   typing/typemod.cmo
 
 COMP=bytecomp/lambda.cmo bytecomp/printlambda.cmo \
@@ -117,7 +122,11 @@ defaultentry:
 
 # Recompile the system using the bootstrap compiler
 all: runtime ocamlc ocamllex ocamlyacc ocamltools library ocaml \
-  otherlibraries ocamlbuild.byte $(CAMLP4OUT) $(DEBUGGER) ocamldoc
+	otherlibraries ocamlbuild.byte $(DEBUGGER) ocamldoc
+# NNNN  otherlibraries ocamlbuild.byte $(CAMLP4OUT) $(DEBUGGER) ocamldoc
+# NNN Since MetaOcaml is no binary compatible with OCaml, there is
+# no need to be rebuilding libraries
+# NNN make all && (cd metalib && make clean all) && (make install; cd metalib && make install)
 
 # Compile everything the first time
 world:
@@ -288,6 +297,13 @@ install:
 	   $(COMPLIBDIR)
 	cp expunge $(LIBDIR)/expunge$(EXE)
 	cp toplevel/topdirs.cmi $(LIBDIR)
+# NNN typing/trx.ml needs its own interface (since it looks up identifiers
+# in itself)
+# Although typing/trx.cmi is already copied, see above, it is copied
+# into $((COMPLIBDIR). We need trx.cmi in the standard .cmi search path.
+	cp typing/trx.cmi $(LIBDIR)
+# BTW, trx.cmo is part of ocamlcommon.cma
+# NNN end
 	cd tools; $(MAKE) install
 	-cd man; $(MAKE) install
 	for i in $(OTHERLIBRARIES); do \
diff --git a/asmcomp/cmmgen.ml b/asmcomp/cmmgen.ml
index 23d4798..f89f864 100644
--- a/asmcomp/cmmgen.ml
+++ b/asmcomp/cmmgen.ml
@@ -2028,6 +2028,7 @@ and emit_constant_field field cont =
       (Clabel_address lbl,
        Cint(floatarray_header (List.length fields)) :: Cdefine_label lbl ::
        Misc.map_end (fun f -> Cdouble f) fields cont)
+  | Const_csp_value _  -> assert false  (* NNN *)
 
 and emit_string_constant s cont =
   let n = size_int - 1 - (String.length s) mod size_int in
diff --git a/ber-metaocaml-101/.depend b/ber-metaocaml-101/.depend
new file mode 100644
index 0000000..d221904
--- /dev/null
+++ b/ber-metaocaml-101/.depend
@@ -0,0 +1,19 @@
+metatop.cmi :
+print_code.cmi :
+reify_type.cmi :
+runcode.cmi :
+trxtime.cmi :
+berstart.cmo :
+berstart.cmx :
+bertop.cmo :
+bertop.cmx :
+print_code.cmo : runcode.cmi print_code.cmi
+print_code.cmx : runcode.cmx print_code.cmi
+reify_type.cmo : reify_type.cmi
+reify_type.cmx : reify_type.cmi
+run_native.cmo :
+run_native.cmx :
+runcode.cmo : runcode.cmi
+runcode.cmx : runcode.cmi
+trxtime.cmo : trxtime.cmi
+trxtime.cmx : trxtime.cmi
diff --git a/ber-metaocaml-101/ChangeLog b/ber-metaocaml-101/ChangeLog
new file mode 100644
index 0000000..16769db
--- /dev/null
+++ b/ber-metaocaml-101/ChangeLog
@@ -0,0 +1,68 @@
+November 26, 2013
+	Release N101
+	Removed environment classifiers.
+	Syntax .! is replaced with the ordinary prefix operation
+	!.  (alias run) in the module Runcode. Runcode.run is an
+	ordinary function, and is not part of the MetaOCaml kernel.
+	New API for running code, encouraging the development of new ways
+	to execute code values (see metalib/runcode.mli).
+	BER N101 is binary compatible with OCaml 4.01. Building it
+	no longer involves bootstrapping.
+	Printing code is now part of OCaml (Pprintast, which was influenced by
+        MetaOCaml).
+	Scope-extrusion check works with delimited control.
+	Added a test for the well-formedness of recursive let.
+	Faster generation of code (especially for functions and nonbinding
+	functions).
+	More precise tracking of free variables and reporting of scope
+	extrusion.
+
+February 20, 2013
+	Re-enabled ocamlbuild.byte target in the Makefile, so to
+	to build ocamlbuild as part of the make all.
+	A small fix to permit compiling ocamlopt. Although at present,
+	ocamlopt can't compile code with brackets, it can compile
+	the regular OCaml code. In addition, it supports let!.
+	Thanks to Bob Zhang for suggestions.
+
+January 30, 2013
+	Rewritten trx.ml. Release N100.
+
+January 12, 2013
+	Importing the pretty-printing of code, greatly improved by Jacques
+	Carette.
+
+January 7-12, 2013
+	Beginning the port to OCaml 4.00.1. The basic changes to OCaml
+	are done. Started work on re-writing trx.ml
+
+December 28, 2012
+	Version N004 released
+
+November 8, 2012
+	Eliminating val_level from value_desc. Introducing Env map stage
+	to map an identifier to its stage, if not zero. Several
+	OCaml modules no longer have to be patched.
+	Simplified CSP code, removed a few patches from typecore.
+	SCP now carries strings, native_int, int32, int64 as
+	literal constants. Identifiers in List module are carried
+	by reference.
+
+October 4, 2012
+	Jacques Carette has committed Alain Frisch's patch implementing
+	the let! form proposed by Nicolas Pouillard for monadic
+	programming in Ocaml.
+	http://pauillac.inria.fr/~protzenk/let-bang.html
+	See metalib/test/pythagorian_triples.ml for an example.
+
+January 3, 2011
+	Added metaocamlmktop
+
+December 2010
+	Patch from Fabrice Le Fessant to remove functional values
+	from typing Env. See entry May 5, 2010 in Problems.txt.
+	Generic printing is now part of BER MetaOCaml.
+
+March 1, 2010
+	Version N002 released, based on OCaml 3.11
+
diff --git a/ber-metaocaml-101/Files.txt b/ber-metaocaml-101/Files.txt
new file mode 100644
index 0000000..e655ff2
--- /dev/null
+++ b/ber-metaocaml-101/Files.txt
@@ -0,0 +1,58 @@
+OCaml files affected by the BER MetaOCaml. 
+Search for NNN in each files for concrete changes
+
+./Makefile
+./ocamldoc/Makefile
+
+done	./parsing/lexer.mll
+done	./parsing/parser.mly
+done	./parsing/parsetree.mli
+done	./parsing/printast.ml       trivial
+done    ./parsing/pprintast.ml      new in 4.01
+done    ./parsing/ast_mapper.ml     new in 4.01, trivial 
+
+done	./typing/typedtree.mli
+done	./typing/typedtree.ml
+done	./typing/predef.ml
+done	./typing/predef.mli
+
+done    ./typing/printtyped.ml      did not exist before, trivial changes
+done    ./typing/typedtreeIter.ml   in 4.01, moved from tools, trivial changes
+done    ./typing/typedtreeMap.ml    new in 4.01, trivial changes
+
+done	./typing/env.mli
+done	./typing/env.ml
+done    ./typing/envaux.ml   new in 4.01, trivial changes
+
+done	./typing/typecore.mli
+done	./typing/typecore.ml
+done	./typing/typemod.ml 
+
+done	./bytecomp/lambda.ml	Only adding Const_csp_value
+done	./bytecomp/lambda.mli
+done	./bytecomp/printlambda.ml
+done	./bytecomp/translcore.ml
+done	./bytecomp/symtable.ml
+
+done	./tools/depend.ml
+done	./tools/dumpobj.ml (only printing Const_csp_value)
+done	./tools/ocamlprof.ml
+done    ./tools/untypeast.ml     did not exist before, trivial changes
+done    ./tools/tast_iter.ml new in 4.01
+
+
+	./typing/trx.mli
+	./typing/trx.ml 
+
+
+		./typing/ident.ml       No longer changed
+	        ./tools/addlabels.ml not built any more?
+		./typing/ident.mli      No longer changed
+		./typing/typeclass.ml   No longer changed
+                ./typing/cmt_format.ml    in 4.01, no longer changed
+
+                ./typing/unused_var.ml  No longer present in Ocaml 4
+
+
+done ./asmcomp/cmmgen.ml	Const_csp_value will cause fatal error
+			Const_csp_value must not appear in native code
diff --git a/ber-metaocaml-101/INSTALL b/ber-metaocaml-101/INSTALL
new file mode 100644
index 0000000..24535f6
--- /dev/null
+++ b/ber-metaocaml-101/INSTALL
@@ -0,0 +1,68 @@
+INSTALLATION
+
+You need the source OCaml 4.01 distribution, which you can download from
+    http://caml.inria.fr/download.en.html
+See also
+    http://ocaml.org/install.html
+
+1. Download, un-tar the OCaml distribution and configure it as described
+   in its INSTALL file
+
+   For example, in the OCaml distribution directory, do
+
+    ./configure -prefix `pwd` -no-pthread -no-tk
+
+  You may chose any other installation prefix. It is best however
+  to chose the prefix different from that of the standard OCaml installation,
+  so to keep the existing OCaml installation intact.
+
+1a. Update the Makefile in the ber-metaocaml directory
+
+    change CAMLROOT= at the beginning of the ber-metaocaml/Makefile
+    to point to the OCaml distribution directory 
+
+2. Patch the OCaml distribution
+
+   In the ber-metaocaml directory, do
+
+   make patch
+
+
+3. Compile and install OCaml as usual. For example, in the OCaml 
+   distribution directory, do
+
+    make world
+    make -i install
+
+
+4. Build the BER MetaOCaml library, the top-level, and the
+   compilation script
+
+   In the ber-metaocaml directory, do
+
+    make all
+    make install
+
+  The BER MetaOCaml top-level can be started afterwards as
+    $prefix/bin/metaocaml 
+
+  The batch compiler can be run using the command file metaocamlc. 
+
+5. Optionally run sample tests
+   
+   In the ber-metaocaml directory, do
+
+   make test
+   make test-compile
+
+
+Installation of BER MetaOCaml on Windows has not been tested. Original
+MetaOCaml contained the following note about the Windows platform:
+
+      To use MetaOCaml under MS Windows, please do not use "Windows
+      OCaml".  Rather, use the standard OCaml system under cygwin.  If you
+      happened to install the "Windows OCaml" in the past, manually remove
+      some environment variables before you can install the standard system
+      successfully.  To do that, goto START -> Control Panel -> System ->
+      Advanced -> Environment variables, and edit the OCAMLLIB variable and
+      remove any entries in that entry.
diff --git a/ber-metaocaml-101/Makefile b/ber-metaocaml-101/Makefile
new file mode 100644
index 0000000..640bed3
--- /dev/null
+++ b/ber-metaocaml-101/Makefile
@@ -0,0 +1,137 @@
+# Build the BER MetaOCaml library, top-level, and the compiler driver
+# See INSTALL for more detail
+
+# Location of the OCaml distribution directory
+CAMLROOT=..
+
+include $(CAMLROOT)/config/Makefile
+
+RUNTIME=$(CAMLROOT)/boot/ocamlrun
+INCLUDES=-I $(CAMLROOT)/utils \
+	-I $(CAMLROOT)/parsing  -I $(CAMLROOT)/typing -I $(CAMLROOT)/bytecomp \
+	-I $(CAMLROOT)/asmcomp  -I $(CAMLROOT)/driver \
+	-I $(CAMLROOT)/toplevel -I $(CAMLROOT)/stdlib
+COMPILER=$(CAMLROOT)/ocamlc
+CAMLC=$(RUNTIME) $(COMPILER) $(INCLUDES)
+COMPFLAGS=-strict-sequence -w +33..39 -warn-error A -nostdlib
+OPTCOMPILER=$(CAMLROOT)/ocamlopt
+CAMLOPT=$(RUNTIME) $(OPTCOMPILER)
+OPTCOMPFLAGS=-strict-sequence -w +33..39 -warn-error A -nostdlib
+CAMLDEP=$(CAMLROOT)/boot/ocamlrun $(CAMLROOT)/tools/ocamldep
+
+METALIB=metalib.cma
+METALIBOBJS=runcode.cmo print_code.cmo
+METAOBJS=$(METALIB) bertop.cmo berstart.cmo
+
+all: $(METAOBJS) metaocaml metaocamlc
+
+.SUFFIXES: .mli .ml .cmi .cmo .cmx
+
+.mli.cmi:
+	$(CAMLC) $(COMPFLAGS) -c $<
+
+.ml.cmo:
+	$(CAMLC) $(COMPFLAGS) -c $<
+
+.ml.cmx:
+	$(CAMLOPT) $(OPTCOMPFLAGS) -c $<
+
+$(METALIB): $(METALIBOBJS)
+	$(CAMLC) $(COMPFLAGS) -o $@ -a $(METALIBOBJS)
+
+
+install: metaocaml metaocamlmktop metaocamlc
+	cp runcode.cmi print_code.cmi metalib.cma bertop.cmo berstart.cmo \
+	  $(LIBDIR)
+	cp metaocaml $(BINDIR)/metaocaml$(EXE)
+	cp metaocamlmktop $(BINDIR)/metaocamlmktop$(EXE)
+	cp metaocamlc $(BINDIR)/metaocamlc$(EXE)
+
+metaocaml: $(METAOBJS) $(CAMLROOT)/compilerlibs/ocamlcommon.cma
+# $(CAMLROOT)/tools/ocamlmktop \
+# -o $@ $(METALIB) bertop.cmo berstart.cmo
+	$(CAMLC) -nostdlib -linkall \
+	$(CAMLROOT)/compilerlibs/ocamlcommon.cma \
+	$(CAMLROOT)/compilerlibs/ocamlbytecomp.cma \
+	$(CAMLROOT)/compilerlibs/ocamltoplevel.cma \
+	-o $@ $(METALIB) bertop.cmo berstart.cmo \
+	$(CAMLROOT)/toplevel/topstart.cmo
+
+
+
+clean::
+	rm -f metaocaml
+
+metaocamlmktop: metaocamlmktop.tpl metaocaml
+	sed -e 's|%%BINDIR%%|$(BINDIR)|' metaocamlmktop.tpl > metaocamlmktop
+	chmod +x metaocamlmktop
+
+clean::
+	rm -f metaocamlmktop
+
+metaocamlc: metaocamlc.tpl metaocaml
+	sed -e 's|%%BINDIR%%|$(BINDIR)|' metaocamlc.tpl > metaocamlc
+	chmod +x metaocamlc
+
+clean::
+	rm -f metaocamlc
+
+clean::
+	rm -f *.cm* *.o *.a
+	rm -f test/*.cm* test/*.o
+	rm -f *~
+#	cd gprint && $(MAKE) CAMLROOT=../$(CAMLROOT) clean
+
+test:
+	TERM=dumb $(BINDIR)/metaocaml < test/trivial.ml > trivial.out && \
+	diff -u trivial.out trivial.ref
+	TERM=dumb $(BINDIR)/metaocaml < test/simple.ml > simple.out && \
+	diff -u simple.out simple.ref
+	$(BINDIR)/metaocaml test/simple_true.ml
+	$(BINDIR)/metaocaml test/quick_test.ml
+	$(BINDIR)/metaocaml test/test21.ml
+	$(BINDIR)/metaocaml test/pythagorian_triples.ml
+#	$(BINDIR)/metaocaml test/t4.ml
+#	cd gprint && $(MAKE) CAMLROOT=../$(CAMLROOT) MOCAMLTOP="../metaocaml -I .." testv_top
+#	cd gprint && $(MAKE) CAMLROOT=../$(CAMLROOT) vgprint_top
+
+test-compile:
+	$(BINDIR)/metaocamlc -o simple_true test/simple_true.ml
+	./simple_true
+# 	$(BINDIR)/metaocamlc -o quick_test test/quick_test.ml
+# 	./quick_test
+	$(BINDIR)/metaocamlc -dparsetree -drawlambda -dinstr -c test/test21.ml
+	$(BINDIR)/metaocamlc -c test/t4types.mli && \
+	cp test/t4types.cmi . # .cmi file should be where the executable is
+	$(BINDIR)/metaocamlc -o t4 -I test/ test/t4.ml
+	./t4
+	$(BINDIR)/metaocamlc -o pt test/pythagorian_triples.ml
+	./pt
+#	cd gprint && $(MAKE) CAMLROOT=../$(CAMLROOT) vgprint
+
+clean::
+	rm -f simple_true quick_test t4 pt trivial.out simple.out
+
+# Patch the OCaml distribution
+patch:
+	cp -p patches/trx.ml $(CAMLROOT)/typing/
+	cp -p patches/trx.mli $(CAMLROOT)/typing/
+#	patch -p0 -d $(CAMLROOT) < patches/patch
+	patch -p1 -d $(CAMLROOT) < patches/patch
+
+# Create the patch set
+makepatch:
+	cp -p $(CAMLROOT)/typing/trx.ml patches/
+	cp -p $(CAMLROOT)/typing/trx.mli patches/
+	sh ./build_patch.sh > patches/patch
+
+# metaocamlopt: stdlib/metanative.cmxa tools/metaocamlopt.tpl 
+# 	sed -e 's|%%BINDIR%%|$(BINDIR)|' tools/metaocamlopt.tpl > metaocamlopt
+# 	chmod +x metaocamlopt
+
+include .depend
+
+depend:
+	$(CAMLDEP) *.mli *.ml > .depend
+
+.PHONY: all test clean patch makepatch depend test-compile install
diff --git a/ber-metaocaml-101/NOTES.txt b/ber-metaocaml-101/NOTES.txt
new file mode 100644
index 0000000..10ef3b1
--- /dev/null
+++ b/ber-metaocaml-101/NOTES.txt
@@ -0,0 +1,746 @@
+			BER MetaOCaml
+
+* Main differences from the original MetaOCaml
+
+** Substantial changes
+
+ -- Constructor restriction: all data constructors and record labels 
+ used within brackets must come from the types that are declared in 
+ separately compiled modules.
+
+ -- Scope extrusion check: attempting to build code values with
+ unbound or mistakenly bound variables (which is possible with
+ mutation or other effects) is caught early, raising an exception
+ with good diagnostics.
+
+ -- The scope extrusion check made it possible to remove environment
+ classifiers while still preserving the static guarantee: if the generator
+ finishes successfully, the generated code is well-typed and
+ well-scoped. Environment classifiers ensured well-scopedness when
+ type-checking the generator -- but only for pure generators. The
+ scope extrusion check is executed when the generator is run; however
+ the check is now comprehensive. Scope extrusion is always caught, and
+ caught early, whether the generator is effectful or not.
+
+ -- Syntax .! is replaced with the ordinary prefix operation
+ (!.) (alias run) defined in the module Runcode. Runcode.run is an
+ ordinary function, and is not part of the MetaOCaml kernel.
+
+ -- In OCaml 4.00.1 , the Core type checker was changed to use
+ type_expect. This generates better error messages. Therefore, the type
+ checking of brackets, escape and CSP was re-written accordingly,
+ to propagate expectations down. For example, <e> is expected to have
+ the type of ty code where e has is expected to have the
+ type ty.
+
+ -- The main MetaOCaml kernel module, trx.ml, has been completely
+ re-written. Many algorithms were changed. For example, the traversal
+ of the Typedtree looking for brackets to replace is completely
+ re-written. Now we maintain sharing as much as possible. If the tree
+ has no brackets, it is returned as it was.  Previously, it was copied.
+
+ -- Faster generation of code (especially for functions and nonbinding
+ functions)
+
+ -- Added a test for the well-formedness of recursive let (see below)
+
+ -- Applications with labeled arguments are supported now.
+
+ -- The problem with first-class polymorphism (records with polymorphic
+ fields inside brackets) has fixed itself. See the file
+ tests/simple.txt. 
+
+
+ -- Precise type assignment when building Typedtree nodes (when
+ hand-compiling Parsetree generation)
+   
+ -- Processing of CSP has changed, split into two phases. At
+ compilation time, we know the type of the CSP and decide if values
+ of that type can be lifted. If not, we look at the CSP identifier
+ to decide if the CSP can be referred to by qualified name (that is,
+ the CSP identifier is part of a separately compiled module).
+ If all fails, we generate the call to a quotator that would build
+ the CSP at run-time, when the value to quote becomes known. Overall,
+ the procedure improves the printing of CSP.
+
+
+** Separation into `kernel' and `user-level' code
+
+The kernel modifies (and is part of) the OCaml system. The user-level
+code is in a directory metalib outside the OCaml distribution. The
+user-level code can be changed and expanded without the need to hack
+and re-compile (Meta)OCaml. Changes introduced to future versions of
+OCaml will not generally affect the `user-level' code.
+
+ -- Printing of code values --  AST pretty_printing by Ed Pizzi --
+ is moved to user-level, a dedicated file metalib/print_code.ml.
+ The bulk of pretty-printing is now done by OCaml itself, module
+ Pprintast.
+
+ -- New API for running code, encouraging the development of new ways
+ to execute code values (see metalib/runcode.mli).
+ The operation 'run' is a regular function now, and is user-level
+ rather than being part of the kernel.
+
+ -- Now BER MetaOCaml is built as a custom top-level, using the standard tool
+ ocamlmktop. We register code printers as regular top-level printers
+ of user-defined data types. Therefore, topmain is no longer modified.
+
+ -- Tag elimination is fully removed.
+
+ -- trxtime is moved to metalib.
+
+ -- Offshoring is temporarily removed; it should be re-introduced as
+ a module in metalib, a user-level code.
+
+
+** Engineering changes
+
+ -- All modified lines in the OCaml code are marked by (* NNN *)
+
+ -- There are comments now -- and lots of them
+
+ -- Added very many regression tests (which also work as examples) to test
+ every feature: see test/trivial.ml and test/simple.ml
+
+ -- The new BER N101 is not only source-compatible with OCaml 4.01 --
+ it is also binary compatible. Any 4.01-built OCaml library and plugin
+ (including findlib) can be used with BER N101 in their binary form.
+ The building of BER N101 no longer involves bootstrapping
+ and is hence much faster. 
+
+
+
+* What part of MetaOCaml can be moved to the OCaml proper
+Suggestions for the OCaml HQ
+
+ -- make all path_idents in predef.ml to be persistent. Currently,
+ to check if type int is in Pervasives, I have to search the initial
+ environment. 
+
+ -- There are two restrictions on let rec: patterns must be simple
+ variable patterns (either just 'var' or '_ as var') and the variable
+ bound by let rec must appear under lambda, lazy or constructor.
+ These conditions are checked very late (in bytecomp/transcore.ml),
+ after type checking. But these are syntactic conditions; in
+ particular, the first condition can be checked during the parsing.
+ Minimal suggestion: check the first condition at parsing and
+ the second at type checking. So, a code that type checks should
+ produce no further compilation errors. Extended suggestion: since
+ let rec patterns are so restricted (and since the processing of patterns
+ becomes more involved with the addition of GADTs), separate
+ Pexp_let/Texp_let into Pexp_let and Pexp_letrec (ditto for Texp). 
+ Type checking will become more orthogonal since in type checking Pexp_letrec
+ we don't need to care about GADTs, the exhaustiveness check and
+ the type propagation from expression to patterns. 
+
+ -- Unify printing functions for various trees and make them
+ prettier. The very same fmt_longident_aux occurs three times in 
+ the OCaml code base (parsing/printast.ml, tools/pprintast.ml,
+ typing/printtyped.ml)
+
+ - Better and modular error handling. Currently, to add a new
+ error, say, to typecore.ml one has to add the error to typecore.mli,
+ make the same addition to typecore.ml, augment the printing function
+ in typecore.ml. To add a new category, one has to augment
+ driver/errors.ml. I have tried a uniform
+      exception Error of (format -> unit)
+ The error carries the function that will print out the error
+ message on the supplied ppf. Handler becomes much more extensible!
+ This approach does seem to work out. It is used all throughout N101.   
+
+ -- On one hand, it is tempting to eliminate Const_csp_value. There
+ will no longer be a need to modify the code generator (in bytecomp/).
+ On the other hand, Const_csp_value does make sense as a structured
+ constant. Consider a constant that refers to a big array, or even 
+ array in ancient. Representing such constant in a Parsetree as a
+ string is ungainly. Syntactic extensions in particular could use
+ Const_csp_value.
+
+
+* Further plans
+
+** Optimize the construction of code values (Parsetree)
+
+When the bracket expression is run, it produces the Parsetree that
+represents the code. The tree is constructed at run-time.  In some
+cases the Parsetree can be constructed at compile time, in
+trx.ml. A constant like <1> is such a case, when we can immediately
+construct the Parsetree: Pexp_constant (Constant_int 1).  After we
+construct the Parsetree at compile time, we use CSP to pass it over to
+run-time. When run, the program will use the compiled constant. This
+mechanism of building Parsetree at compile-time whenever possible is
+one of the large differences from the previous versions of MetaOCaml.
+
+This approach can be extended, by constructing large Parsetree
+subtrees at compile time, and passing them as CSP. See ``TODO: an
+optimization idea. Consider <assert e> as a typical expression.'' in
+trx.ml
+If we can build functions at translation time, we don't even
+need to rename bound variables (let alone do the scope-extrusion
+check). If a code value has no escapes, like .<fun x -> x>.,
+then no scope extrusion is possible.
+
+** Improve processing CSP
+
+When lifting int, bool, etc. values, we generate calls to run-time
+functions like lift_constant_int to do the Parsetree generation. In
+the future we should `inline' those functions -- that is, obtain the
+Typedtree for them and use the tree for building Texp_apply.
+
+Lists, arrays, option types of liftable types are themselves
+liftable. We can lift many more types. For arrays, check their length.
+If the array is short, it should be lifted. For long arrays, building
+a CSP is better (although it make take a bit longer since we will have
+to invoke dyn_quote at run-time).
+
+** Minimize changes to OCaml
+
+Strictly speaking, we don't need to change typedtree or parsetree. We
+can just add functions with distinguished names.  And add printers and
+add to the type checker. It helps if OCaml added one node to parsetree
+Pexp_extension and a similar node to typed tree. The user may register
+extensions, invoked by the type checker, printer, etc.  to type check
+the node.
+
+
+** Search for TODO in trx.ml
+
+** Generating let rec with statically unknown number of bindings
+(suggestion by Jun Inoue)
+Use case: specialization of recursive functions, e.g., specializing
+KMP.
+
+proposed interface
+module MakeLetRecs : sig
+  type letrec_id                        (* abstract *)
+  val make_letrec : (letrec_id -> ('cl,'w) code) -> ('cl,'w) code
+
+  val add_fun_binding : letrec_id -> 
+  (('cl,'a->'b) code -> ('cl,'a->'b) code) -> 
+    (('cl,'a->'b) code -> ('cl,'w) code) -> ('cl,'w) code
+end
+
+Perhaps there should also be
+ add_lazy_binding : letrec_id -> ('a lazy code -> 'b lazy code) -> ...
+  (* classifiers omitted *)
+i.e. one that generates bindings of the form
+ a = lazy (foo a)
+
+Jun Inoue wrote:
+I wonder if it wouldn't be too limiting to restrict the interface
+slightly further, so as to ensure that we never get a "this kind of
+expression is not allowed on the right-hand side of a let rec" error?
+For instance, add_fun_binding could be restricted so that
+  add_fun_binding : letrec_id -> (('arg -> 'ret) code -> 'arg code ->
+'ret code) -> (('arg -> 'ret) code -> 'body code) -> 'body code
+and
+  add_fun_binding id (fun f x -> .<.~f .~x>.) (fun f -> .<.~f 0>.)
+produces
+  .<let rec f x = f x in f 0>.
+
+
+
+* Installation notes
+
+configuration line
+./configure -prefix /home/oleg/Cache/ncaml4/ -no-tk -no-pthread
+-no-camlp4 -no-graph
+
+
+* Old Future work
+
+** Get rid of .! as a kernel form
+
+The syntax .! may remain, but only as syntax. The parser would just 
+expand .! x  to {Trx.cde = x}. To really run the code, we would write
+    Run.run .! .<1>.
+Incidentally, we can have Run.run_bytecode and Run.run_native.
+Since it is possible now to dynamically load native code into
+bytecode, we can separate the mode of running the generated code
+(bytecode/native) from the mode of running the generator.
+
+We don't have to add the record 'a cde to predef. We can add it to
+Trx. The only drawback is that pretty-printer may print {cde = x} with
+the Trx qualification. But it is easy to adjust the pretty-printer to
+omit the Trx qualification.
+
+[BER N101 removed environment classifiers altogether. Therefore, run
+ became ordinary function and is moved out of the kernel.]
+
+Then BER MetaOCaml becomes BE MetaOCaml?
+
+** without environment classifiers, more programs type check
+let tr7 = .<fun x -> !. x>.;;
+(*
+val tr7 : ('a code -> 'a) code = .<fun x_63  -> Runcode.( !. )  x_63>. 
+
+Was:
+Characters 24-25:
+  let tr7 = .<fun x -> !. x>.;;
+                          ^
+Error: !. error: 'a not generalizable in ('a, 'b) code
+*)
+But the code was legitimate:
+let 10 = !. tr7 .<10>.;;
+
+BER N101 accepts it and runs.
+
+
+** well-formedness check for let rec
+[This check is implemented in BER N101]
+
+  let rec x = x in x;;
+              ^
+Error: This kind of expression is not allowed as right-hand side of `let rec'
+
+It is not well-formed. But it is well-typed:
+
+let c1 = .<let rec x = x in x>.;;
+   val c1 : ('cl, 'a) code = .<let rec x_142 = x_142 in x_142>. 
+
+and it is accepted by all versions of MetaOCaml before N101.  It is
+only when we try to compile (that is, run) the generated code, we see
+a problem
+
+.! c1;;
+   Exception: Translcore.Error (_, 1).
+
+
+Once I knew where to look, I found another similar problem:
+
+let c2 = .<let rec [] = [] in []>.;;
+  val c2 : ('cl, 'a list) code = .<let rec [] = [] in []>. 
+
+It is well-typed and accepted. Alas,
+
+.! c2;;
+   Exception: Translcore.Error (_, 0).
+
+This problem has existed in MetaOCaml from the very beginning, as far
+as I could see.
+
+The first problem is most troubling. Consider
+
+let t1 x = .<0:: .~x>.;;
+  val t1 : ('cl, int list) code -> ('cl, int list) code = <fun>
+let t2 x = .<if true then 0:: .~x else [1]>.;;
+  val t2 : ('cl, int list) code -> ('cl, int list) code = <fun>
+
+Both t1 and t2 are well-typed and accepted. They have identical types.
+However,
+
+let r = .<let rec x = .~(t1 .<x>.) in 2>. in .!r;;
+  - : int = 2
+
+let r = .<let rec x = .~(t2 .<x>.) in 2>. in .!r;;
+  Exception: Translcore.Error (_, 1).
+
+I was thinking to check that all future-stage letrec are of the form 
+        let rec f x1 ... xn = ...
+although this is certainly restrictive since it precludes lazy
+bindings and also the following legitimate code
+
+        type stream = Stream of string * (unit -> stream);;
+        let rec f = Stream ("stream", fun () -> f) in f;;
+Perhaps it may be worth noting the issue and leave it for now?
+
+** Installation notes
+When linking the first time, beware!
+Since we added to predef.ml[i], we have changed the timestamps of the
+pre-defined identifiers and exceptions, and so created inconsistency
+with respect to the bootstrap compiler. So, when compiling the system
+the first time, after applying the patches to OCaml, do
+    make core
+    make coreboot
+    make all
+[This is fixed in N101, which is now binary compatible with OCaml]
+
+** Type-checking of run
+Type-checking of run  (in typing/typecore.ml) can be done differently,
+using polymorphic/universally quantified variables (Tpoly/Tunivar)
+
+One may think that we can pre-process the ParseTree before we hand it
+over to the type-checker, replacing Pexp_constant that occurs within
+the brackets with a node Pexp_apply "mk_constant", etc. However, we
+have problems with generalizing second-stage let. Since the let-form
+will be replaced with a function call, generalization won't be
+performed!
+[As of BER N101, this is no longer relevant since there are no
+environment classifiers any more.]
+
+** The problem of the constructor environment (signature)
+
+Why typecore.ml has so many changes.
+A bracket expression .< e >. is typechecked once, then it is turned
+into expression that builds, at run-time, the AST for e. When we run
+the code expression, MetaOCaml type-checks the AST -- essentially
+type-checking e the second time around, at a different level this
+time. The second type-checking certainly occurs in a different
+environment -- specifically, in a different constructor and label
+environment. The constructors and labels that have been in effect when
+e is first type-checked may be re-defined when e is type-checked the
+second time.
+
+Therefore, we remember, in the fields pexp_ext and ppat_ext the typed
+tree of the expression resulting from the original type-checker
+run. When we type-check the expression the second time, we keep the
+constructor descriptors resolved from the first time around (yet we
+re-typecheck the arguments of the record and the constructed
+expression: for the sake of staging constructs and CSP, which are
+demoted. After all, the second type-checking occurs at a different
+level).
+
+Currently, MetaOCaml adds pexp_ext and ppat_ext fields to ParseTree,
+to store ref to the type of the node. We only need this information
+for nodes of the variant and record types (see typecore). We don't
+need to store anything for literals, and other irrelevant nodes.
+Furthermore, we don't need to store anything for records and variants
+that are defined in Pervasives (or stdlib).  The next approximation:
+we don't need to store any type information if the type is a
+variant/record defined in another module (that is, qualified with the
+name of another module) -- provided that the corresponding .cmi is
+available at run-time, to the run-time compiler.
+
+What pexp_ext and ppat_ext really need to store? Can they just store
+constructor, labels, probably types and classes (but not values) maps
+from Env.t? (We need to force the maps: they have lazy components).
+We can bracket only expressions: therefore, staged code, when
+typechecked again, cannot modify the constructor, label etc maps
+from the environment. Well, there is always
+     <let module M = struct type foo = Foo ... end in ...>
+but it is not clear if we want to support this. 
+
+It would be great to find a way not not add fields to Parsetree such
+as pexp_ext and ppat_ext. The latter causes too many modifications, in
+all the places where such records are constructed. Could we store the
+_ext fields in a parallel map? How to garbage-collect them though? It
+would be great if the only cases where ppat_ext and pext_ext mattered
+where the cases of identifiers (so we can use Lident as a key).
+Incidentally, the type t in env.ml is a collection of various maps.
+Perhaps that's the place to store pexp_ext information for
+identifiers. Here is an idea: Think of replacing pexp_ext and ppat_ext
+with an extra field in location record. Location is almost always used
+as an abstract type.  Thus when extending the concrete type of
+Location.t, little code needs to be patched.
+
+Here is the idea how to simplify trx code. As we discussed earlier,
+the code expression produces Parsedtree, which contains only the names
+of the constructors. We need to know the constructor description.  In
+the regular type-checking, all this information can be found in the
+environment, placed there by data type declarations. When we invoke
+the type checker at run time (as part of running the code), there are
+no data declarations available. After all, a code expression contains
+only expression rather than declarations. Currently, we stash away the
+whole environment inside the fake parsetree.  What we can do: during
+the first type-checking, determine is a particular constructor name is
+pre-defined or user-defined. If a constructor name is not global,
+generate a long identifier of the form Lxxxx.real_name where Lxxxx is
+some random string. Maintain a new environment and store in it the
+association of that Lxxxx with the constructor description (which we
+can get from Env.t). Once we finish type-checking, attach the new env
+as part of the code value; perhaps each code value should have the
+field for the environment for constructor description, exception
+description, label and method description.  When we run the code, add
+this associated env to the env of the type-checker. We don't need to
+care of any time-stamps.  Since the parsed tree contains unique names
+anyway, like Lxxxxx, there is no chance of name clashes. Perhaps the
+synthesized constructor environment could be saved in the .cmo file
+(along with import and other such data)?
+
+*** A new idea
+
+In general, a code value should be a pair (ParseTree, CtorEnv).  An
+escape (splice) should merge the CtorEnv parts. So a code value is a
+closure with respect to a signature for type and data constructors. In
+a sense, lambda-a gives us that, if we consider type declarations as
+let-expressions (lambda-a has big lambda).
+
+Actually, OCaml 3.12 already has a similar facility: local open.
+So, a code value should be a parse tree expression of the form
+    let module M = struct 
+                    declaration of needed constructors, labels,
+		    exceptions
+                    let res = <expr>
+    in M.res
+Splice should merge such modules, performing renames in case
+of identically named constructors.
+
+See env.ml (and mtype.ml) for functions to export Env.t as a signature
+(and to merge an old signature with the current Env.t -- open).
+There is code for renaming and qualifying all identifiers by a path.
+So, when we generate the code for bracket, maintain the list of
+constructors used in the code. Then build the declarations.
+
+Since we won't store the env any more (as part of pexp_ext, ppat_ext),
+we don't need the lazy transformation of env.ml and we don't need
+to maintain extra time-stamps (which we currently do). The generated
+code becomes self-contained, with all needed constructors, which
+are explicit -- rather than hidden in *_ext fields.
+
+As the initial approximation, to make porting to OCaml 4, require
+that all constructors to be in separate modules (the corresponding
+.cmi must be available at run-time, and, properly, we should record
+their CRC). Later on, save the needed .cmi as part of the code (for
+native compilation). Later, we eliminate that restriction by
+building proper declarations. [BER MetaOCaml N100 implements this
+idea.]
+
+A code value should be a module, struct type t = ... let term = xxx
+end.  That nodule defines all type constructors/types that are used
+within the code, except for the built-ins or pervasives. We should
+define these types along with equalities (sharing constraints) so that
+the code and the main program use consistent types.That solves the
+problem of redeclarations (we introduce a nested struct).  Also, we
+automatically obtain the desired property that a code value is a
+closure with respect to the constructor env.
+
+type foo = Foo
+let x = <Foo>
+type bar = Foo
+let y = <Foo>
+
+type foo1 = Foo1
+let x = quote (struct type t1 = foo1 = Foo
+   let res = Foo end)
+
+It has to be a functor, from the env. We rely on contra-variance (env
+may contain many more types), Since the env should only contain
+types, its run-time representation is empty.  But splicing is a bit
+more expensive since we have to apply env. All identifiers in the env
+are alpha-renamed to contain the explicit tstamp.  The main benefit is
+that we don't need to modify the AST to contain the type env.
+
+An idea for the constructor calculus
+
+Datatype definitions can be represented in System Fw:
+        data T = Foo | Bar
+
+is equivalent to the type T, functions foo :: T and bar :: T and 
+the deconstructor T -> w -> w -> w. The body of the program in the scope of
+T can be represented as
+  Lam(t) lam(foo:t) lam(bar:t) lam(decon:forall w. t->w->w) ...
+
+Assume that Lam and lam are special in that they bind `special
+identifiers' (constructors) and that we can evaluate under such
+lam. If c is a special identifier, then c v is a value. (check CRWL; I
+think we don't need to do anything about not-fully-applied
+constructors, which are values anyway.)  We need Fw so we can bind
+types of the kind *->*, etc. needed for defining list-like types. The
+main advantage: we don't need to introduce constants, and we get the
+regular scoping, substitution rules. So, constants (constructors) and
+identifiers are pretty much the same, with respect to alpha renaming
+and substitution.  That simplifies the calculus as we introduce
+staging.
+
+
+** Other
+Think about moving the predefined type ('a,'b) code from
+typing/predef.ml[i] into trx.mli Do we really need the code type
+predefined? Can we consider it pervasive instead? There would be no
+need to modify typecore to add a special rule to process the code
+type.
+
+A conversation with Chung-chieh Shan brought up another issue:
+generalization is not at all clear staged languages. Consider
+    .<let f = fun x -> x in (f 1, f true)>.
+The code is OK. When we type-check it at level 0, we have to
+type-check the body of the bracket at level 1
+	   let f = fun x -> x in (f 1, f true)
+and it is certainly OK, since f is generalizable as being bound to a
+value. Now consider this:
+    .<let f = .~(.<fun x -> x>.) in (f 1, f true)>.
+Is this OK? MetaOCaml says yes. What about
+    .<let f = .~((fun y -> y) .<fun x -> x>.) in (f 1, f true)>.
+Now it does not generalize.
+For a good reason! The following, for example, generalizes
+let lift x = .<x>.;;
+let fff =
+	.<let foo = fun x -> let t = .~(lift (ref [])) in 
+	(match !t with [] -> t := [x]; x | [y] -> t := [x]; y) in
+	(foo ("xxx"), foo(true), foo([1,2]))>.;;
+and gives the Bus error. See more description and proposed restriction
+in the file Problems.txt, the entry as of June 11, 2010.
+
+Other interesting cases:
+let id y = y in .<let f = fun x -> id x in (f 1, f true)>.;;
+
+Interesting case:
+let id y = y in .<let f = fun x -> id y in (f 1, f true)>.;;
+let id y = y in .<let f = fun x -> id x in (f 1, f true)>.;;
+
+
+
+
+* Done in N004 (Nov 7, 2012)
+Check to see if val_level field in the value_description structure can
+be eliminated. Quite a few patches become unnecessary.  We should
+associate the staging level with identifiers rather than values.  We
+should introduce a new map in Env.t that maps identifiers to levels.
+Global identifiers and identifiers appearing in structures and
+signatures are not in the domain of that map and are implicitly
+0-level. We don't support module expressions in the staged code.
+
+We have done that.
+
+Adding a new Texp_ident (see typecore etc) should be accompanied by
+Env.add_level ident !global_level But we don't support staging for
+objects.
+
+Before
+
+# let x = 1 in .<x>.;;
+- : ('a, int) code = .<1>.
+# let x = [] in .<x>.;;
+- : ('a, 'b list) code = .<(* cross-stage persistent value (as id: x) *)>.
+# let x = None in .<x>.;;
+- : ('a, 'b option) code = .<(* cross-stage persistent value (as id: x) *)>.
+# let x = "abc" in .<x>.;;
+- : ('a, string) code = .<(* cross-stage persistent value (as id: x) *)>.
+# let x = 123l in .<x>.;;
+- : ('a, int32) code = .<(* cross-stage persistent value (as id: x) *)>.
+
+# .<Array.get>.;;
+- : ('a, 'b array -> int -> 'b) code = .<Array.get>.
+# .<List.nth>.;;
+- : ('a, 'b list -> int -> 'b) code =
+.<(* cross-stage persistent value (as id: List.nth) *)>.
+
+Now
+# let x = 1 in .<x>.;;
+- : ('a, int) code = .<1>.
+# let x = [] in .<x>.;;
+- : ('a, 'b list) code = .<(* cross-stage persistent value (as id: x) *)>.
+# let x = None in .<x>.;;
+- : ('a, 'b option) code = .<(* cross-stage persistent value (as id: x) *)>.
+# let x = "abc" in .<x>.;;
+- : ('a, string) code = .<"abc">.
+# let x = 123l in .<x>.;;
+- : ('a, int32) code = .<123>.
+# .<Array.get>.;;
+X: Stage for var is set to implicit 0:Array.get
+- : ('a, 'b array -> int -> 'b) code = .<Array.get>.
+# .<List.nth>.;;
+X: Stage for var is set to implicit 0:List.nth
+- : ('a, 'b list -> int -> 'b) code = .<List.nth>.
+
+More CSP are carried as literals. 
+
+When compiling code expressions, warnings should be disabled since
+they are not informative anyway.  See runcode.ml, the function
+with_disabled_warnings.
+
+
+* Done in N100 (January 2013)
+
+** trx.ml is re-written, and so most of the following has been taken
+care of
+
+In [old] trx.ml, check to see if ident_can_be_quoted and path_to_lid
+can be merged to a single function, following the idea that any path
+made of global/persistent components can be safely converted to lident
+(the time stamps are all zero anyway).  Any such path can be used to
+refer to a CSP by name, since that path persists and is stable. I
+guess it is also important that it is global: we can expect the same
+name available when we compile the code and when we invoke the
+type-checker again at run-time.
+
+In trx.ml, there are notes on CSP, in the comments before mkcsp.  If
+CSP id is long id, (global id), use it as a constant and generate the
+corresponding global ref code. Zero-arity constants such as [] or
+None, when used as CSP, can be included by value, and show as such
+when we print out the code values.  OCaml 3.11 adds annotations for
+identifiers (see typing/annot.mli and search for Annot in
+env.mli). Annot are used for the sake of .annot files. That data could
+be useful to identify CSP that refer to external or global
+identifiers.
+
+** Re-written trx.ml now does more efficient traversal, so most
+of the following has been taken care of
+
+It seems that there is a lot of room for improvement. For example,
+run compiles and type-checks the code expression from scratch.
+Mainly, Trx.structure pre-processes the whole program, each and every
+expression and definition -- even if an expression contains no
+staging forms. That pre-processing re-builds the whole parse tree,
+which is wasteful, and slows down compilation for large programs.
+We should hook escape and bracket processing to the type-checker -- to
+typecore.ml, and be done. We pay for staging only when needed.
+
+I have hooked Trx.trx_structure as a post-processor to
+Typemod.type_structure. Now, top-level drivers (toplevel/toploop.ml,
+driver/compile.ml) no longer have to be modified.  The function
+Typemod.type_structure traverses the whole structure expression,
+invoking typecore.type_exp and other functions.  But Trx.trx_structure
+does a very similar traversal! I have to think how to simplify
+unnecessary traversal and hook trx processing deeper, perhaps within
+typecore.type_exp and typecore.type_binding.  These are the only cases
+that matter...
+
+** Better quotation (which results in better printing of CSP *)
+# let l x = .<x>.;;
+val l : 'a -> ('cl, 'a) code = <fun>  (* Polymorphic! *)
+# l 1;;
+- : ('a, int) code = .<(* cross-stage persistent value (as id: x) *)>.
+# l 1.0;;
+- : ('a, float) code = .<1.>.   (* Now it prints as a constant *)
+
+** Record with polymorphic fields in brackets: problem solved
+
+A new way of running the code and its problems.  Actually, the
+problems are old -- the Trx module cannot handle polymorphic
+values. It erroneously fails to generalize type variables.  Here is
+the illustration of the bug.
+
+# .< {Trx.cde = .<1>.} >.;;
+- : ('a, int Trx.cde) code = .<{Trx.cde = .<1>.}>.
+# .! .< {Trx.cde = .<1>.} >.;;
+# .! .< {Trx.cde = .<1>.} >.;;
+This expression [1 is highlighted]
+has type ('a, int) code but is here used with type
+  ('b, int) code
+
+Exception: Trx.TypeCheckingError.
+
+Since the new way of running relies on the polymorphic values, the
+problem becomes acute.
+Compare:
+# let a1 = .<fun x -> .! .<1>.>.;;
+val a1 : ('a, 'b -> int) code = .<fun x_2 -> .!.<1>.>.
+# let a2 = .! a1;;
+val a2 : 'a -> int = <fun>
+# a2 42;;
+- : int = 1
+
+# let b1 = .<fun x -> Runcode.run {Trx.cde = .<1>.}>.;;
+val b1 : ('a, 'b -> int) code =
+  .<fun x_3 ->
+     (((* cross-stage persistent value (as id: Runcode.run) *))
+       {Trx.cde = .<1>.})>.
+# let b11 = {Trx.cde = b1 };;
+val b11 : ('a -> int) Trx.cde =
+  .<fun x_3 ->
+     (((* cross-stage persistent value (as id: Runcode.run) *))
+       {Trx.cde = .<1>.})>.
+
+# Runcode.run b11;;
+Warning X: this argument will not be used by the function.
+This expression has type ('a, int) code but is here used with type
+  ('b, int) code
+
+Exception: Trx.TypeCheckingError.
+
+Runcode re-typechecks the expression -- and here where the error comes
+in.
+
+One workaround: when trx pre-processes the code first-time around,
+it should detect {Trx.cde = xxx} that appears within quotation, and
+replace it with something else (Parsetree.exp?). After all, the
+type-checking has already happened; when the generated code is run, no
+real check are needed; so we can use the untyped Parsetree at will.
+
+I believe the problem is in the clause `Pexp_record(lid_sexp_list,
+opt_sexp)' of the function type_exp of the file typecore.ml. In the
+conditional branch of (is_type_exp_second_time sexp) being true, we
+may be missing generalization (or forget to introduce fresh type
+variables).
diff --git a/ber-metaocaml-101/ORIGINAL-LICENSE-META b/ber-metaocaml-101/ORIGINAL-LICENSE-META
new file mode 100644
index 0000000..52e97e2
--- /dev/null
+++ b/ber-metaocaml-101/ORIGINAL-LICENSE-META
@@ -0,0 +1,50 @@
+
+Copyright 2002-2006 
+Walid Taha's research group at Rice University and collaborators
+All Rights Reserved
+
+MetaOCaml is licensed as a patch to the respective distribution of
+OCaml upon which it is based.  Please see OCaml licence for status of
+a patch.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal with the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+Redistributions of source code must retain the above copyright notice,
+this list of conditions and the following disclaimers.
+
+ - Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimers in
+   the documentation and/or other materials provided with the
+   distribution.
+
+ - Neither the names of MetaOCaml, Concoqtion, Rice University, nor the
+   names of its contributors may be used to endorse or promote products
+   derived from this Software without specific prior written permission.
+
+ - Products derived from this software may not be called "MetaOCaml",
+   "MetaOCaml Concoqtion", "Concoqtion", or an extension of these names
+   without prior written permission from the RAP group.
+
+Commercial use is prohibited without prior written permission.
+
+Permissions must be granted by
+
+	Walid Taha (taha@rice.edu)
+	Department of Computer Science
+	Rice University, Houston, TX 77025.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT
+HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
+SOFTWARE.
+
diff --git a/ber-metaocaml-101/Problems.txt b/ber-metaocaml-101/Problems.txt
new file mode 100644
index 0000000..ec12cf2
--- /dev/null
+++ b/ber-metaocaml-101/Problems.txt
@@ -0,0 +1,208 @@
+			Open and closed problems
+
+June 11, 2010.
+
+While designing a counter-example, I was too
+successful. The counter-example worked, also for OCaml
+
+let lift x = .<x>.;;
+let fff =
+	.<let foo = fun x -> let t = .~(lift (ref [])) in 
+	(match !t with [] -> t := [x]; x | [y] -> t := [x]; y) in
+	(foo ("xxx"), foo(true), foo([1,2]))>.;;
+
+So, the future-stage lambda should not be considered unexpansive by
+default. We should check the body for escapes. In principle,
+we should also check for CSP -- however MetaOCaml, unlike the
+calculus of PEPM03 paper, permits CSP of only values rather than
+expressions. And we know that we can't have a polymorphic reference
+cell bound to an identifier or as a constant.
+So, we should declare expansive those future-stage lambda whose
+bodies contain expansive escapes (that is, escapes that are not
+manifest code constants such as <0>). We should be careful of multiple-levels
+though; the problem above occurs because ``polymorphic'' reference cell can
+be a value (once created), and can be lifted to code. So, we should
+conservatively regard as potentially expansive a future-stage lambda
+that has expansive escapes to any level.
+
+
+
+May 5, 2010
+Loading test/test21.ml in top-level works fine. However, compiling
+that file gives 
+  Fatal error: exception Invalid_argument("output_value: functional value")
+
+If we pass the flags -drawlambda -dinstr to the compiler, we observe
+that the constants "" and Pervasive.^ are accompanied with
+environments (which are probably useless in that case anyway).
+If the code file has nested modules, it seems the environemnt has
+functional values. Therefore, attempting to serialize such an
+environment fails.
+
+The permanent solution requires re-thinking of building parsetree at run-time
+(see quote_constant in trx.ml)
+We shouldn't probably attach environemnt to contants. Also, we should
+get rid of location information, which is not needed and can be
+confusing.
+
+
+It turns out that the environment indeed contains functional values.
+The patch from Fabrice Le Fessant (who faced a similar problem in
+JoCaml) helped.
+
+
+
+-- Older
+
+
+
+(* CSP issues *)
+let f = fun x -> .<x>.;;
+let a = .<fun y -> .~(f .<y>.)>.;;
+let b = .! a;;
+let c = b 56;;
+let d = .! c;;
+
+let f = fun x -> .<x>.;;
+let a = .<fun y -> .~(f .<.<y>.>.)>.;;
+let b = .! a;;
+let c = b 56;;
+let d = .! c;;
+
+let f = fun x -> .<x>.;;
+let a = .<fun y -> f y>.;;
+let f2 = .! a;;
+let a2 = .<fun y -> .~(f2 .<.<y>.>.)>.;;
+let b = .! a2;;
+let c = b 56;;
+let d = .! c;;
+
+
+(* Type synonyms/aliasing bug: *)
+-- Description: Pattern matching against a value whose type is a type
+synonym, while using the pattern alias (as s) results in a
+type-checking error when applying .! to a piece of code.
+
+-- The smallest example of this bug is:
+type vect = int * int;;
+type state = State of vect;;
+let f state = .<let (State d) as s = .~state in
+               let (u,v) = d in 34>.;;
+let c = f .<State (2,3)>. in .! c;;
+
+-- error: "This expression has type vect but is here used with type 'a * 'b"
+
+-- The piece of code where this exception is raised is the call to
+(type_expect) in the function type_let in typecore.ml.
+
+-- Suspected reasons: The type synonym 'vect' is not unified with 'a *
+'b, which it should be. The problem seems the way that we handle
+environments. When type-checking run, the (initial) environment in
+which it is type-checked does not seem to contain a binding for the
+type vect.
+
+-- General note: This problem seems to be an artifact of how we
+   implement environments. Perhaps we need to deal with these things
+   more systematically.
+
+
+Oct 3, 2006
+ printing of `record with expressions'
+ type recd = {f1 : int; f2 : string};;
+
+ let foo = .<let x = {f1=1; f2="a"} in
+            let y = {x with f1 = 2} in
+            y>.
+ ;;
+
+ produces the output
+  val foo : ('a, recd) code =
+   .<let x_3 = {f1 = 1; f2 = "a"} in let y_4 = {f1 = 2} (x_3) in y_4>.
+
+ The expression "{f1 = 2} (x_3)" obviously can't be right: a record is
+ not a function and can't be applied.
+
+ That is merely a printing issue:
+  .! foo;;
+   - : recd = {f1 = 2; f2 = "a"}
+
+ which is correct.
+
+
+Tue Jan 18 14:08:52 GMTST 2005
+  BUG: type aliases are not handled correctly in code, example:
+    # type a = int;;
+    # let f (x:a) = 1;;
+    # .! .<f 1>.;;
+    This expression has type int but is here used with type a
+  PROBLEM: the type of csp constants cannot resolve type aliases
+  FIX: when typing Pexp_cspval return a fresh variable so it will type
+    check in any situation
+
+Tue Jan 11 11:19:23 GMTST 2005
+  BUG: records, constructors etc are typed once and their type is reused, same
+    bug as on Jan 10 2005.
+  FIXED: when typing e.g. a record field access (Pexp_field) the stored type
+   is still used to get the label description (used by the compiler to compute
+   the offset for field access), but the toplevel type is not reused and a
+   fresh type variable is returned instead. In this way we avoid that several
+   runs of code coming from the same field access have their types unified.
+
+Mon Jan 10 18:51:21 GMTST 2005
+  BUG: csp constants in Pervasives (and similar) are type checked only once for
+  a given occurrence.
+   # let f x  = .< ref .~ x>.
+     in (.! (f .<3>.), .! (f .<1.3>.));;
+   This expression has type int but is here used with type float
+   Exception: Trx.TypeCheckingError.
+  PROBLEM: "ref" is typechecked only once when f is declared, and the resulting
+    type is used twice in the second line
+  FIXED: typing/typecore.ml now re-createx the untyped parsetree for the
+    Pervasive identifier and type-checks it again.
+
+Tue Jan 20 12:18:00 GMTST 2004
+  BUG: typechecker broken for csp ids, e.g. we get the wrong type
+  We get the incorrect typing (inner and outer code forced to be both 'a)
+   # .<fun x -> .<x>.>.;;
+   - : ('a, 'b -> ('a, 'b) code) code = .<fun (x_2) -> .<(x_2)>.>.    
+  PROBLEM: typechecker unifies the current level with the id's level left-to-right
+   but the latest classifier is the leftmost.
+  FIXED: levels are now unified right-to-left, and get correct type:
+    # .<fun x -> .<x>.>.;;
+    - : ('a, 'b -> ('c, 'b) code) code = .<fun (x_1) -> .<(x_1)>.>.
+
+Fri May 16 14:54:22 BST 2003
+  BUG: standalone bytecode compiling does not work with tag elimination
+       e.g. ./ocamlc toplevel/toplevellib.cma mex/evaletag.mk; ./a.out
+  PROBLEM: Tooploop.etag gets a typing error because timestamp of the code is in
+  the future (similar problem in the past with run)
+  FIXED: current timestamp bumped with the timestamp of the env passed to etag
+
+Mon Nov 25 18:24:28 GMT 2002
+  BUG: error typecore.ml: Texp_construct expected
+  PROBLEM: somehow typechecked made restrictive assuptions on the contents of the pexp_ext field for the case pPexp_construct
+  FIXED: assumptions relaxed 
+
+Mon Nov 25 10:10:32 GMT 2002
+  BUG: csp of array ops gives internal errors
+  PROBLEM: arrays are treated in a special way after typechecking phase, so replacing an op with a csp val of the op changes the semantics. Use ocamlc -dlambda to see how array ops are treated internally. 
+  FIXED: csp of array is rebuilt, like a Pervasives, so it's type-checked again, and the second phase of the compiler is happy.
+
+Thu Oct 24 09:55:36 BST 2002
+  BUG: csp at level n+2 gives Segmentation fault
+  PROBLEM: now Trx.mkcsp takes 2 args and not one, forgot to change cases
+  instvar and cspval at level n+1 accordingly
+  FIXED: cases instvar and cspvar at level n+1 now pass a second argument (None)
+
+Wed Oct  2 08:39:04 BST 2002
+  BUG: occurrences of a csp value share the same instantiated type
+  APPEARED: when treating Pervasives.* in a special way for performance. The
+  type of e.g. Pervasives.! is recorded in the extra field as an instantiated
+  type, so applications of the value cause unification.
+  BACKGROUND: values' types are closed schemas (all the identifiers are generic).
+  During type checking the types are instantiated. Instantiation is idempotent,
+  so one should always carry the schema somewhere. A typed expression exp such
+  that exp.exp_desc = Texp_ident (ident,value_description) has an instantiated
+  type in exp.exp_type and the type schema in value_description.val_type.
+  FIXED: Trx.trx creates a new instantiation for csp idents; Typecore.type_exp
+  re-instantiates the type schema when type-checking a cspval
diff --git a/ber-metaocaml-101/README b/ber-metaocaml-101/README
new file mode 100644
index 0000000..90d1828
--- /dev/null
+++ b/ber-metaocaml-101/README
@@ -0,0 +1,152 @@
+		BER MetaOCaml
+		N101 November 2013
+
+0. TABLE OF CONTENTS
+
+   1 Copyright 
+   2 Installation
+   3 Staging constructs
+   4 Restrictions and Common Problems
+   5 Detailed Discussion
+   6 Credits
+
+1. COPYRIGHT
+
+BER MetaOCaml is a complete re-implementation of MetaOCaml, 
+which was licensed according to ORIGINAL-LICENSE-META
+
+
+2. INSTALLATION
+
+  Please see the file INSTALL
+
+
+3. STAGING CONSTRUCTS
+   (This is a modified version of the section from the last
+    release of the original MetaOCaml, Feb 3, 2006)
+
+  The three new constructs are
+
+    bracket: .< e >.  to delay computation (to the future stage)
+    escape:  .~ e     to perform a computation within brackets
+                      and splice-in the result
+    run:     !. e     to run a future-stage computation, or code, now
+
+  A special type constructor, called 'code' builds the type of
+  future-stage computations, or code expressions. For example, 
+
+    # .< 2 + 4 >.;;
+    - : int code = .<2 + 4>. 
+
+  The type constructor 'code' takes as its argument the type of the
+  future-stage expression. Future-stage expressions are executed later,
+  but are type-checked now. Therefore, the generated code is assuredly
+  well-typed.
+
+  Code fragments can be spliced into larger code contexts by using the
+  escape construct: 
+
+    # let x = .< 2 + 4 >. in .< .~ x + .~ x >. ;;
+    - : int code = .<(2 + 4) + (2 + 4)>. 
+
+  The escape construct takes an expression of type (t code) and
+  produces an expression of type t, but only inside of a
+  code-constructing context (i.e., inside inside code brackets).
+  Attempting to escape code outside of a code-building context results
+  in the following type error:
+
+    # .~ .< 2 + 3 >.;;
+    Characters 0-14:
+    .~ .< 2 + 3 >.;;
+    ^^^^^^^^^^^^^^
+    Wrong level: escape at level 0
+
+
+  The run construct takes a code value, executes it and returns its result. 
+  It is actually an ordinary function Runcode.run, which is also bound 
+  to the prefix operation (!.). These operations are in the module
+  Runcode (which is not opened by default). For example: 
+
+    # Runcode.run .< 2 + 3 >.;;
+    - : int = 5
+    # open Runcode;;
+    # !. .<fun x y -> x + y >. 2 3;;
+    - : int = 5
+
+  The run construct only works on closed code values. Attempting to run
+  open code leads to an exception in the generator (which can be traced
+  as any other exception).
+
+    # .< fun x -> .~ (let u = !. .< x >. in .<()>.) >.;;
+    Exception:
+    Failure
+     "The code built at Characters 7-8:
+      .< fun x -> .~ (let u = !. .< x >. in .<()>.) >.;;
+             ^
+     is not closed: identifier x_91 bound at Characters 7-8:
+      .< fun x -> .~ (let u = !. .< x >. in .<()>.) >.;;
+             ^
+    is free".
+
+  Please see many more examples in test/trivial.ml and other files
+  in the test/ directory.
+
+
+4. RESTRICTIONS AND COMMON PROBLEMS
+
+   1. All data constructors and record labels used within brackets must
+   come from the types that are declared in separately compiled modules.
+   For example, the following works:
+       .<true>.                 (* data constructor is Pervasive *)
+       .<Some [1]>.             (* ditto                         *)
+       .<{Complex.re = 1.0; im = 2.0}>. (* The Record Complex is defined *)
+                                        (* in the standard library.      *)
+       open Complex                     (* which is separately complied  *)
+       .<{re = 1.0; im = 2.0}>.
+
+   But the following are not allowed and flagged as compile-time error:
+
+       type foo = Bar
+       .<Bar>.
+
+       module Foo = struct exception E end
+      .<raise Foo.E>.
+
+   The type declaration foo or the module declaration Foo must be
+   moved into a separate file. The corresponding .cmi file must also be
+   available at run-time: either placed into the same directory as
+   the executable, or somewhere within the OCaml library search
+   path.
+
+   2. Escaped expressions at the same level evaluate in the same
+   order as arguments in an application. For byte-code OCaml,
+   this order is RIGHT to left.
+
+   3. Objects and modules are not supported within brackets
+     (but you can use brackets within modules or objects).
+
+
+5. DETAILED DISCUSSION
+
+   For differences from the original MetaOCaml and further discussion,
+   see NOTES.txt.
+
+
+6. CREDITS
+
+  BER MetaOCaml is a complete re-implementation of the original MetaOCaml. 
+
+  The original MetaOCaml was funded primarily by an NSF project titled:
+
+	"ITR/SY(CISE): Putting Multi-Stage Annotations to Work"
+
+  That project was led by Walid Taha. Most of the original development
+  and implementation of staging was done by Cristiano
+  Calcagno, then at Imperial College. 
+  Edward Pizzi has implemented the pretty-printing of code -- which
+  since then has been extensively modified and maintained by 
+  Jacques Carette.
+  Xavier Leroy, INRIA, helped with the compiler specifics.
+
+  Many members of the metaocaml-users and metaocaml-hackers lists have
+  helped identify bugs and in some cases fixed them.
diff --git a/ber-metaocaml-101/berstart.ml b/ber-metaocaml-101/berstart.ml
new file mode 100644
index 0000000..785f79f
--- /dev/null
+++ b/ber-metaocaml-101/berstart.ml
@@ -0,0 +1,21 @@
+(*
+   To `run' the code we use toplevel facilities.
+   If we invoke BER MetaOcaml top level, then Toplevel.topstart() will
+   initalialize the top level.
+   If we execute a byte-compiled executable, we link with
+   the top-level library. But we need initialize it first.
+   This is the job of the current file.
+
+   This file must be linked in *before* the first user executable.
+
+   The present code roughly do the same steps OCaml top level does
+   when executing a script.
+   See Toplevel.topmain
+*)
+
+let () =
+  Toploop.set_paths ();
+  Compmisc.init_path true;
+  Toploop.initialize_toplevel_env ()
+  (* toplevel_env := Compile.initial_env();
+  *)
diff --git a/ber-metaocaml-101/bertop.ml b/ber-metaocaml-101/bertop.ml
new file mode 100644
index 0000000..b95fdac
--- /dev/null
+++ b/ber-metaocaml-101/bertop.ml
@@ -0,0 +1,26 @@
+(* `Plugin' for the OCaml top-level *)
+open Longident
+
+(* Install printers for code values *)
+let install_printers () =
+  Topdirs.dir_install_printer Format.std_formatter
+    (Ldot(Lident "Print_code", "print_code"));
+  Topdirs.dir_install_printer Format.std_formatter
+    (Ldot(Lident "Print_code", "print_closed_code"))
+
+(* Initialization function *)
+
+let initialize () =
+  Printf.printf "BER MetaOCaml toplevel, version %s\n" Trx.meta_version;
+  install_printers ()
+
+(* Hook up to the top level *)
+let () =
+Toploop.toplevel_startup_hook :=
+  let old_hook = !Toploop.toplevel_startup_hook in
+  fun () -> 
+    begin
+      initialize ();
+      old_hook ()
+    end
+
diff --git a/ber-metaocaml-101/build_patch.sh b/ber-metaocaml-101/build_patch.sh
new file mode 100644
index 0000000..f8f8bde
--- /dev/null
+++ b/ber-metaocaml-101/build_patch.sh
@@ -0,0 +1,47 @@
+#!/bin/sh
+# Building the patch set
+#    build_patch
+# This auxiliary file builds the patch set using the internal
+# GIT repository. The patch set is written into the standard output.
+
+cd ..
+
+#git diff 327f91b41f16b223c783070fa44058c5b1db8804 -- 
+git diff 4.01 -- \
+./.depend \
+./Makefile \
+./ocamldoc/Makefile \
+./parsing/lexer.mll \
+./parsing/parser.mly \
+./parsing/parsetree.mli \
+./parsing/printast.ml \
+./parsing/pprintast.ml \
+./parsing/ast_mapper.ml \
+./typing/typedtree.mli \
+./typing/typedtree.ml \
+./typing/predef.ml \
+./typing/predef.mli \
+./typing/printtyped.ml \
+./typing/typedtreeIter.ml \
+./typing/typedtreeMap.ml \
+./typing/env.mli \
+./typing/env.ml \
+./typing/envaux.ml \
+./typing/typecore.mli \
+./typing/typecore.ml \
+./typing/typemod.ml  \
+./bytecomp/lambda.ml \
+./bytecomp/lambda.mli \
+./bytecomp/printlambda.ml \
+./bytecomp/translcore.ml \
+./bytecomp/symtable.ml \
+./tools/depend.ml \
+./tools/dumpobj.ml \
+./tools/ocamlprof.ml \
+./tools/untypeast.ml \
+./tools/tast_iter.ml \
+./asmcomp/cmmgen.ml
+
+
+# svn diff -r5522 \
+# tools/addlabels.ml \
diff --git a/ber-metaocaml-101/metaocamlc.tpl b/ber-metaocaml-101/metaocamlc.tpl
new file mode 100755
index 0000000..049ce94
--- /dev/null
+++ b/ber-metaocaml-101/metaocamlc.tpl
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+# Multi-shell script.  Works under Bourne Shell, MPW Shell, zsh.
+
+if : == x
+then # Bourne Shell or zsh
+     exec %%BINDIR%%/ocamlc -I +compiler-libs ocamlcommon.cma ocamlbytecomp.cma ocamltoplevel.cma metalib.cma berstart.cmo "$@"
+else # MPW Shell
+     ocamlc -I +compiler-libs ocamlcommon.cma ocamlbytecomp.cma ocamltoplevel.cma metalib.cma berstart.cmo {"parameters"}
+     exit {status}
+End # uppercase E because "end" is a keyword in zsh
+fi
diff --git a/ber-metaocaml-101/metaocamlmktop.tpl b/ber-metaocaml-101/metaocamlmktop.tpl
new file mode 100644
index 0000000..290cf17
--- /dev/null
+++ b/ber-metaocaml-101/metaocamlmktop.tpl
@@ -0,0 +1,16 @@
+#!/bin/sh
+#########################################################################
+#                                                                       #
+#                                 OCaml                                 #
+#                                                                       #
+#            Damien Doligez, projet Para, INRIA Rocquencourt            #
+#                                                                       #
+#   Copyright 1999 Institut National de Recherche en Informatique et    #
+#   en Automatique.  All rights reserved.  This file is distributed     #
+#   under the terms of the Q Public License version 1.0.                #
+#                                                                       #
+#########################################################################
+
+# $Id$
+
+exec %%BINDIR%%/ocamlc -I +compiler-libs -linkall ocamlcommon.cma ocamlbytecomp.cma ocamltoplevel.cma metalib.cma bertop.cmo berstart.cmo "$@" topstart.cmo
diff --git a/ber-metaocaml-101/patches/patch b/ber-metaocaml-101/patches/patch
new file mode 100644
index 0000000..93880ef
--- /dev/null
+++ b/ber-metaocaml-101/patches/patch
@@ -0,0 +1,1236 @@
+diff --git a/.depend b/.depend
+index 50b6337..8c2483e 100644
+--- a/.depend
++++ b/.depend
+@@ -112,6 +112,8 @@ typing/printtyped.cmi : typing/typedtree.cmi
+ typing/stypes.cmi : typing/typedtree.cmi parsing/location.cmi \
+     typing/annot.cmi
+ typing/subst.cmi : typing/types.cmi typing/path.cmi typing/ident.cmi
++typing/trx.cmi : typing/typedtree.cmi parsing/parsetree.cmi \
++    parsing/longident.cmi parsing/location.cmi parsing/asttypes.cmi
+ typing/typeclass.cmi : typing/types.cmi typing/typedtree.cmi \
+     parsing/parsetree.cmi parsing/longident.cmi parsing/location.cmi \
+     typing/ident.cmi typing/env.cmi typing/ctype.cmi parsing/asttypes.cmi
+@@ -266,6 +268,16 @@ typing/subst.cmo : typing/types.cmi utils/tbl.cmi typing/path.cmi \
+ typing/subst.cmx : typing/types.cmx utils/tbl.cmx typing/path.cmx \
+     utils/misc.cmx parsing/location.cmx typing/ident.cmx typing/btype.cmx \
+     typing/subst.cmi
++typing/trx.cmo : utils/warnings.cmi typing/types.cmi typing/typedtree.cmi \
++    typing/typecore.cmi typing/printtyp.cmi typing/predef.cmi typing/path.cmi \
++    parsing/parsetree.cmi utils/misc.cmi parsing/longident.cmi \
++    parsing/location.cmi typing/ident.cmi typing/env.cmi typing/ctype.cmi \
++    typing/btype.cmi parsing/asttypes.cmi typing/trx.cmi
++typing/trx.cmx : utils/warnings.cmx typing/types.cmx typing/typedtree.cmx \
++    typing/typecore.cmx typing/printtyp.cmx typing/predef.cmx typing/path.cmx \
++    parsing/parsetree.cmi utils/misc.cmx parsing/longident.cmx \
++    parsing/location.cmx typing/ident.cmx typing/env.cmx typing/ctype.cmx \
++    typing/btype.cmx parsing/asttypes.cmi typing/trx.cmi
+ typing/typeclass.cmo : utils/warnings.cmi typing/typetexp.cmi \
+     typing/types.cmi typing/typedtree.cmi typing/typedecl.cmi \
+     typing/typecore.cmi typing/subst.cmi typing/stypes.cmi \
+@@ -332,7 +344,7 @@ typing/typedtreeMap.cmx : typing/typedtree.cmx utils/misc.cmx \
+     parsing/asttypes.cmi typing/typedtreeMap.cmi
+ typing/typemod.cmo : utils/warnings.cmi typing/typetexp.cmi typing/types.cmi \
+     typing/typedtree.cmi typing/typedecl.cmi typing/typecore.cmi \
+-    typing/typeclass.cmi typing/subst.cmi typing/stypes.cmi \
++    typing/typeclass.cmi typing/trx.cmi typing/subst.cmi typing/stypes.cmi \
+     typing/printtyp.cmi typing/path.cmi parsing/parsetree.cmi \
+     typing/mtype.cmi utils/misc.cmi parsing/longident.cmi \
+     parsing/location.cmi typing/includemod.cmi typing/ident.cmi \
+@@ -341,7 +353,7 @@ typing/typemod.cmo : utils/warnings.cmi typing/typetexp.cmi typing/types.cmi \
+     typing/typemod.cmi
+ typing/typemod.cmx : utils/warnings.cmx typing/typetexp.cmx typing/types.cmx \
+     typing/typedtree.cmx typing/typedecl.cmx typing/typecore.cmx \
+-    typing/typeclass.cmx typing/subst.cmx typing/stypes.cmx \
++    typing/typeclass.cmx typing/trx.cmx typing/subst.cmx typing/stypes.cmx \
+     typing/printtyp.cmx typing/path.cmx parsing/parsetree.cmi \
+     typing/mtype.cmx utils/misc.cmx parsing/longident.cmx \
+     parsing/location.cmx typing/includemod.cmx typing/ident.cmx \
+@@ -522,15 +534,15 @@ bytecomp/translclass.cmx : typing/types.cmx bytecomp/typeopt.cmx \
+     typing/btype.cmx parsing/asttypes.cmi bytecomp/translclass.cmi
+ bytecomp/translcore.cmo : utils/warnings.cmi typing/types.cmi \
+     bytecomp/typeopt.cmi typing/typedtree.cmi bytecomp/translobj.cmi \
+-    typing/primitive.cmi typing/predef.cmi typing/path.cmi \
+-    typing/parmatch.cmi utils/misc.cmi bytecomp/matching.cmi \
++    typing/printtyped.cmi typing/primitive.cmi typing/predef.cmi \
++    typing/path.cmi typing/parmatch.cmi utils/misc.cmi bytecomp/matching.cmi \
+     parsing/longident.cmi parsing/location.cmi bytecomp/lambda.cmi \
+     typing/ident.cmi typing/env.cmi utils/config.cmi utils/clflags.cmi \
+     typing/btype.cmi parsing/asttypes.cmi bytecomp/translcore.cmi
+ bytecomp/translcore.cmx : utils/warnings.cmx typing/types.cmx \
+     bytecomp/typeopt.cmx typing/typedtree.cmx bytecomp/translobj.cmx \
+-    typing/primitive.cmx typing/predef.cmx typing/path.cmx \
+-    typing/parmatch.cmx utils/misc.cmx bytecomp/matching.cmx \
++    typing/printtyped.cmx typing/primitive.cmx typing/predef.cmx \
++    typing/path.cmx typing/parmatch.cmx utils/misc.cmx bytecomp/matching.cmx \
+     parsing/longident.cmx parsing/location.cmx bytecomp/lambda.cmx \
+     typing/ident.cmx typing/env.cmx utils/config.cmx utils/clflags.cmx \
+     typing/btype.cmx parsing/asttypes.cmi bytecomp/translcore.cmi
+diff --git a/Makefile b/Makefile
+index 10c80d2..d3db812 100644
+--- a/Makefile
++++ b/Makefile
+@@ -19,6 +19,9 @@ CAMLC=boot/ocamlrun boot/ocamlc -nostdlib -I boot
+ CAMLOPT=boot/ocamlrun ./ocamlopt -nostdlib -I stdlib -I otherlibs/dynlink
+ COMPFLAGS=-strict-sequence -w +33..39 -warn-error A $(INCLUDES)
+ LINKFLAGS=
++# For debugging
++# COMPFLAGS=-warn-error A -g $(INCLUDES) # NNN
++# LINKFLAGS=-g #NNN
+ 
+ CAMLYACC=boot/ocamlyacc
+ YACCFLAGS=-v
+@@ -45,6 +48,7 @@ PARSING=parsing/location.cmo parsing/longident.cmo \
+   parsing/pprintast.cmo \
+   parsing/ast_mapper.cmo
+ 
++# NNN (trx)
+ TYPING=typing/ident.cmo typing/path.cmo \
+   typing/primitive.cmo typing/types.cmo \
+   typing/btype.cmo typing/oprint.cmo \
+@@ -57,6 +61,7 @@ TYPING=typing/ident.cmo typing/path.cmo \
+   typing/typedtreeIter.cmo typing/typedtreeMap.cmo typing/cmt_format.cmo \
+   typing/stypes.cmo typing/typecore.cmo \
+   typing/typedecl.cmo typing/typeclass.cmo \
++  typing/trx.cmo \
+   typing/typemod.cmo
+ 
+ COMP=bytecomp/lambda.cmo bytecomp/printlambda.cmo \
+@@ -117,7 +122,11 @@ defaultentry:
+ 
+ # Recompile the system using the bootstrap compiler
+ all: runtime ocamlc ocamllex ocamlyacc ocamltools library ocaml \
+-  otherlibraries ocamlbuild.byte $(CAMLP4OUT) $(DEBUGGER) ocamldoc
++	otherlibraries ocamlbuild.byte $(DEBUGGER) ocamldoc
++# NNNN  otherlibraries ocamlbuild.byte $(CAMLP4OUT) $(DEBUGGER) ocamldoc
++# NNN Since MetaOcaml is no binary compatible with OCaml, there is
++# no need to be rebuilding libraries
++# NNN make all && (cd metalib && make clean all) && (make install; cd metalib && make install)
+ 
+ # Compile everything the first time
+ world:
+@@ -288,6 +297,13 @@ install:
+ 	   $(COMPLIBDIR)
+ 	cp expunge $(LIBDIR)/expunge$(EXE)
+ 	cp toplevel/topdirs.cmi $(LIBDIR)
++# NNN typing/trx.ml needs its own interface (since it looks up identifiers
++# in itself)
++# Although typing/trx.cmi is already copied, see above, it is copied
++# into $((COMPLIBDIR). We need trx.cmi in the standard .cmi search path.
++	cp typing/trx.cmi $(LIBDIR)
++# BTW, trx.cmo is part of ocamlcommon.cma
++# NNN end
+ 	cd tools; $(MAKE) install
+ 	-cd man; $(MAKE) install
+ 	for i in $(OTHERLIBRARIES); do \
+diff --git a/asmcomp/cmmgen.ml b/asmcomp/cmmgen.ml
+index 01e2a61..c63d12d 100644
+--- a/asmcomp/cmmgen.ml
++++ b/asmcomp/cmmgen.ml
+@@ -2036,6 +2036,7 @@ and emit_constant_field field cont =
+       (Clabel_address lbl,
+        Cint(floatarray_header (List.length fields)) :: Cdefine_label lbl ::
+        Misc.map_end (fun f -> Cdouble f) fields cont)
++  | Const_csp_value _  -> assert false  (* NNN *)
+ 
+ and emit_string_constant s cont =
+   let n = size_int - 1 - (String.length s) mod size_int in
+diff --git a/bytecomp/lambda.ml b/bytecomp/lambda.ml
+index cfced85..cca6409 100644
+--- a/bytecomp/lambda.ml
++++ b/bytecomp/lambda.ml
+@@ -143,6 +143,7 @@ type structured_constant =
+   | Const_block of int * structured_constant list
+   | Const_float_array of string list
+   | Const_immstring of string
++  | Const_csp_value of Obj.t                   (* NNN: immediate CSP *)
+ 
+ type function_kind = Curried | Tupled
+ 
+diff --git a/bytecomp/lambda.mli b/bytecomp/lambda.mli
+index 17da073..dbcef13 100644
+--- a/bytecomp/lambda.mli
++++ b/bytecomp/lambda.mli
+@@ -143,6 +143,7 @@ type structured_constant =
+   | Const_block of int * structured_constant list
+   | Const_float_array of string list
+   | Const_immstring of string
++  | Const_csp_value of Obj.t                   (* NNN: immediate CSP *)
+ 
+ type function_kind = Curried | Tupled
+ 
+diff --git a/bytecomp/printlambda.ml b/bytecomp/printlambda.ml
+index 6531670..14bcf05 100644
+--- a/bytecomp/printlambda.ml
++++ b/bytecomp/printlambda.ml
+@@ -39,6 +39,8 @@ let rec struct_const ppf = function
+       let floats ppf fl =
+         List.iter (fun f -> fprintf ppf "@ %s" f) fl in
+       fprintf ppf "@[<1>[|@[%s%a@]|]@]" f1 floats fl
++  | Const_csp_value _ ->                        (* NNN *)
++      fprintf ppf "(CSP_value)"(* NNN; or use print_obj from tools/dumpobj.ml *)
+ 
+ let boxed_integer_name = function
+   | Pnativeint -> "nativeint"
+diff --git a/bytecomp/symtable.ml b/bytecomp/symtable.ml
+index 63374f8..f50d6ec 100644
+--- a/bytecomp/symtable.ml
++++ b/bytecomp/symtable.ml
+@@ -218,6 +218,7 @@ let rec transl_const = function
+       block
+   | Const_float_array fields ->
+       Obj.repr(Array.of_list(List.map (fun f -> float_of_string f) fields))
++  | Const_csp_value v -> v                                  (* NNN *)
+ 
+ (* Build the initial table of globals *)
+ 
+diff --git a/bytecomp/translcore.ml b/bytecomp/translcore.ml
+index 36b79da..a5a0907 100644
+--- a/bytecomp/translcore.ml
++++ b/bytecomp/translcore.ml
+@@ -881,6 +881,13 @@ and transl_exp0 e =
+           cl_loc = e.exp_loc;
+           cl_type = Cty_signature cty;
+           cl_env = e.exp_env }
++  | Texp_cspval (v,_) ->  Lconst(Const_csp_value v)         (* NNN *)
++  | Texp_escape _  | Texp_bracket _ ->                      (* NNN begin *)
++      Printtyped.implementation Format.err_formatter
++        {str_type = []; str_final_env = e.exp_env;
++         str_items = [{str_env = e.exp_env; str_loc = Location.none; 
++                       str_desc =Tstr_eval e}]};
++      fatal_error "Translcore.trans_exp with meta stuff"    (* NNN end *)
+ 
+ and transl_list expr_list =
+   List.map transl_exp expr_list
+diff --git a/ocamldoc/Makefile b/ocamldoc/Makefile
+index 144b95d..d7332cb 100644
+--- a/ocamldoc/Makefile
++++ b/ocamldoc/Makefile
+@@ -137,6 +137,7 @@ LIBCMOFILES=$(CMOFILES)
+ LIBCMXFILES= $(LIBCMOFILES:.cmo=.cmx)
+ LIBCMIFILES= $(LIBCMOFILES:.cmo=.cmi)
+ 
++# NNN add trx.ml and printtyped.cmo
+ # Les cmo et cmx de la distrib OCAML
+ OCAMLCMOFILES=$(OCAMLSRCDIR)/parsing/printast.cmo \
+ 	$(OCAMLSRCDIR)/typing/ident.cmo \
+@@ -178,7 +179,9 @@ OCAMLCMOFILES=$(OCAMLSRCDIR)/parsing/printast.cmo \
+ 	$(OCAMLSRCDIR)/typing/typeclass.cmo \
+ 	$(OCAMLSRCDIR)/typing/mtype.cmo \
+ 	$(OCAMLSRCDIR)/typing/includemod.cmo \
++	$(OCAMLSRCDIR)/typing/trx.cmo \
+ 	$(OCAMLSRCDIR)/typing/typemod.cmo \
++	$(OCAMLSRCDIR)/typing/printtyped.cmo \
+ 	$(OCAMLSRCDIR)/bytecomp/lambda.cmo \
+ 	$(OCAMLSRCDIR)/bytecomp/typeopt.cmo \
+ 	$(OCAMLSRCDIR)/bytecomp/printlambda.cmo \
+diff --git a/parsing/ast_mapper.ml b/parsing/ast_mapper.ml
+index 1584e2e..6cb65e9 100644
+--- a/parsing/ast_mapper.ml
++++ b/parsing/ast_mapper.ml
+@@ -319,6 +319,11 @@ module E = struct
+   let newtype ?loc a b = mk ?loc (Pexp_newtype (a, b))
+   let pack ?loc a = mk ?loc (Pexp_pack a)
+   let open_ ?loc a b c = mk ?loc (Pexp_open (a, b, c))
++  (* NNN begin *)
++  let bracket ?loc a = mk ?loc (Pexp_bracket a)
++  let escape ?loc a = mk ?loc (Pexp_escape a)
++  let cspval ?loc a b = mk ?loc (Pexp_cspval (a, b))
++  (* NNN end *)
+ 
+   let lid ?(loc = Location.none) lid = ident ~loc (mkloc (Longident.parse lid) loc)
+   let apply_nolabs ?loc f el = apply ?loc f (List.map (fun e -> ("", e)) el)
+@@ -360,6 +365,10 @@ module E = struct
+     | Pexp_newtype (s, e) -> newtype ~loc s (sub # expr e)
+     | Pexp_pack me -> pack ~loc (sub # module_expr me)
+     | Pexp_open (ovf, lid, e) -> open_ ~loc ovf (map_loc sub lid) (sub # expr e)
++  (* NNN through the end of the clause *)
++    | Pexp_bracket e -> bracket ~loc (sub # expr e)
++    | Pexp_escape e  -> escape  ~loc (sub # expr e)
++    | Pexp_cspval (v,lid)  -> cspval ~loc v (map_loc sub lid)
+ end
+ 
+ module P = struct
+diff --git a/parsing/lexer.mll b/parsing/lexer.mll
+index ae69b37..47a1e7b 100644
+--- a/parsing/lexer.mll
++++ b/parsing/lexer.mll
+@@ -255,6 +255,8 @@ let identchar_latin1 =
+   ['A'-'Z' 'a'-'z' '_' '\192'-'\214' '\216'-'\246' '\248'-'\255' '\'' '0'-'9']
+ let symbolchar =
+   ['!' '$' '%' '&' '*' '+' '-' '.' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~']
++let symbolcharnodot =                                                  (* NNN *)
++ ['!' '$' '%' '&' '*' '+' '-' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~'] (* NNN *)
+ let decimal_literal =
+   ['0'-'9'] ['0'-'9' '_']*
+ let hex_literal =
+@@ -277,6 +279,9 @@ rule token = parse
+       }
+   | blank +
+       { token lexbuf }
++  | ".<" { DOTLESS }     (* NNN *)
++  | ">." { GREATERDOT }  (* NNN *)
++  | ".~" { DOTTILDE }    (* NNN *)
+   | "_"
+       { UNDERSCORE }
+   | "~"
+@@ -431,8 +436,10 @@ rule token = parse
+             { PREFIXOP(Lexing.lexeme lexbuf) }
+   | ['~' '?'] symbolchar +
+             { PREFIXOP(Lexing.lexeme lexbuf) }
+-  | ['=' '<' '>' '|' '&' '$'] symbolchar *
++  | ['=' '<' '|' '&' '$'] symbolchar *	         (* NNN: ">." is not INFIXOP0 *)
+             { INFIXOP0(Lexing.lexeme lexbuf) }
++  | ['>'] symbolcharnodot symbolchar *           (* NNN exclude ">." case *)
++            { INFIXOP0(Lexing.lexeme lexbuf) }   (* NNN *)
+   | ['@' '^'] symbolchar *
+             { INFIXOP1(Lexing.lexeme lexbuf) }
+   | ['+' '-'] symbolchar *
+@@ -441,6 +448,8 @@ rule token = parse
+             { INFIXOP4(Lexing.lexeme lexbuf) }
+   | ['*' '/' '%'] symbolchar *
+             { INFIXOP3(Lexing.lexeme lexbuf) }
++  | "let" symbolchar*                            (* NNN *)
++            { LETOP(Lexing.lexeme lexbuf) }      (* NNN *)
+   | eof { EOF }
+   | _
+       { raise (Error(Illegal_character (Lexing.lexeme_char lexbuf 0),
+diff --git a/parsing/parser.mly b/parsing/parser.mly
+index 429d6be..d567a85 100644
+--- a/parsing/parser.mly
++++ b/parsing/parser.mly
+@@ -298,10 +298,25 @@ let wrap_type_annotation newtypes core_type body =
+   in
+   (exp, ghtyp(Ptyp_poly(newtypes,varify_constructors newtypes core_type)))
+ 
++    (* NNN: the whole definition *)
++let let_operator op bindings cont =
++  let pat, expr =
++    match List.rev bindings with
++    | []  -> assert false
++    | [x] -> x
++    | l   ->
++        let pats, exprs = List.split l in
++        ghpat (Ppat_tuple pats), ghexp (Pexp_tuple exprs)
++    in
++      mkexp(Pexp_apply(op, [("", expr); 
++                            ("", ghexp(Pexp_function("", None, [pat, cont])))]))
+ %}
+ 
+ /* Tokens */
+ 
++%token DOTLESS     /* NNN */
++%token GREATERDOT  /* NNN */
++%token DOTTILDE    /* NNN */
+ %token AMPERAMPER
+ %token AMPERSAND
+ %token AND
+@@ -365,6 +380,7 @@ let wrap_type_annotation newtypes core_type body =
+ %token LESS
+ %token LESSMINUS
+ %token LET
++%token <string> LETOP /* NNN */
+ %token <string> LIDENT
+ %token LPAREN
+ %token MATCH
+@@ -441,6 +457,7 @@ The precedences must be listed from low to high.
+ %nonassoc below_SEMI
+ %nonassoc SEMI                          /* below EQUAL ({lbl=...; lbl=...}) */
+ %nonassoc LET                           /* above SEMI ( ...; let ... in ...) */
++%nonassoc LETOP           /* NNN */
+ %nonassoc below_WITH
+ %nonassoc FUNCTION WITH                 /* below BAR  (match ... with ...) */
+ %nonassoc AND             /* above WITH (module rec A: SIG with ... and ...) */
+@@ -465,6 +482,7 @@ The precedences must be listed from low to high.
+ %nonassoc prec_unary_minus prec_unary_plus /* unary - */
+ %nonassoc prec_constant_constructor     /* cf. simple_expr (C versus C x) */
+ %nonassoc prec_constr_appl              /* above AS BAR COLONCOLON COMMA */
++%left	  prec_escape    /* NNN */
+ %nonassoc below_SHARP
+ %nonassoc SHARP                         /* simple_expr/toplevel_directive */
+ %nonassoc below_DOT
+@@ -968,6 +986,8 @@ expr:
+       { mkexp(Pexp_apply($1, List.rev $2)) }
+   | LET rec_flag let_bindings IN seq_expr
+       { mkexp(Pexp_let($2, List.rev $3, $5)) }
++  | let_operator let_bindings IN seq_expr     /* NNN */
++      { let_operator $1 $2 $4 }               /* NNN */
+   | LET MODULE UIDENT module_binding IN seq_expr
+       { mkexp(Pexp_letmodule(mkrhs $3 3, $4, $6)) }
+   | LET OPEN override_flag mod_longident IN seq_expr
+@@ -1076,6 +1096,10 @@ simple_expr:
+       { reloc_exp $2 }
+   | LPAREN seq_expr error
+       { unclosed "(" 1 ")" 3 }
++  | DOTLESS expr GREATERDOT                 /* NNN */
++      { mkexp(Pexp_bracket $2) }            /* NNN */
++  | DOTTILDE simple_expr %prec prec_escape  /* NNN */
++      { mkexp(Pexp_escape $2) }             /* NNN */
+   | BEGIN seq_expr END
+       { reloc_exp $2 }
+   | BEGIN END
+@@ -1705,6 +1729,7 @@ operator:
+   | INFIXOP2                                    { $1 }
+   | INFIXOP3                                    { $1 }
+   | INFIXOP4                                    { $1 }
++  | LETOP                                       { $1 } /* NNN */
+   | BANG                                        { "!" }
+   | PLUS                                        { "+" }
+   | PLUSDOT                                     { "+." }
+@@ -1720,6 +1745,15 @@ operator:
+   | AMPERAMPER                                  { "&&" }
+   | COLONEQUAL                                  { ":=" }
+ ;
++    /* NNN: the whole definition */
++let_operator:
++    LETOP                                   { mkexp (Pexp_ident(
++                                                     mkloc (Lident $1)
++                                                           (symbol_rloc ()))) }
++  | mod_longident DOT LETOP                 { mkexp (Pexp_ident(
++                                                     mkloc (Ldot($1,$3))
++                                                           (symbol_rloc ()))) }
++;
+ constr_ident:
+     UIDENT                                      { $1 }
+ /*  | LBRACKET RBRACKET                           { "[]" } */
+diff --git a/parsing/parsetree.mli b/parsing/parsetree.mli
+index ce6ac36..eed78cb 100644
+--- a/parsing/parsetree.mli
++++ b/parsing/parsetree.mli
+@@ -119,6 +119,9 @@ and expression_desc =
+   | Pexp_newtype of string * expression
+   | Pexp_pack of module_expr
+   | Pexp_open of override_flag * Longident.t loc * expression
++  | Pexp_bracket of expression (* NNN *)
++  | Pexp_escape of expression  (* NNN *)
++  | Pexp_cspval of Obj.t * Longident.t loc (* NNN *)
+ 
+ (* Value descriptions *)
+ 
+diff --git a/parsing/pprintast.ml b/parsing/pprintast.ml
+index 0965ca6..fdea70d 100644
+--- a/parsing/pprintast.ml
++++ b/parsing/pprintast.ml
+@@ -47,7 +47,9 @@ let fixity_of_string  = function
+   | _ -> `Normal
+ 
+ let view_fixity_of_exp = function
+-  | {pexp_desc = Pexp_ident {txt=Lident l;_};_} -> fixity_of_string l
++  | {pexp_desc = Pexp_ident {txt=Lident l}} -> fixity_of_string l
++  | {pexp_desc = Pexp_ident {txt=Ldot (Lident "Pervasives",l)}} 
++    -> fixity_of_string l
+   | _ -> `Normal  ;;
+ 
+ let is_infix  = function  | `Infix _ -> true | _  -> false
+@@ -632,6 +634,23 @@ class printer  ()= object(self:'self)
+           self#expression  e
+     | Pexp_variant (l,Some eo) ->
+         pp f "@[<2>`%s@;%a@]" l  self#simple_expr eo
++(* NNN through the end of the case *)
++    | Pexp_bracket (e) ->
++        pp f "@[<hov2>.<@ %a @ >.@]" self#expression e
++    | Pexp_escape (e) ->
++        let simple_exp = match e.pexp_desc with
++        | Pexp_ident (_) -> true
++        | _ -> false
++        in
++        pp f ".~%a" (self#paren simple_exp self#expression) e
++    | Pexp_cspval (v,li) ->
++      (* was: compiled code omitted
++         however, CSP values's are not always compiled code:
++           let f x = x in
++           let g   = .!.<fun x -> f x>. *)
++      pp f "(* cross-stage persistent value (id: %a) *)"
++          self#longident_loc li
++ (* NNN end *)
+     | _ -> self#expression1 f x
+   method expression1 f x =
+     match x.pexp_desc with
+diff --git a/parsing/printast.ml b/parsing/printast.ml
+index 22c68ee..caedb66 100644
+--- a/parsing/printast.ml
++++ b/parsing/printast.ml
+@@ -338,6 +338,15 @@ and expression i ppf x =
+       line i ppf "Pexp_open %a \"%a\"\n" fmt_override_flag ovf
+         fmt_longident_loc m;
+       expression i ppf e
++(* NNN through the end of the case *)
++  | Pexp_bracket (e) ->
++      line i ppf "Pexp_bracket\n";
++      expression i ppf e;
++  | Pexp_escape (e) ->
++      line i ppf "Pexp_escape\n";
++      expression i ppf e;
++  | Pexp_cspval (v,li) ->
++      line i ppf "Pexp_cspval <compiled_code> (as id: %a)" fmt_longident_loc li
+ 
+ and value_description i ppf x =
+   line i ppf "value_description %a\n" fmt_location x.pval_loc;
+diff --git a/tools/depend.ml b/tools/depend.ml
+index 328ca49..4a463f0 100644
+--- a/tools/depend.ml
++++ b/tools/depend.ml
+@@ -178,6 +178,10 @@ let rec add_expr bv exp =
+   | Pexp_newtype (_, e) -> add_expr bv e
+   | Pexp_pack m -> add_module bv m
+   | Pexp_open (_ovf, m, e) -> addmodule bv m; add_expr bv e
++(* NNN through the rest of the pattern-match *)
++  | Pexp_bracket e -> add_expr bv e
++  | Pexp_escape e  -> add_expr bv e
++  | Pexp_cspval _  -> ()
+ 
+ and add_pat_expr_list bv pel =
+   List.iter (fun (p, e) -> let bv = add_pattern bv p in add_expr bv e) pel
+diff --git a/tools/dumpobj.ml b/tools/dumpobj.ml
+index b2af788..4a4a9ef 100644
+--- a/tools/dumpobj.ml
++++ b/tools/dumpobj.ml
+@@ -104,6 +104,8 @@ let rec print_struct_const = function
+       printf "[|";
+       List.iter (fun f -> print_float f; printf "; ") a;
+       printf "|]"
++  | Const_csp_value obj ->                    (* NNN *)
++      printf "CSP_value"  (* print_obj obj *)    (* NNN *)
+ 
+ (* Print an obj *)
+ 
+diff --git a/tools/ocamlprof.ml b/tools/ocamlprof.ml
+index 72c9900..5cd2fcd 100644
+--- a/tools/ocamlprof.ml
++++ b/tools/ocamlprof.ml
+@@ -283,6 +283,9 @@ and rw_exp iflag sexp =
+   | Pexp_newtype (_, sexp) -> rewrite_exp iflag sexp
+   | Pexp_open (_ovf, _, e) -> rewrite_exp iflag e
+   | Pexp_pack (smod) -> rewrite_mod iflag smod
++(* NNN through the rest of the pattern-match *)
++  | Pexp_bracket e | Pexp_escape e -> rewrite_exp iflag e
++  | Pexp_cspval _ -> ()
+ 
+ and rewrite_ifbody iflag ghost sifbody =
+   if !instr_if && not ghost then
+diff --git a/tools/tast_iter.ml b/tools/tast_iter.ml
+index b02a4d2..dddd6c6 100644
+--- a/tools/tast_iter.ml
++++ b/tools/tast_iter.ml
+@@ -160,6 +160,9 @@ let expression sub exp =
+       sub # class_structure cl
+   | Texp_pack (mexpr) ->
+       sub # module_expr mexpr
++  | Texp_bracket e -> sub # expression exp  (* NNN *)
++  | Texp_escape e  -> sub # expression exp  (* NNN *)
++  | Texp_cspval (v,li) -> ()                (* NNN *)
+ 
+ 
+ let package_type sub pack =
+diff --git a/tools/untypeast.ml b/tools/untypeast.ml
+index 6cbbc55..29eaccf 100644
+--- a/tools/untypeast.ml
++++ b/tools/untypeast.ml
+@@ -289,6 +289,9 @@ and untype_expression exp =
+         Pexp_object (untype_class_structure cl)
+     | Texp_pack (mexpr) ->
+         Pexp_pack (untype_module_expr mexpr)
++    | Texp_bracket e -> Pexp_bracket (untype_expression e) (* NNN *)
++    | Texp_escape e  -> Pexp_escape (untype_expression e)  (* NNN *)
++    | Texp_cspval (v,li) -> Pexp_cspval (v,li)             (* NNN *)
+   in
+   List.fold_right untype_extra exp.exp_extra
+     { pexp_loc = exp.exp_loc;
+diff --git a/typing/env.ml b/typing/env.ml
+index 506975f..b23d416 100644
+--- a/typing/env.ml
++++ b/typing/env.ml
+@@ -98,6 +98,20 @@ end  = struct
+ 
+ end
+ 
++(* NNN added a new component of the environment: stage.
++   It maps a term variable to the staging level, 0 for the present stage.
++   It ued to be a list of type_expr -- actually, the list
++   of type variables, that is, env classifiers.
++   We only care about stage level for term variables.
++   Every key in the 'stage' map (the Ident) must occur in
++   the 'values' map.
++*)
++(* NNN
++  The current stage, 0 for the present stage.
++  It used to be a list of active classifiers, whose length
++  was the stage level of a variable.
++*)
++type stage = int	(* NNN *)
+ 
+ type summary =
+     Env_empty
+@@ -109,6 +123,7 @@ type summary =
+   | Env_class of summary * Ident.t * class_declaration
+   | Env_cltype of summary * Ident.t * class_type_declaration
+   | Env_open of summary * Path.t
++  | Env_stage of summary * Ident.t * stage (* NNN *)
+ 
+ module EnvTbl =
+   struct
+@@ -171,6 +186,7 @@ type t = {
+   classes: (Path.t * class_declaration) EnvTbl.t;
+   cltypes: (Path.t * class_type_declaration) EnvTbl.t;
+   summary: summary;
++  stage: (Path.t * stage) EnvTbl.t;		(* NNN *)
+   local_constraints: bool;
+   gadt_instances: (int * TypeSet.t ref) list;
+   in_signature: bool;
+@@ -183,6 +199,9 @@ and module_components_repr =
+     Structure_comps of structure_components
+   | Functor_comps of functor_components
+ 
++(* NNN there are no stage levels here: modules must occur at the 0 level.
++   No modules in brackets.
++*)
+ and structure_components = {
+   mutable comp_values: (string, (value_description * int)) Tbl.t;
+   mutable comp_constrs: (string, (constructor_description * int) list) Tbl.t;
+@@ -214,6 +233,7 @@ let empty = {
+   modules = EnvTbl.empty; modtypes = EnvTbl.empty;
+   components = EnvTbl.empty; classes = EnvTbl.empty;
+   cltypes = EnvTbl.empty;
++  stage = EnvTbl.empty;                 (* NNN *)
+   summary = Env_empty; local_constraints = false; gadt_instances = [];
+   in_signature = false;
+  }
+@@ -289,6 +309,7 @@ let check_consistency filename crcs =
+       (fun (name, crc) -> Consistbl.check crc_units name crc filename)
+       crcs
+   with Consistbl.Inconsistency(name, source, auth) ->
++    Printf.eprintf "failed check_consistency %s %s %s\n" name source auth; (* NNNN *)
+     raise(Error(Inconsistent_import(name, auth, source)))
+ 
+ (* Reading persistent structures from .cmi files *)
+@@ -425,6 +446,13 @@ and find_class =
+   find (fun env -> env.classes) (fun sc -> sc.comp_classes)
+ and find_cltype =
+   find (fun env -> env.cltypes) (fun sc -> sc.comp_cltypes)
++(* NNN there is no comp_stage since all modules are at stage 0 *)
++let find_stage path env =			(* NNN entire function *)
++  match path with
++  | Pident id -> 
++      let (p, data) = EnvTbl.find_same id env.stage
++      in data
++  | _         -> raise Not_found
+ 
+ let find_type p env =
+   fst (find_type_full p env)
+@@ -647,6 +675,9 @@ and lookup_class =
+   lookup (fun env -> env.classes) (fun sc -> sc.comp_classes)
+ and lookup_cltype =
+   lookup (fun env -> env.cltypes) (fun sc -> sc.comp_cltypes)
++(* NNN there is no comp_stage since all modules are at stage 0 *)
++let lookup_stage =			(* NNN *)
++  lookup_simple (fun env -> env.stage) (fun sc -> raise Not_found) (* NNN *)
+ 
+ let mark_value_used name vd =
+   try Hashtbl.find value_declarations (name, vd.val_loc) ()
+@@ -1255,6 +1286,11 @@ and store_cltype slot id path desc env renv =
+     cltypes = EnvTbl.add "class type" slot id (path, desc) env.cltypes
+                          renv.cltypes;
+     summary = Env_cltype(env.summary, id, desc) }
++and store_stage slot id path st env renv =     (* NNN whole clause *)
++  { env with
++    stage = EnvTbl.add "stage" slot id (path, st) env.stage renv.stage;
++    summary = Env_stage(env.summary, id, st) } (* NNN end *)
++
+ 
+ (* Compute the components of a functor application in a path. *)
+ 
+@@ -1300,6 +1336,9 @@ and add_class id ty env =
+ and add_cltype id ty env =
+   store_cltype None id (Pident id) ty env env
+ 
++let add_stage id st env =		        (* NNN *)
++  store_stage None id (Pident id) st env env    (* NNN *)
++
+ let add_local_constraint id info elv env =
+   match info with
+     {type_manifest = Some ty; type_newtype_level = Some (lv, _)} ->
+diff --git a/typing/env.mli b/typing/env.mli
+index 38d8cee..b070b79 100644
+--- a/typing/env.mli
++++ b/typing/env.mli
+@@ -14,6 +14,8 @@
+ 
+ open Types
+ 
++type stage = int        (* NNN; in N100 was type_expr list *)
++
+ type summary =
+     Env_empty
+   | Env_value of summary * Ident.t * value_description
+@@ -24,6 +26,7 @@ type summary =
+   | Env_class of summary * Ident.t * class_declaration
+   | Env_cltype of summary * Ident.t * class_type_declaration
+   | Env_open of summary * Path.t
++  | Env_stage of summary * Ident.t * stage (* NNN *)
+ 
+ type t
+ 
+@@ -51,6 +54,7 @@ val find_module: Path.t -> t -> module_type
+ val find_modtype: Path.t -> t -> modtype_declaration
+ val find_class: Path.t -> t -> class_declaration
+ val find_cltype: Path.t -> t -> class_type_declaration
++val find_stage: Path.t -> t -> stage	(* NNN *)
+ 
+ val find_type_expansion:
+     ?level:int -> Path.t -> t -> type_expr list * type_expr * int option
+@@ -80,6 +84,7 @@ val lookup_module: Longident.t -> t -> Path.t * module_type
+ val lookup_modtype: Longident.t -> t -> Path.t * modtype_declaration
+ val lookup_class: Longident.t -> t -> Path.t * class_declaration
+ val lookup_cltype: Longident.t -> t -> Path.t * class_type_declaration
++val lookup_stage: Longident.t -> t -> Path.t * stage (* NNN *)
+ 
+ exception Recmodule
+   (* Raise by lookup_module when the identifier refers
+@@ -97,6 +102,7 @@ val add_modtype: Ident.t -> modtype_declaration -> t -> t
+ val add_class: Ident.t -> class_declaration -> t -> t
+ val add_cltype: Ident.t -> class_type_declaration -> t -> t
+ val add_local_constraint: Ident.t -> type_declaration -> int -> t -> t
++val add_stage: Ident.t -> stage -> t -> t (* NNN *)
+ 
+ (* Insertion of all fields of a signature. *)
+ 
+diff --git a/typing/envaux.ml b/typing/envaux.ml
+index 5e8b524..aef8811 100644
+--- a/typing/envaux.ml
++++ b/typing/envaux.ml
+@@ -71,6 +71,8 @@ let rec env_from_summary sum subst =
+               raise (Error (Module_not_found path'))
+           in
+           Env.open_signature Asttypes.Override path' (extract_sig env mty) env
++      | Env_stage(s, id, st) ->                           (* NNN *)
++          Env.add_stage id st (env_from_summary s subst)  (* NNN *)
+     in
+       Hashtbl.add env_cache (sum, subst) env;
+       env
+diff --git a/typing/predef.ml b/typing/predef.ml
+index e4e96d2..fa7e97a 100644
+--- a/typing/predef.ml
++++ b/typing/predef.ml
+@@ -108,6 +108,18 @@ and ident_nil = ident_create "[]"
+ and ident_cons = ident_create "::"
+ and ident_none = ident_create "None"
+ and ident_some = ident_create "Some"
++
++
++(* NNN ident_create "code" must be placed at the end of all other
++   ident creation expressions, to make sure that creating ident_code
++   does not shift the timestamps of other standard idents like 
++   Eof, etc. Otherwise, binary compatibility with OCaml breaks,
++   and we have to do expensive bootstrapping.
++*)
++let ident_code = ident_create "code"    (* NNN *)
++let path_code  = Pident ident_code      (* NNN *)
++let type_code t = newgenty (Tconstr(path_code, [t], ref Mnil)) (* NNN *)
++
+ let build_initial_env add_type add_exception empty_env =
+   let decl_bool =
+     {decl_abstr with
+@@ -152,6 +164,13 @@ let build_initial_env add_type add_exception empty_env =
+      type_params = [tvar];
+      type_arity = 1;
+      type_variance = [Variance.covariant]}
++ (* NNN added decl_code *)
++  and decl_code =
++    let tvar = newgenvar() in
++    {decl_abstr with
++     type_params = [tvar];
++     type_arity = 1;
++     type_variance = [Variance.covariant]}
+   in
+ 
+   let add_exception id l =
+@@ -171,6 +190,7 @@ let build_initial_env add_type add_exception empty_env =
+                          [newgenty (Ttuple[type_string; type_int; type_int])] (
+   add_exception ident_undefined_recursive_module
+                          [newgenty (Ttuple[type_string; type_int; type_int])] (
++  add_type ident_code decl_code (       (* NNN *)
+   add_type ident_int64 decl_abstr (
+   add_type ident_int32 decl_abstr (
+   add_type ident_nativeint decl_abstr (
+@@ -186,7 +206,7 @@ let build_initial_env add_type add_exception empty_env =
+   add_type ident_string decl_abstr (
+   add_type ident_char decl_abstr (
+   add_type ident_int decl_abstr (
+-    empty_env)))))))))))))))))))))))))))
++    empty_env))))))))))))))))))))))))))) ) (* NNN extra parenthesis *)
+ 
+ let builtin_values =
+   List.map (fun id -> Ident.make_global id; (Ident.name id, id))
+diff --git a/typing/predef.mli b/typing/predef.mli
+index a2f4724..610e233 100644
+--- a/typing/predef.mli
++++ b/typing/predef.mli
+@@ -28,6 +28,7 @@ val type_nativeint: type_expr
+ val type_int32: type_expr
+ val type_int64: type_expr
+ val type_lazy_t: type_expr -> type_expr
++val type_code:   type_expr -> type_expr (* NNN *)
+ 
+ val path_int: Path.t
+ val path_char: Path.t
+@@ -44,6 +45,7 @@ val path_nativeint: Path.t
+ val path_int32: Path.t
+ val path_int64: Path.t
+ val path_lazy_t: Path.t
++val path_code: Path.t  (* NNN *)
+ 
+ val path_match_failure: Path.t
+ val path_assert_failure : Path.t
+diff --git a/typing/printtyped.ml b/typing/printtyped.ml
+index 840a767..76b8615 100644
+--- a/typing/printtyped.ml
++++ b/typing/printtyped.ml
+@@ -353,6 +353,15 @@ and expression i ppf x =
+   | Texp_pack me ->
+       line i ppf "Pexp_pack";
+       module_expr i ppf me
++        (* NNN: through the rest of the expression *)
++  | Texp_bracket e ->
++      line i ppf "Pexp_bracket";
++      expression i ppf e;
++  | Texp_escape e ->
++      line i ppf "Pexp_escape";
++      expression i ppf e;
++  | Texp_cspval (_, li) ->
++      line i ppf "Pexp_cspval %a\n" fmt_longident li
+ 
+ and value_description i ppf x =
+   line i ppf "value_description\n";
+diff --git a/typing/typecore.ml b/typing/typecore.ml
+index cccaff6..672c8df 100644
+--- a/typing/typecore.ml
++++ b/typing/typecore.ml
+@@ -63,6 +63,7 @@ type error =
+   | Recursive_local_constraint of (type_expr * type_expr) list
+   | Unexpected_existential
+   | Unqualified_gadt_pattern of Path.t * string
++  | Trx_error of (Format.formatter -> unit)               (* NNN *)
+ 
+ exception Error of Location.t * Env.t * error
+ 
+@@ -88,6 +89,81 @@ let type_object =
+        Env.t -> Location.t -> Parsetree.class_structure ->
+          Typedtree.class_structure * Types.class_signature * string list)
+ 
++(* NNN: begin
++  The current stage level.
++  Type-checking the body of a bracket increases the level
++  type-checking of an escape decreases.
++  Be sure to reset upon any exception;
++  alternatively; reset when beginning a new type-level
++  expression or binding
++  (whenever you do Typetexp.reset_type_variables();)
++
++ Check all instances of Env.add_value amd make sure that
++ we record the stage of every identifier that is added to the
++ value env (unless the stage is 0).
++*)
++let global_stage : Env.stage ref  = ref 0
++
++(* Obsolete; kept for reference 
++
++  The list of active classifiers. The length of the list
++  is the level of an expression.
++  Type-checking the body of a bracket adds a type variable
++  to the list; type-checking of an escape removes the
++  top-most classifier.
++  Be sure to reset this list upon any exception;
++  alternatively; reset the list when beginning a new type-level
++  expression or binding
++  (whenever you do Typetexp.reset_type_variables();)
++
++let global_stage : Env.stage ref  = ref []
++
++   Unify classifier lists, *right-to-left*
++   See the bug Tue Jan 20 12:18:00 GMTST 2004 in XXCC-BUG-OPEN-FIXED
++   why we need this order.
++   The current classifier is left-most, and the lists don't have
++   to have the same length.
++   Example:
++   .<fun x -> .< x >. >.
++   When type-checking the innermost bracket, the global_stage
++   will contain ['b,'a] and the level of x will be ['a]
++   The unification will succeed, without changing anything, as expected.
++
++let unify_stage env tl1 tl2 =
++   let rec loop = function
++   | (t1::tl1,t2::tl2) -> unify env t1 t2; loop (tl1,tl2)
++   | _ -> ()
++   in loop (List.rev tl1, List.rev tl2)
++*)
++open Format
++
++let raise_wrong_stage_error loc env n m =
++  raise (Error(loc, env, Trx_error (fun ppf ->
++	fprintf ppf 
++         "Wrong level: variable bound at level %d and used at level %d" n m)))
++
++let with_stage_up body =
++   let old_stage = !global_stage in
++   let () = incr global_stage in
++   try 
++    let r = body () in
++    global_stage := old_stage; r
++   with e ->
++   global_stage := old_stage; raise e
++
++let with_stage_down loc env body =
++   let old_stage = !global_stage in
++   if !global_stage = 0 then
++     raise (Error (loc, env, Trx_error (fun ppf ->
++       fprintf ppf "Wrong level: escape at level 0")));
++   decr global_stage;
++   try 
++    let r = body () in
++    global_stage := old_stage; r
++   with e ->
++   global_stage := old_stage; raise e
++(* NNN end *)
++
+ (*
+   Saving and outputting type information.
+   We keep these function names short, because they have to be
+@@ -150,6 +226,8 @@ let iter_expression f e =
+     | Pexp_letmodule (_, me, e) -> expr e; module_expr me
+     | Pexp_object { pcstr_fields = fs } -> List.iter class_field fs
+     | Pexp_pack me -> module_expr me
++    | Pexp_bracket e | Pexp_escape e -> expr e (* NNN *)
++    | Pexp_cspval (_, _) -> ()                 (* NNN *)
+ 
+   and module_expr me =
+     match me.pmod_desc with
+@@ -1170,13 +1248,16 @@ let rec iter3 f lst1 lst2 lst3 =
+   | _ ->
+       assert false
+ 
++
+ let add_pattern_variables ?check ?check_as env =
+   let pv = get_ref pattern_variables in
+   (List.fold_right
+      (fun (id, ty, name, loc, as_var) env ->
+        let check = if as_var then check_as else check in
++       Env.add_stage id !global_stage ( (* NNN *)
+        Env.add_value ?check id
+          {val_type = ty; val_kind = Val_reg; Types.val_loc = loc} env
++       )                                              (* NNN *)
+      )
+      pv env,
+    get_ref module_variables)
+@@ -1216,6 +1297,9 @@ let type_class_arg_pattern cl_num val_env met_env l spat =
+            else Warnings.Unused_var_strict s in
+          let id' = Ident.create (Ident.name id) in
+          ((id', name, id, ty)::pv,
++	  (* NNN we don't do Env.add_stage id' 0
++	     since we don't handle classes within brackets.
++	   *)
+           Env.add_value id' {val_type = ty;
+                              val_kind = Val_ivar (Immutable, cl_num);
+                              Types.val_loc = loc;
+@@ -1243,6 +1327,10 @@ let type_self_pattern cl_num privty val_env met_env par_env spat =
+   pattern_variables := [];
+   let (val_env, met_env, par_env) =
+     List.fold_right
++	  (* NNN we don't do Env.add_stage id 0 for all
++	     Env.add_value below
++	     since we don't handle classes within brackets.
++	   *)
+       (fun (id, ty, name, loc, as_var) (val_env, met_env, par_env) ->
+          (Env.add_value id {val_type = ty;
+                             val_kind = Val_unbound;
+@@ -1339,6 +1427,8 @@ let rec is_nonexpansive exp =
+       is_nonexpansive_mod mexp && is_nonexpansive e
+   | Texp_pack mexp ->
+       is_nonexpansive_mod mexp
++  | Texp_bracket e -> is_nonexpansive e     (* NNN *)
++  | Texp_escape e  -> is_nonexpansive e     (* NNN *)
+   | _ -> false
+ 
+ and is_nonexpansive_mod mexp =
+@@ -1795,6 +1885,9 @@ let duplicate_ident_types loc caselist env =
+            I don't think this is what we want *)
+         let (path, desc) = Env.lookup_value (Longident.Lident s) env in
+         match path with
++        (* NNN since id is already known in the Env, its stage is
++           already recorded.
++         *)
+           Path.Pident id ->
+             let desc = {desc with val_type = correct_levels desc.val_type} in
+             Env.add_value id desc env
+@@ -1845,6 +1938,11 @@ and type_expect_ ?in_function env sexp ty_expected =
+           let name = Path.name ~paren:Oprint.parenthesized_ident path in
+           Stypes.record (Stypes.An_ident (loc, name, annot))
+         end;
++        let stage =				(* NNN begin *)
++              try snd (Env.lookup_stage lid.txt env)
++              with Not_found -> 0
++        in                                      (* NNN end *)
++	(* unify_stage env stage !global_stage;	 NNN old *)
+         rue {
+           exp_desc =
+             begin match desc.val_kind with
+@@ -1864,9 +1962,13 @@ and type_expect_ ?in_function env sexp ty_expected =
+             | Val_unbound ->
+                 raise(Error(loc, env, Masked_instance_variable lid.txt))
+             | _ ->
++              if stage > !global_stage then                          (* NNN *)
++                 raise_wrong_stage_error loc env stage !global_stage (* NNN *)
++	      else                                                   (* NNN *)
+                 Texp_ident(path, lid, desc)
+           end;
+           exp_loc = loc; exp_extra = [];
++(* NNN:  Instantiates type scheme to a type *)
+           exp_type = instance env desc.val_type;
+           exp_env = env }
+       end
+@@ -2026,6 +2128,51 @@ and type_expect_ ?in_function env sexp ty_expected =
+         exp_loc = loc; exp_extra = [];
+         exp_type = ty_res;
+         exp_env = env }
++
++       (* NNN:  Typechecking bracket *)
++       (* follow Pexp_array or Pexp_lazy as a template *)
++       (* Expected type: ty code where ty is the type
++          of the expression within brackets.
++        *)
++  | Pexp_bracket(sexp) ->   
++      let ty = newgenvar() in     (* expected type for the bracketed sexp *)
++      let to_unify = Predef.type_code ty in
++      unify_exp_types loc env to_unify ty_expected;
++      with_stage_up (fun () ->
++      let exp = type_expect env sexp ty in
++        re { 
++          exp_desc = Texp_bracket(exp);
++          exp_loc = loc; exp_extra = [];
++          exp_type = instance env ty_expected;
++          exp_env = env })
++       (* NNN:  Typechecking escapes *)
++       (* If ~e is expected to have the type ty then
++          e is expected to have the type ty code
++        *)
++  | Pexp_escape(sexp) ->    
++      with_stage_down loc env (fun () ->
++       let sexp_ty_expected = Predef.type_code ty_expected in
++       let exp = type_expect env sexp sexp_ty_expected in
++       re { 
++         exp_desc = Texp_escape(exp);
++         exp_loc = loc; exp_extra = [];
++         exp_type = instance env ty_expected;
++         exp_env = env })
++       (* The rule says that CSP can have any desired type.
++          Pexp_cspval nodes are added only by the builder of
++          code expressions, by the builder of AST in trx.ml
++         At that time we know that the expression that gave
++         rise to CSP had the correct type. Therefore, we trust
++         that the type was correct the first time around.
++         The second argument, li, is used for identification only.
++        *)
++  | Pexp_cspval(obj,li) ->
++     re { 
++        exp_desc = Texp_cspval(obj,li);
++        exp_loc = loc; exp_extra = [];
++        exp_type = instance env ty_expected;
++        exp_env = env }
++       (* NNN end *)
+   | Pexp_match(sarg, caselist) ->
+       begin_def ();
+       let arg = type_exp env sarg in
+@@ -2277,6 +2424,8 @@ and type_expect_ ?in_function env sexp ty_expected =
+           val_kind = Val_reg; Types.val_loc = loc; } env
+           ~check:(fun s -> Warnings.Unused_for_index s)
+       in
++      let (id, new_env) =				  (* NNN *)
++          (id, Env.add_stage id !global_stage new_env) in (* NNN *)
+       let body = type_statement new_env sbody in
+       rue {
+         exp_desc = Texp_for(id, param, low, high, dir, body);
+@@ -2425,6 +2574,10 @@ and type_expect_ ?in_function env sexp ty_expected =
+                   let (obj_ty, res_ty) = filter_arrow env method_type "" in
+                   unify env obj_ty desc.val_type;
+                   unify env res_ty (instance env typ);
++                  (* NNN Texp_ident should've been accompanied by
++		     Env.add_level id !global_level
++		     But we don't support staging for objects.
++		   *)
+                   let exp =
+                     Texp_apply({exp_desc =
+                                 Texp_ident(Path.Pident method_id, lid,
+@@ -2495,6 +2648,9 @@ and type_expect_ ?in_function env sexp ty_expected =
+               exp_env = env }
+         end
+   | Pexp_setinstvar (lab, snewval) ->
++      if !global_stage != 0 then                                      (* NNN *)
++        raise (Error (loc, env, Trx_error (fun ppf ->                 (* NNN *)
++          fprintf ppf "Setinstvar not supported within brackets")));  (* NNN *)
+       begin try
+         let (path, desc) = Env.lookup_value (Longident.Lident lab.txt) env in
+         match desc.val_kind with
+@@ -2518,6 +2674,9 @@ and type_expect_ ?in_function env sexp ty_expected =
+           raise(Error(loc, env, Unbound_instance_variable lab.txt))
+       end
+   | Pexp_override lst ->
++      if !global_stage != 0 then                                    (* NNN *)
++        raise (Error (loc, env, Trx_error (fun ppf ->               (* NNN *)
++          fprintf ppf "Override not supported within brackets")));  (* NNN *)
+       let _ =
+        List.fold_right
+         (fun (lab, _) l ->
+@@ -2555,6 +2714,9 @@ and type_expect_ ?in_function env sexp ty_expected =
+           assert false
+       end
+   | Pexp_letmodule(name, smodl, sbody) ->
++      if !global_stage != 0 then                                    (* NNN *)
++        raise (Error (loc, env, Trx_error (fun ppf ->               (* NNN *)
++          fprintf ppf "Letmodule not supported within brackets"))); (* NNN *)
+       let ty = newvar() in
+       (* remember original level *)
+       begin_def ();
+@@ -2846,6 +3008,10 @@ and type_argument env sarg ty_expected' ty_expected =
+       unify_exp env {texp with exp_type = ty_fun} ty_expected;
+       if args = [] then texp else
+       (* eta-expand to avoid side effects *)
++      (* NNN Every Texp_ident below should've been accompanied by
++	 Env.add_stage. But we don't support staging for
++	 optional and named parameters.
++       *)
+       let var_pair name ty =
+         let id = Ident.create name in
+         {pat_desc = Tpat_var (id, mknoloc name); pat_type = ty;pat_extra=[];
+@@ -3438,6 +3604,7 @@ and type_let ?(check = fun s -> Warnings.Unused_var s)
+ 
+ let type_binding env rec_flag spat_sexp_list scope =
+   Typetexp.reset_type_variables();
++  global_stage := 0;			(* NNN *)
+   let (pat_exp_list, new_env, unpacks) =
+     type_let
+       ~check:(fun s -> Warnings.Unused_value_declaration s)
+@@ -3455,6 +3622,7 @@ let type_let env rec_flag spat_sexp_list scope =
+ 
+ let type_expression env sexp =
+   Typetexp.reset_type_variables();
++  global_stage := 0;			(* NNN *)
+   begin_def();
+   let exp = type_exp env sexp in
+   end_def();
+@@ -3667,6 +3835,8 @@ let report_error env ppf = function
+       fprintf ppf "@[The GADT constructor %s of type %a@ %s.@]"
+         name path tpath
+         "must be qualified in this pattern"
++(* NNN through the end of the pattern-match *)
++  | Trx_error fn -> fn ppf              (* NNN *)
+ 
+ let report_error env ppf err =
+   wrap_printing_env env (fun () -> report_error env ppf err)
+diff --git a/typing/typecore.mli b/typing/typecore.mli
+index 0c6bdd0..2f87dc1 100644
+--- a/typing/typecore.mli
++++ b/typing/typecore.mli
+@@ -105,6 +105,7 @@ type error =
+   | Recursive_local_constraint of (type_expr * type_expr) list
+   | Unexpected_existential
+   | Unqualified_gadt_pattern of Path.t * string
++  | Trx_error of (Format.formatter -> unit)               (* NNN *)
+ 
+ exception Error of Location.t * Env.t * error
+ 
+diff --git a/typing/typedtree.ml b/typing/typedtree.ml
+index 405e56b..74ad6aa 100644
+--- a/typing/typedtree.ml
++++ b/typing/typedtree.ml
+@@ -100,6 +100,10 @@ and expression_desc =
+   | Texp_lazy of expression
+   | Texp_object of class_structure * string list
+   | Texp_pack of module_expr
++(* NNN through the rest of the definition of expression *)
++  | Texp_bracket of expression
++  | Texp_escape of expression
++  | Texp_cspval of Obj.t * Longident.t loc
+ 
+ and meth =
+     Tmeth_name of string
+diff --git a/typing/typedtree.mli b/typing/typedtree.mli
+index a263c90..8c3d237 100644
+--- a/typing/typedtree.mli
++++ b/typing/typedtree.mli
+@@ -99,6 +99,10 @@ and expression_desc =
+   | Texp_lazy of expression
+   | Texp_object of class_structure * string list
+   | Texp_pack of module_expr
++(* NNN through the rest of the definition of expression *)
++  | Texp_bracket of expression
++  | Texp_escape of expression
++  | Texp_cspval of Obj.t * Longident.t loc
+ 
+ and meth =
+     Tmeth_name of string
+diff --git a/typing/typedtreeIter.ml b/typing/typedtreeIter.ml
+index 4280826..0badaf6 100644
+--- a/typing/typedtreeIter.ml
++++ b/typing/typedtreeIter.ml
+@@ -322,6 +322,10 @@ module MakeIterator(Iter : IteratorArgument) : sig
+             iter_class_structure cl
+         | Texp_pack (mexpr) ->
+             iter_module_expr mexpr
++        (* NNN: through the rest of the expression *)
++        | Texp_bracket exp -> iter_expression exp
++        | Texp_escape  exp -> iter_expression exp
++        | Texp_cspval (_, li) -> ()
+       end;
+       Iter.leave_expression exp;
+ 
+diff --git a/typing/typedtreeMap.ml b/typing/typedtreeMap.ml
+index 7c8c633..9a1fb53 100644
+--- a/typing/typedtreeMap.ml
++++ b/typing/typedtreeMap.ml
+@@ -344,6 +344,10 @@ module MakeMap(Map : MapArgument) = struct
+           Texp_object (map_class_structure cl, string_list)
+         | Texp_pack (mexpr) ->
+           Texp_pack (map_module_expr mexpr)
++        (* NNN: through the rest of the expression *)
++        | Texp_bracket exp -> Texp_bracket (map_expression exp)
++        | Texp_escape  exp -> Texp_escape  (map_expression exp)
++        | Texp_cspval (_, li) -> exp.exp_desc
+     in
+     let exp_extra = List.map map_exp_extra exp.exp_extra in
+     Map.leave_expression {
+diff --git a/typing/typemod.ml b/typing/typemod.ml
+index 7cbda25..a2f1b03 100644
+--- a/typing/typemod.ml
++++ b/typing/typemod.ml
+@@ -1151,10 +1151,31 @@ and type_structure ?(toplevel = false) funct_body anchor env sstr scope =
+     (Cmt_format.Partial_structure str :: previous_saved_types);
+   str, sg, final_env
+ 
++(* NNN begin
++Hook up the Trx post-processing
++old
+ let type_toplevel_phrase env s =
+   type_structure ~toplevel:true false None env s Location.none
++*)
++let type_toplevel_phrase env s = 
++  let (str, sg, finalenv) = 
++    type_structure ~toplevel:true false None env s Location.none
++  in 
++  (Trx.trx_structure str, sg, finalenv)
++(* NNN end *)
++
+ let type_module = type_module true false None
+-let type_structure = type_structure false None
++(* NNN begin
++Hook up the Trx post-processing
++old
++ let type_structure = type_structure false None
++*)
++let type_structure env sstr scope = 
++  let (str, sg, finalenv) = type_structure false None env sstr scope
++  in 
++  (Trx.trx_structure str, sg, finalenv)
++(* NNN end *)
++
+ 
+ (* Normalize types in a signature *)
+ 
diff --git a/ber-metaocaml-101/patches/trx.ml b/ber-metaocaml-101/patches/trx.ml
new file mode 100644
index 0000000..6f94793
--- /dev/null
+++ b/ber-metaocaml-101/patches/trx.ml
@@ -0,0 +1,2121 @@
+(*
+  This file is to post-process the Typedtree built by the type checker
+  before it is passed to the code generator -- to get rid of bracket and
+  escape. The main function is trx_structure, which initiates the
+  traversal and transforms every found expression with trx_exp. The
+  real transformation is done by trx_bracket.
+
+  For example,
+     <succ 1> 
+  gets transformed to 
+     mkApp <succ> <1> 
+  and eventually to
+     mkApp (mkIdent "succ") (mkConst 1)
+  One may say that we `push the brackets inside'.  We replace brackets
+  with calls to functions that will construct, at run-time, a
+  Parsetree, which is the representation of values of the code type.
+
+  Generally, the Parsetree is constructed when the program is run.
+  In some cases we can construct the Parsetree at compile time,
+  that is, when this trx.ml is run. Constants like <1> is such a case.
+  If we see <1>, or, in terms of trees,
+      Texp_bracket (Texp_constant (Constant_int 1))
+  we can immediately construct the Parsetree:
+      Pexp_constant (Constant_int 1)
+  After we construct the Parsetree at compile time, we use CSP to
+  pass it over to run-time. At run-time, we merely use the compiled constant.
+  This mechanism of building Parsetree at compile-time whenever possible
+  is one of the large differences from the previous versions of MetaOCaml.
+
+  Future-stage Bindings.
+  Future-stage bindings are introduced by patterns in let, fun,
+  match, try and for forms. Global bindings are always at present-stage.
+  Since local modules in brackets are not allowed, all future bindings are
+  unqualified (i.e., simple names, without the module path).
+  The principal rule of translating binding forms is
+     <fun x -> e> ---> let x = gensym "x" in mkLAM x <e>
+  Emphatically, gensym cannot be run at compile time!
+  Reason: consider the recursive invocation:
+     let rec f z = <fun y -> ~( ... f 1 ... )>
+
+  Thus, at run-time, we generate new names for bound variables and
+  use the OCaml's evaluator (the `run-time') to substitute these
+  new names in <e>. Therefore, a future-stage bound variable after
+  the translation becomes a present-stage bound variable,
+  but at a different type: string loc. We use string loc rather
+  than Longident.t loc since all, at present, future-stage bindings
+  are simple names.
+
+  We now check for scope extrusion: we enforce the region discipline
+  for generated identifiers. To make it easier to impose checks,
+  the translation rule is modified as follows
+     <fun x -> e> ---> build_simple_fun "x" (fun x -> <e>)
+  One can say that <fun x -> e> of the type (a->b) code is translated
+  into (fun x -> <e>) of the type a code -> b code. This looks quite
+  like the HOAS syntax for lambda (see the code-generation approach
+  with code combinators. The function build_simple_fun generates a gensym
+  and establishes a region for the gensym variable.
+
+  OCaml has more complicated functions, <function pattern -> body> with
+  complex patterns. If the patterns contain no binding variables,
+  there is no need to go into the gensym generation. The translation is
+  no more complex than that of <lazy e>. 
+  For more complicated binding patterns, we generalize, for example
+     <fun (x1,true,x2) as x3 -> e1 | _ -> e2> ---> 
+       build_fun ["x1";"x2"] (fun (x1,x2,x3) -> [<e1>;e2])
+  That is, we pick all binding variables from the pattern and build a
+  function that receives the code for these variables and produces the
+  array of code for all alternatives.
+
+  Here are the main patterns of scope extrusion
+  let r = <0> in 
+  <fun x -> ~(r := <x + 1>; <()>)>
+
+  let r = <0> in
+  <fun x -> .~(<fun x -> ~(let v = <x> in r := <fun x -> ~v>; <()>)>; !r)>
+
+  exception E of int code
+  try <fun x -> ~(raise (E <x>)> with E x -> x
+  (actually we need a local polymorphic exception, but the idea is the same)
+
+  and similar using control effects.
+
+  The most obvious method of detecting the scope extrusion is traversing
+  the generated code looking for unbound identifiers. We can do
+  such a check when we are about to show or run the code, or
+  about to splice (in the latter case, we have to maintain
+  the dynamic environment of gensym'ed names generated by 
+  build_fun_). However, reporting the scope
+  extrusion upon printing or running the code is reporting it too
+  late. Doing the check on each escape (since only splices can incorporate
+  scope-extruded code) means many repeated traversals of the generated
+  code.
+
+  We use a different method: we mark each piece of the generated code
+  with the list of free variable the code contains. Each variable
+  is associated with a `stackmark', which identifiers the region
+  with which the variable is associated. All valid stackmarks form
+  a total order. Alas, delimited control can reshuffle that order.
+  The function build_simple_fun and others enter a new region
+  and then check that the generated body contains only valid stackmarks
+  (that is, stackmarks that correspond to active regions). 
+  Every code building function ( build_* ) checks to see that the stackmarks
+  in the incorporated fragments are all valid, that is,
+  correspond currently alive variables. These code building function
+  merge the free variable lists (heaps actually) from the incorporated
+  fragments.
+
+This file was based on trx.ml from the original MetaOCaml, but it is
+completely re-written from scratch and has many comments. The
+traversal algorithm, the way of compiling Parsetree builders, dealing
+    with CSP and many other algorithms are all different.
+
+*)
+
+open Parsetree
+open Asttypes
+open Misc
+open Typedtree
+open Types
+
+
+(*{{{ Preliminaries, common functions *)
+
+(* BER MetaOCaml version string *)
+let meta_version  = "N 101"
+
+(* Co-opt Camlp4 class of warnings *)
+let debug_print : string -> unit = fun msg ->
+ ignore(Warnings.print Format.err_formatter 
+          (Warnings.Camlp4 msg))
+
+(* Emit a translation-time error *)
+let trx_error ?(loc = Location.none) fn =
+  raise (Typecore.Error (loc, Env.initial, Typecore.Trx_error fn))
+
+let not_supported loc msg =
+  trx_error ~loc:loc (fun ppf -> Format.fprintf ppf 
+      "%s is not yet supported within brackets" msg)
+
+(* left-to-right accumulating map *)
+let rec map_accum : ('accum -> 'a -> 'b * 'accum) -> 'accum -> 'a list ->
+  'b list * 'accum = fun f acc -> function
+    | []   -> ([],acc)
+    | h::t -> 
+        let (h,acc) = f acc h in
+        let (t,acc) = map_accum f acc t in
+        (h::t, acc)
+
+(*}}}*)
+
+
+(*{{{ Path and location utilities *)
+
+(* ------------------------------------------------------------------------ *)
+(* Path utilities *)
+
+(* We always use path when available, and convert it to Longident
+   when needed -- even if the Typedtree already carries the longident.
+   The path is preferred because it is fully qualified for
+   external identifiers and it is unambiguous.
+   If we open a module, its components can be referred to without
+   qualification -- the path will be qualified nevertheless.
+   When we build a Parsetree representing the generated code,
+   we have to use fully qualified identifiers since the open statement
+   in the original code won't be represented in the generated
+   Parsetree.
+*)
+
+(* Check to see if a path refers to an identifier, exception, or
+   constructor that is available from an external module. If so, the run-time
+   compiler invoked by run can get the definition for the identifier from
+   a .cmi file. The value of an external identifier can be obtained from
+   a .cmo file.
+*)
+let is_external = function
+  | Path.Pident id ->           (* not qualified *)
+      Ident.persistent id || Ident.global id || Ident.is_predef_exn id
+  | Path.Papply _  -> false
+  | Path.Pdot(Path.Pident id, _,_) -> Ident.persistent id
+  | _             -> false
+
+(* Convert a path to an identifier. Since the path is assumed to be
+   `global', time stamps don't matter and we can use just strings.
+*)
+let rec path_to_lid : Path.t -> Longident.t = function
+  | Path.Pident i       -> Longident.Lident (Ident.name i)
+  | Path.Pdot (p,s,_)   -> Longident.Ldot (path_to_lid p, s)
+  | Path.Papply (p1,p2) ->
+      Longident.Lapply(path_to_lid p1, path_to_lid p2)
+
+(* Convert the path to lid but use the given str as the last component.
+   This in effect qualifies 'str' with the given module path
+*)
+let path_to_lid_but_last : Path.t -> string -> Longident.t =
+  fun p str ->
+    match p with
+    | Path.Pident _ -> Longident.Lident str
+    | Path.Pdot (p,_,pos) -> path_to_lid (Path.Pdot (p,str,pos))
+    | _ -> assert false
+
+(* Replace the last component of p1 with p2, which should be a Pident
+   path 
+*)
+let path_replace_last : Path.t -> Path.t -> Path.t = fun p1 p2 ->
+ match (p1,p2) with
+  | (Path.Pident _,x) -> x
+  | (Path.Pdot(p1,_,s),Path.Pident id) -> Path.Pdot(p1,Ident.name id,s)
+  | _ -> assert false
+
+
+(* Check to make sure a constructor, label, exception, etc.
+   have the name that we can put into AST (Parsetree).
+   Local names can't be put into the Parsetree since the type env in which
+   they are declared is not represented in the Parsetree.
+*)
+let check_path_quotable msg path =
+  if not (is_external path) then
+    trx_error (fun ppf ->
+      Format.fprintf ppf 
+        "%s %s cannot be used within brackets. Put into a separate file."
+        msg (Path.name path))
+
+(* Check to see that a constructor belongs to a type defined
+   in a persistent module or in the initial environment.
+   Return the fully qualified name to put into AST 
+   (Pervasive constructors remain unqualified however).
+
+   We have nothing to do if the constructor is already fully qualified
+   with a persistent module identifier: for example, Scanf.Scan_failure.
+   The major complexity comes from this scenario:
+      open Scanf
+      .<raise (Scan_failure "xx")>.
+   The Texp_construct node of Typedtree contains the lid and (was: the
+   path) that refer to "Scan_failure" without any module qualifications.
+   We have to find the fully qualified path and check
+   that it is external. We do that by finding the path for the _type_
+   constructor, for the type of which the data constructor is a member.
+   That type_path is fully qualified. We can ascertain the later fact
+   from Env.constructors_of_type, which puts the complete path
+   into the type of the constructor, which is always of the form
+   Tconstr(ty_path,_,_). The function constructors_of_type is used
+   within Env.store_type, which is used when opening a module.
+
+   Alternatively we could've used Env.lookup_constuctor, which also
+   returns the qualified path? Searching the environment is costly
+   though.
+   Actually, using Env.lookup_constuctor is a bad idea. Now labels and
+   constructors don;t have to be unique. The type checker goes to
+   a great length to disambiguate a constructor or a label. It records
+   the eventually determined type of the label/constructor in
+   label_description or constructor_description.
+   So, we should only use information from these descriptions.
+
+   Alas, the predefined types (with no module qualification) are
+   not specially distinguished. So, we have to check the initial
+   environment.
+ *)
+let qualify_ctor : 
+    Longident.t loc -> constructor_description -> Longident.t loc = 
+ fun lid cdesc ->
+  let loc = lid.loc in
+  match (cdesc.cstr_tag, Ctype.repr cdesc.cstr_res) with
+  | (Cstr_exception (p,_),_) ->
+      if is_external p then Location.mkloc (path_to_lid p) loc else
+       trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
+       "Exception %s cannot be used within brackets. Put into a separate file."
+        (Path.name p))
+  | (_,{desc = Tconstr((Path.Pident _ as ty_path), _, _)}) ->
+     begin
+      try ignore (Env.find_type ty_path Env.initial); lid
+      with Not_found ->
+        trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
+        "Unqualified constructor %s cannot be used within brackets. Put into a separate file."
+          cdesc.cstr_name)
+     end
+  | (_,{desc = Tconstr(ty_path, _, _)}) ->
+      if is_external ty_path then
+        Location.mkloc (path_to_lid_but_last ty_path cdesc.cstr_name) loc
+      else
+      trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
+      "Constructor %s cannot be used within brackets. Put into a separate file."
+          cdesc.cstr_name)
+  | _ -> Printtyp.type_expr Format.err_formatter cdesc.cstr_res;
+           failwith ("qualify_ctor: cannot determine type_ctor from data_ctor "^
+                     cdesc.cstr_name)
+
+(* Check to see that a record label belongs to a record defined
+   in a persistent module or in the initial environment.
+   This is a label version of qualify_ctor
+*)
+let qualify_label : Longident.t loc -> label_description -> Longident.t loc =
+ fun lid ldesc ->
+  let loc = lid.loc in
+  match Ctype.repr ldesc.lbl_res with
+  | {desc = Tconstr((Path.Pident _ as ty_path), _, _)} ->
+    begin
+      try ignore (Env.find_type ty_path Env.initial); lid
+      with Not_found ->
+        trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
+        "Unqualified label %s cannot be used within brackets. Put into a separate file."
+          ldesc.lbl_name)
+    end
+  | {desc = Tconstr(ty_path, _, _)} ->
+      if is_external ty_path then
+        Location.mkloc 
+          (path_to_lid_but_last ty_path ldesc.lbl_name) loc
+      else
+        trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
+          "Label %s cannot be used within brackets. Put into a separate file."
+          ldesc.lbl_name)
+  | _ -> Printtyp.type_expr Format.err_formatter ldesc.lbl_res;
+           failwith ("qualify_label: cannot determine type from label "^
+                     ldesc.lbl_name)
+
+(* Test if we should refer to a CSP value by name rather than by
+   value
+*)
+(* Module identifiers for the modules that are expected to be
+   present at run-time -- that is, will be available for
+   dynamic linking of the run-time generated code.
+
+TODO: check bytecomp/transclass.ml:const_path
+Perhaps that's a hint which unqualified identifiers will be persistent
+*)
+
+let ident_can_be_quoted = is_external
+
+(*}}}*)
+
+
+(*{{{ Templates for building Parsetree/Typedtree components *)
+
+let dummy_lid : string -> Longident.t loc = fun name ->
+  Location.mknoloc (Longident.Lident name)
+
+(* Exported. Used as a template for constructing lid expressions *)
+let sample_lid = dummy_lid "*sample*"
+
+(* Exported. Used as a template for constructing name expression *)
+let sample_name : string loc = mknoloc "*sample*"
+
+(* Exported. Used as a template for constructing Location.t expressions *)
+let sample_loc = Location.none
+
+(* Exported. Used as a template for constructing pattern lists expressions *)
+let sample_pat_list : Parsetree.pattern list = []
+let sample_pats_names : Parsetree.pattern list * string loc list = ([],[])
+
+(* Exported. Used as a template for passing the Asttypes.rec_flag *)
+let sample_rec_flag : Asttypes.rec_flag = Nonrecursive
+
+(* Exported. Used as a template for passing the Asttypes.override_flag *)
+let sample_override_flag : Asttypes.override_flag = Fresh
+
+(*}}}*)
+
+(* ------------------------------------------------------------------------ *)
+(* Building Texp nodes *)
+(* Env.initial is used for all look-ups. Unqualified identifiers
+   must be found there. For qualified identifiers, Env.lookup
+   functions look things up in the persistent structures, loading them
+   up as needed.
+*)
+
+let mk_texp : ?env:Env.t -> Typedtree.expression_desc -> type_expr -> 
+  Typedtree.expression =
+  fun ?(env=Env.initial) desc ty ->
+  { exp_desc = desc; exp_type = ty;
+    exp_loc  = Location.none; exp_extra = [];
+    exp_env  = env }
+
+(* TODO: add memoization? *)
+
+(* Compiling an identifier with a given (qualified) name *)
+let texp_ident : string -> expression = fun name ->
+  let lid     = Longident.parse name in
+  let (p, vd) = try Env.lookup_value lid Env.initial 
+                with Not_found -> fatal_error ("Trx.find_value: " ^ name) in
+  mk_texp (Texp_ident (p,mknoloc lid, vd))
+          (Ctype.instance Env.initial vd.val_type)
+
+
+(* Building an application *)
+let texp_apply : Typedtree.expression -> Typedtree.expression list -> 
+ Typedtree.expression_desc = fun f args ->
+   Texp_apply(f, List.map (fun arg -> ("",Some arg, Required)) args)
+
+(* Compiling location data *)
+let texp_loc : Location.t -> Typedtree.expression = fun loc ->
+  let loc_exp = texp_ident "Trx.sample_loc" in (* this fills in the type, etc.*)
+  {loc_exp with exp_desc = Texp_cspval (Obj.repr loc, dummy_lid "*loc*")}
+
+(* Compiling longident with location data *)
+let texp_lid : Longident.t loc -> Typedtree.expression = fun lid ->
+  let lid_exp = texp_ident "Trx.sample_lid" in (* this fills in the type, etc.*)
+  {lid_exp with exp_desc = Texp_cspval (Obj.repr lid, dummy_lid "*lid*")}
+
+(* Compiling a string constant *)
+let texp_string : string -> Typedtree.expression = fun str ->
+  mk_texp (Texp_constant (Const_string str))
+          (Ctype.instance_def Predef.type_string)
+
+(* Compiling a string with a location *)
+let texp_string_loc : string loc -> Typedtree.expression = fun name ->
+  let name_exp = texp_ident "Trx.sample_name" in
+  {name_exp with
+   exp_desc = Texp_cspval (Obj.repr name, dummy_lid "*name*")} 
+
+(* Compiling a boolean *)
+(* For prototype, see Typecore.option_none *)
+let texp_bool : bool -> Typedtree.expression = fun b ->
+  let lid = Longident.Lident (if b then "true" else "false") in
+  let cdec = Env.lookup_constructor lid Env.initial in
+  mk_texp (Texp_construct(mknoloc lid, cdec, [], false))
+          (Ctype.instance_def Predef.type_bool)
+
+(* Compiling an option *)
+(* For prototype, see Typecore.option_none *)
+let texp_option : Typedtree.expression option -> Typedtree.expression = 
+  function
+    | None -> 
+        let lid = Longident.Lident "None" in
+        let cnone = Env.lookup_constructor lid Env.initial in
+        mk_texp (Texp_construct(mknoloc lid, cnone, [], false))
+                (Ctype.instance_def (Predef.type_option (Btype.newgenvar ())))
+    | Some e ->
+        let lid = Longident.Lident "Some" in
+        let csome = Env.lookup_constructor lid Env.initial in
+        mk_texp (Texp_construct(mknoloc lid, csome, [e],false))
+                (Ctype.instance_def (Predef.type_option e.exp_type)) 
+                ~env:e.exp_env
+
+(* Compiling a tuple *)
+let texp_tuple : Typedtree.expression list -> Typedtree.expression = fun el ->
+  mk_texp (Texp_tuple el)
+          (Ctype.newty (Ttuple (List.map (fun e -> e.exp_type) el)))
+
+(* Compiling an array *)
+(* We use this function for grouping trx_bracket-transformed expressions,
+   which have the same representation type (but may be different
+   code type). We ignore the differences in the code type, since
+   the representation type is the same.
+
+   We don't use lists since they are harder to compile, and more
+   fragile. Texp_construct has more arguments, we have to locate
+   constructor information, etc.
+*)
+let texp_array : Typedtree.expression list -> Typedtree.expression = function
+  | [] -> 
+      mk_texp (Texp_array []) 
+	      (Ctype.instance_def (Predef.type_array (Btype.newgenvar ())))
+  | (h::_) as el ->
+      mk_texp (Texp_array el) 
+	      (Ctype.instance_def (Predef.type_array h.exp_type))
+
+(* Compiling patterns and the list of names bound by them *)
+let texp_pats_names : Parsetree.pattern list -> string loc list -> 
+  Typedtree.expression = fun pats names ->
+    let pn_exp = texp_ident "Trx.sample_pats_names" in
+    {pn_exp with
+     exp_desc = Texp_cspval (Obj.repr (pats,names), dummy_lid "*pn*")}
+
+(* ------------------------------------------------------------------------ *)
+(* Stack marks, a simple form of dynamic binding *)
+
+(* In the earlier version, our stackmarks could be ordered.
+   Alas, it is hard to dynamically replace the implementation
+   below with the one adjusted for delimcc. The implementation below
+   does not work when partial continuations can be captured and reinstated.
+   Mainly, when delimited continuations are used, the order is
+   not stable. Delimited control operators can reshuffle the order
+   arbitrarily. Therefore, the fact that there is order among valid stackmarks
+   is not helpful anyway.
+
+module type STACKMARK = sig
+  type t
+  val is_valid : t -> bool
+  (* compare is supposed to be called on stack marks that are
+     checked to be valid
+   *)
+  val compare : t -> t -> int
+  val with_stack_mark : (t -> 'w) -> 'w
+end
+
+(* Simple implementation with shallow dynamic binding *)
+module StackMark : STACKMARK = struct
+  type t = int ref
+
+  (* The global counter of the nesting depth of with_stack_mark *)
+  let stack_mark_cnt = ref 0
+
+  (* A stack mark is ref n where n is the depth of the corresponding
+     with_stack_mark form.
+     The stack mark is invalid if the counter is 0
+   *)
+  let with_stack_mark body =
+    incr stack_mark_cnt;
+    let mark = ref !stack_mark_cnt in
+    let finalize () =
+      mark := 0;                         (* invalidate the mark *)
+      assert (!stack_mark_cnt > 0);
+      decr stack_mark_cnt
+    in
+    try 
+      let r = body mark in finalize (); r
+    with e -> finalize (); raise e
+
+  let is_valid mark = !mark > 0
+  let compare m1 m2 =
+    assert (!m1 >0 && !m2 > 0);
+    compare !m1 !m2
+end
+
+*)
+
+(* A robust and truly minimalistic implementation of stack-marks.
+   A stack-mark is created by 'with_stack_mark' function. Since
+   the only operation on a stackmark is to test if it is valid,
+   the stackmark is realized as a thunk unit -> bool.
+*)
+type stackmark = unit -> bool           (* true if valid *)
+
+(* The type of the with_stack_mark operation *)
+type stackmark_region_fn = 
+    {stackmark_region_fn : 'w. (stackmark -> 'w) -> 'w}
+
+(* The simple implementation of stackmark_region_fn, appropriate
+   when no delimited control is used.
+   The mark is a ref bool cell, containing true within
+   stackmark_region_fn's dynamic region.
+*)
+let with_stack_mark_simple : stackmark_region_fn = 
+  {stackmark_region_fn = fun body ->
+    let mark = ref true in
+    try
+      let r = body (fun () -> !mark) in
+      mark := false;                      (* invalidate the mark *)
+      r
+    with e -> mark := false; raise e
+ }
+
+let with_stack_mark : stackmark_region_fn ref = ref with_stack_mark_simple
+
+(* Replace a with_stack_mark implementation, e.g., when delimcc is used *)
+let set_with_stack_mark : stackmark_region_fn -> unit =
+  fun smf -> with_stack_mark := smf
+
+    
+(* ------------------------------------------------------------------------ *)
+(* Simple heap *)
+(* A mapping of keys to values. Priority is used for the sake of
+   efficient operations. Also, values with the same priority are
+   considered equivalent (belong to the same binding region)
+   and are collapsed, lazily. 
+
+   The invariant: for each non-leaf
+   node, the priority of the node is strictly greater than the priorities 
+   of any of the child nodes. The order of priorities between 
+   the children can be arbitrary.
+*)
+type prio = int
+type 'v heap = Nil | HNode of prio * stackmark * 'v * 'v heap * 'v heap
+let empty = Nil
+
+let rec merge : 'v heap -> 'v heap -> 'v heap = fun h1 h2 ->
+  match (h1,h2) with
+  | (Nil,h) | (h,Nil)-> h
+  | (HNode (p1,k1,v1,l1,r1), HNode (p2,k2,v2,l2,r2)) ->
+      begin
+        match p1 - p2 with
+        | 0 -> HNode (p1,k1,v1, merge l1 l2, merge r1 r2) (* same keys *)
+        | n when n < 0 -> HNode (p2,k2,v2, merge h1 l2, r2)
+        | _ -> HNode (p1,k1,v1,l1,merge h2 r1)
+      end
+
+(* Remove the node with a given priority *)
+let rec remove : prio -> 'v heap -> 'v heap = fun p -> function
+  | Nil -> Nil
+  | HNode (pn,k,v,h1,h2) as h -> 
+      begin
+        match p - pn with
+        | 0 -> merge h1 h2              (* p cannot occur in h1 or h2 *)
+        | n when n > 0 -> h             (* entire tree has the lower prio *)
+        | _ -> HNode (pn,k,v, remove p h1, remove p h2)
+      end
+
+(* The representation of the possibly open code: AST plus the
+   set of free identifiers, annotated with the marks
+   of the corresponding with_binding_region forms
+*)
+type code_repr = Code of string loc heap * Parsetree.expression
+
+(* The closed code is AST *)
+type closed_code_repr = Parsetree.expression
+
+(* Check that the code is closed and return the closed code *)
+
+(* The same as close_code but return the closedness check as a thunk
+   rather than performing it.
+   This is useful for debugging and for showing the code
+*)
+let close_code_delay_check : code_repr -> closed_code_repr * (unit -> unit) =
+ function
+  | Code (Nil,ast) -> (ast,fun () -> ())
+  | Code (HNode (_,_,var,_,_),ast) ->
+    (ast, fun () ->
+      Format.fprintf Format.str_formatter
+      "The code built at %a is not closed: identifier %s bound at %a is free"
+      Location.print ast.pexp_loc var.txt Location.print var.loc;
+      failwith (Format.flush_str_formatter ()))
+
+let close_code_repr : code_repr -> closed_code_repr = fun cde ->
+  let (ast, check) = close_code_delay_check cde in
+  check (); ast
+
+let open_code : closed_code_repr -> code_repr = fun ast ->
+  Code (Nil,ast)
+
+(* Compiling a closed code value: a structural constant of
+   type code_repr
+   This constant is transported via CSP (although we could have
+   built a Typedtree node for that purpose.
+ *)
+let texp_code : ?node_id:string ->
+  Location.t -> Parsetree.expression_desc -> Typedtree.expression_desc =
+  fun ?(node_id="") loc desc ->
+  let ast = {pexp_loc = loc; pexp_desc = desc}
+  in Texp_cspval (Obj.repr (open_code ast), dummy_lid node_id)
+
+
+
+(* ------------------------------------------------------------------------ *)
+(* Bindings in the future stage *)
+(* Recall, all bindings at the future stage are introduced by
+   patterns, and hence are simple names, without any module qualifications.
+*)
+let gensym_count = ref 0
+
+(* Generate a fresh name with a given base name *)
+let gensym : string -> string = fun s ->
+  incr gensym_count;
+  s ^ "_" ^ string_of_int !gensym_count
+
+let reset_gensym_counter () = gensym_count := 0
+
+(* Make a simple identifier unique *)
+let genident : string loc -> string loc = fun name ->
+  {name with txt = gensym name.txt}
+
+(* This is a run-time error, rather than a translation-time error *)
+let scope_extrusion_error : 
+  detected:Location.t -> occurred:Location.t -> string loc -> 'a = 
+  fun ~detected ~occurred var ->
+  Format.fprintf Format.str_formatter
+    "Scope extrusion detected at %a for code built at %a for the identifier %s bound at %a"
+    Location.print detected Location.print occurred
+    var.txt Location.print var.loc;
+  failwith (Format.flush_str_formatter ())
+
+(* Check to make sure that free variables in the potentially open
+   code fragment are valid.
+   If it weren't for delimited control, the order of stack marks is
+   stable; therefore, if the maximal mark is valid then all
+   smaller marks are valid as well.
+   Delimited control spoils all that. 
+   When we capture some of the inner-bidings
+   in a continuation and then reinstall that continuation at the
+   top level, the `latest' free variable is valid but earlier are
+   no longer valid:
+
+  let r = ref ... in
+  .<fun x1 x2 -> .~(reset .<fun y1 y2 -> 
+                              .~(shift k (r := k; k .<0>.))>.)>.
+  .r .<2>.
+  Here, y1 and y2 are valid but x1 and x2 are not.
+*)
+let validate_vars : Location.t -> code_repr -> code_repr = 
+  fun l -> function
+  | Code (Nil,_) as cde -> cde
+  | Code (h, ast) as cde -> begin
+      let rec check = function
+        | Nil -> ()
+        | HNode (_,sm,var,h1,h2) ->
+            if sm () then (check h1; check h2)
+            else scope_extrusion_error ~detected:l ~occurred:ast.pexp_loc var 
+      in check h; cde
+  end
+
+let validate_vars_option : Location.t -> code_repr option -> 
+  Parsetree.expression option * string loc heap = 
+  fun l -> function
+  | None -> (None,Nil)
+  | Some e -> let Code (vars, e) = validate_vars l e in (Some e, vars)
+
+let validate_vars_list : Location.t -> code_repr list -> 
+  Parsetree.expression list * string loc heap = fun l cs ->
+  map_accum (fun acc c -> 
+      let Code (vars,e) = validate_vars l c in
+      (e, merge vars acc))
+    Nil cs
+
+(* Generate a fresh name off the given name, enter a new binding region
+   and evaluate a function passing it the generated name as code_repr.
+   Remove the generated name from the annotation on the resulting code_expr.
+   Return that result and the generated name.
+   This function embodies the translation of simple functions, for-loops,
+   simple let-expressions, etc.
+*)
+      (* Counter for assiging priorities to vars heap nodes. *)
+      (* Keep in mind the invariant that variables of the same priority
+         comes from the same binding location. So, we must keep the
+         priorities unique to binders. Giving binders monotonically
+         increasing priorities is helpful: the innermost binding
+         has the highest priority and it will be at the top of the heap,
+         the easiest to remove.
+       *)
+let prio_counter = ref 0
+
+let with_binding_region : 
+  Location.t -> string loc -> (code_repr -> code_repr) -> 
+  string loc * string loc heap * Parsetree.expression = fun l name f -> 
+  let new_name = genident name in
+  let (vars,e) = 
+   !with_stack_mark.stackmark_region_fn (fun mark ->
+     incr prio_counter;
+     let prio = !prio_counter in
+     let var_code = (* code that corresponds to the bound variable *)
+       Code (HNode (prio,mark,new_name,Nil,Nil),
+          {pexp_loc  = name.loc;        (* the loc of the binder *)
+           pexp_desc = 
+            Pexp_ident (mkloc (Longident.Lident new_name.txt) new_name.loc)}) in
+     let Code (vars,e) = validate_vars l (f var_code) in
+     (remove prio vars, e)) in
+  (new_name, vars, e)
+
+(* The most general version with several bindings and several expressions 
+   that use the bindings
+ *)
+let with_binding_region_gen : 
+  Location.t -> string loc list -> (code_repr array -> code_repr array) -> 
+  string loc list * string loc heap * Parsetree.expression list
+  = fun l names f -> 
+  let new_names = List.map genident names in
+  let (vars,es) = 
+   !with_stack_mark.stackmark_region_fn (fun mark ->
+     incr prio_counter;
+     let prio = !prio_counter in
+     let vars_code = Array.of_list (List.map (fun new_name ->
+                      (* code that corresponds to a bound variable *)
+       Code (HNode (prio,mark,new_name,Nil,Nil),
+          {pexp_loc  = new_name.loc;        (* the loc of the binder *)
+           pexp_desc = 
+            Pexp_ident (mkloc (Longident.Lident new_name.txt) new_name.loc)}))
+       new_names) in
+     let cs = Array.to_list (f vars_code) in
+     let (es,vars) = map_accum (fun vars c -> 
+                      let Code (var,e) = validate_vars l c in 
+                      (e,merge var vars)) Nil cs in
+     (remove prio vars, es)) in
+  (new_names, vars, es)
+
+
+(* ------------------------------------------------------------------------ *)
+(* Building Parsetree nodes *)
+
+(* Handle timestamp for builders of the type 
+      Parsetree.expression -> Parsetree.expression
+*)
+let code_wrapper : 
+    (Location.t -> Parsetree.expression -> Parsetree.expression) ->
+    (Location.t -> code_repr -> code_repr) =
+fun f l e ->
+  let Code (vars,e) = validate_vars l e in
+  Code (vars, f l e)
+
+(* building a typical Parsetree node: Pexp_assert of expression*)
+let build_assert : Location.t -> code_repr -> code_repr = 
+  code_wrapper
+  (fun l e -> {pexp_loc = l; pexp_desc = Pexp_assert e})
+
+(* When we translate the typed-tree, we have to manually compile
+   the above code 
+First, to see the AST for the phrase, invoke the top-level with the flag
+-dparsetree. Then
+   {pexp_loc  = l; pexp_desc = Pexp_assert e}
+
+gives the parsetree:
+let build_assert_ast : Location.t -> Parsetree.expression -> Parsetree.expression = 
+{pexp_loc = l1;
+ pexp_desc = 
+  Pexp_record
+        ([(Location.mknoloc (Longident.parse "Parsetree.pexp_loc"), 
+           Pexp_ident "l");
+         (Location.mknoloc (Longident.parse "Parsetree.pexp_desc"),
+           {pexp_loc  = Location.none;
+            pexp_desc = Pexp_construct 
+                          ((Location.mknoloc (Longident.parse 
+                                                "Parsetree.Pexp_assert")),
+              Some {pexp_loc = Location.none;
+                    pexp_desc = Pexp_ident "e"},
+              false)})
+        ],
+        None)}
+type_expression
+
+If building the parsetree on our own, beware! For example, labels in
+Texp_record must be sorted, in their declared order!
+*)
+
+
+(* Other similar builders *)
+let build_lazy : Location.t -> code_repr -> code_repr = 
+  code_wrapper
+    (fun l e -> {pexp_loc = l; pexp_desc = Pexp_lazy e})
+let build_bracket : Location.t -> code_repr -> code_repr= 
+  code_wrapper
+    (fun l e -> {pexp_loc = l; pexp_desc = Pexp_bracket e})
+let build_escape : Location.t -> code_repr -> code_repr = 
+  code_wrapper
+    (fun l e -> {pexp_loc = l; pexp_desc = Pexp_escape e})
+
+let build_sequence : Location.t -> code_repr -> code_repr -> code_repr = 
+  fun l e1 e2 -> 
+    let Code (vars1,e1) = validate_vars l e1 in
+    let Code (vars2,e2) = validate_vars l e2 in
+    Code (merge vars1 vars2,
+          {pexp_loc = l; pexp_desc = Pexp_sequence (e1,e2) })
+let build_while : Location.t -> code_repr -> code_repr -> code_repr = 
+  fun l e1 e2 -> 
+    let Code (vars1,e1) = validate_vars l e1 in
+    let Code (vars2,e2) = validate_vars l e2 in
+    Code (merge vars1 vars2,
+          {pexp_loc = l; pexp_desc = Pexp_while (e1,e2) })
+let build_when : Location.t -> code_repr -> code_repr -> code_repr = 
+  fun l e1 e2 -> 
+    let Code (vars1,e1) = validate_vars l e1 in
+    let Code (vars2,e2) = validate_vars l e2 in
+    Code (merge vars1 vars2,
+          {pexp_loc = l; pexp_desc = Pexp_when (e1,e2) })
+
+(* Build the application. The first element in the array is the
+   function. The others are arguments. *)
+let build_apply : Location.t -> (label * code_repr) array -> code_repr = 
+  fun l ea -> 
+    assert (Array.length ea > 1);
+    match map_accum (fun vars (lbl,e) -> 
+                   let Code (var,e) = validate_vars l e in
+                   ((lbl,e),merge var vars))
+          Nil (Array.to_list ea) with
+    | (("",eh)::elt,vars) ->
+       Code (vars, 
+              {pexp_loc  = l; 
+               pexp_desc = Pexp_apply (eh, elt)})
+    | _ -> assert false
+
+
+let build_tuple : Location.t -> code_repr array -> code_repr =
+ fun l ea -> 
+  let (els,vars) = validate_vars_list l (Array.to_list ea) in
+  Code (vars, 
+    {pexp_loc = l; pexp_desc = Pexp_tuple els })
+
+let build_array : Location.t -> code_repr array -> code_repr =
+ fun l ea -> 
+  let (els,vars) = validate_vars_list l (Array.to_list ea) in
+  Code (vars, 
+    {pexp_loc = l; pexp_desc = Pexp_array els })
+
+let build_ifthenelse : 
+ Location.t -> code_repr -> code_repr -> code_repr option -> code_repr =
+ fun l e1 e2 eo -> 
+    let Code (vars1,e1) = validate_vars l e1 in
+    let Code (vars2,e2) = validate_vars l e2 in
+    let (eo,varso)      = validate_vars_option l eo in
+    Code (merge vars1 (merge vars2 varso),
+      {pexp_loc = l; pexp_desc = Pexp_ifthenelse (e1,e2,eo) })
+
+let build_construct :
+ Location.t -> Longident.t loc -> code_repr array -> bool -> code_repr =
+ fun loc lid args explicit_arity ->
+  let (args,vars) = validate_vars_list loc (Array.to_list args) in
+  Code (vars, 
+  {pexp_loc  = loc;
+   pexp_desc = Pexp_construct (lid,
+     begin
+      match args with
+      | []  -> None
+      | [x] -> Some x
+      | xl  -> Some { pexp_loc  = loc; pexp_desc = Pexp_tuple xl }
+     end,
+     explicit_arity) })
+
+let build_record : Location.t -> (Longident.t loc * code_repr) array ->
+ code_repr option -> code_repr =
+ fun loc lel eo ->
+   let (lel,vars) = map_accum (fun vars (lbl,e) -> 
+                       let Code (var,e) = validate_vars loc e in
+                       ((lbl,e),merge var vars))
+        Nil (Array.to_list lel) in
+   let (eo,varo) = validate_vars_option loc eo in
+   Code (merge vars varo, 
+   {pexp_loc  = loc; pexp_desc = Pexp_record (lel,eo)})
+
+let build_field : Location.t -> code_repr -> Longident.t loc -> code_repr =
+ fun loc e lid ->
+  let Code (vars,e) = validate_vars loc e in
+  Code (vars, 
+     {pexp_loc  = loc;
+      pexp_desc = Pexp_field (e,lid)})
+
+let build_setfield :
+ Location.t -> code_repr -> Longident.t loc -> code_repr -> code_repr =
+ fun loc e1 lid e2 ->
+  let Code (vars1,e1) = validate_vars loc e1 in
+  let Code (vars2,e2) = validate_vars loc e2 in
+  Code (merge vars1 vars2,
+     {pexp_loc  = loc;
+      pexp_desc = Pexp_setfield (e1,lid,e2)})
+
+let build_variant : Location.t -> string -> code_repr option -> code_repr =
+ fun loc l eo ->
+  let (eo,vars) = validate_vars_option loc eo in
+  Code (vars, 
+     {pexp_loc  = loc;
+      pexp_desc = Pexp_variant (l,eo)})
+
+let build_send : Location.t -> code_repr -> string -> code_repr =
+ fun loc e l ->
+  let Code (vars,e) = validate_vars loc e in
+  Code (vars, 
+    {pexp_loc  = loc;
+     pexp_desc = Pexp_send (e,l)})
+
+let build_open :
+ Location.t -> Longident.t loc -> override_flag -> code_repr -> code_repr =
+ fun loc l ovf e ->
+  let Code (vars,e) = validate_vars loc e in
+  Code (vars, 
+     {pexp_loc  = loc;
+      pexp_desc = Pexp_open (ovf,l,e)})
+
+(* Build a function with a non-binding pattern, such as fun () -> ... *)
+let build_fun_nonbinding : 
+  Location.t -> string -> Parsetree.pattern list -> 
+  code_repr array -> code_repr =
+  fun l label pats bodies -> 
+  let (ebodies,vars) = validate_vars_list l (Array.to_list bodies) in
+  Code (vars,
+    {pexp_loc = l; 
+     pexp_desc = Pexp_function (label,None,
+                                List.map2 (fun p e -> (p,e)) pats ebodies)})
+
+
+(* Build a Parsetree for a future-stage identifier
+   It is always in scope of with_binding_region:
+   Bound variables are always in scope of their binders;
+   A well-typed code has no unbound variables.
+let build_ident : Location.t -> string loc -> code_repr =
+ fun loc l ->
+  not_supported loc "vars not supported"
+  Code (add_timestamp (Some l)
+   {pexp_loc  = loc;
+    pexp_desc = Pexp_ident (mkloc (Longident.Lident l.txt) l.loc)}
+*)
+
+(* Build a simple one-arg function, as described in the the title comments *)
+(* 'name' is the name of the variable from Ppat_var of the fun x -> ...
+   form. It is the real name with the location within the function pattern.
+   Use name.loc to identify the binder in the source code.
+*)
+let build_fun_simple : 
+  Location.t -> string -> string loc -> (code_repr -> code_repr) -> code_repr =
+  fun l label old_name fbody -> 
+  let (name, vars, ebody) = with_binding_region l old_name fbody in
+  let pat = {ppat_loc  = name.loc; ppat_desc = Ppat_var name} in
+  Code (vars,
+    {pexp_loc = l; 
+     pexp_desc = Pexp_function (label,None,[(pat,ebody)])})
+
+let build_for : 
+  Location.t -> string loc -> code_repr -> code_repr -> 
+  bool -> (code_repr -> code_repr) -> code_repr =
+  fun l old_name elo ehi dir fbody -> 
+  let (name, varsb, ebody) = with_binding_region l old_name fbody in
+  let Code (varso,elo) = validate_vars l elo in
+  let Code (varsh,ehi) = validate_vars l ehi in
+  Code (merge varsb (merge varso varsh),
+  {pexp_loc = l; 
+   pexp_desc = Pexp_for (name,elo,ehi,(if dir then Upto else Downto), ebody) })
+
+(* deflt_flag = True, the let was Default (auto-geneterated by the type
+   checker for the default function argument)
+*)
+let build_let_simple_nonrec : 
+  Location.t -> string loc -> bool -> code_repr -> (code_repr -> code_repr) -> 
+    code_repr = fun l old_name deflt_flag e fbody -> 
+  let (name, varsb, ebody) = with_binding_region l old_name fbody in
+  let pat = {ppat_loc  = name.loc; ppat_desc = Ppat_var name} in
+  let Code (varse,e) = validate_vars l e in
+  Code (merge varsb varse,
+  {pexp_loc = l; 
+   pexp_desc = 
+    Pexp_let ((if deflt_flag then Default else Nonrecursive), [(pat,e)],ebody)})
+
+(*
+ Recursive let is subject to additional well-formedness constraints, 
+ see bytecomp/translcore.ml:transl_let.
+ The first is that binding pattern should contain either Tpat_var
+ or Tpat_alias. For build_let_simple_rec, this constraint is
+ satisfied automatically. 
+ The second check is performed by check_recursive_lambda in 
+ bytecomp/translcore.ml. We use a simpler version of the test:
+ we allow only letrec experssions of the form
+   let rec f = fun x -> ....
+ that is, 
+   let rec f x y ... =
+*)
+let build_letrec : 
+  Location.t -> string loc array -> 
+    (code_repr array -> code_repr array) -> code_repr = 
+  fun l old_names fbodies -> 
+  let (names,vars,ebodies) = 
+    with_binding_region_gen l (Array.to_list old_names) fbodies in
+  let (ebody,es) = 
+    match ebodies with body::es -> (body,es) | _ -> assert false in
+  let pel = List.map2 (fun name e ->
+     ({ppat_loc  = name.loc; ppat_desc = Ppat_var name},e)) names es in
+  let check_rhs e =
+    match e.pexp_desc with
+    | Pexp_function (_,_,_) -> ()
+    | _ ->     
+        Format.fprintf Format.str_formatter
+          "Recursive let binding %a must be to a function %a"
+          Location.print l Location.print e.pexp_loc;
+        failwith (Format.flush_str_formatter ()) in
+  List.iter check_rhs es;
+  Code (vars,
+  {pexp_loc = l; 
+   pexp_desc = Pexp_let (Recursive, pel, ebody)})
+
+
+(*{{{ CSP *)
+
+(* ------------------------------------------------------------------------ *)
+(* Dealing with CSP *)
+
+exception CannotLift
+
+(* Analyze the type of the expression and figure out if we can lift it.
+   Raise CannotLift if cannot (e.g., the type is polymorphic), or it is too
+   much to bother.
+   TODO: lists, arrays, option types of liftable types are themselves
+   liftable. We can lift many more types. For arrays, check their length.
+   If the array is short, it should be lifted. For long arrays,
+   building a CSP is better (although it make take a bit longer since
+   we will have to invoke dyn_quote at run-time).
+
+   TODO: currently we generate calls to run-time functions like 
+   lift_constant_int to do the Parsetree generation. In the future
+   we should `inline' those functions -- that is, obtain the Typedtree
+   for them and use the tree for building Texp_apply.
+*)
+let lift_as_literal : 
+  Typedtree.expression -> Path.t -> Longident.t loc -> 
+  Typedtree.expression_desc = fun exp p li ->
+  let exp_ty =
+        Ctype.expand_head exp.exp_env (Ctype.correct_levels exp.exp_type) in
+  match Ctype.repr exp_ty with
+    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_int ->
+        texp_apply (texp_ident "Trx.lift_constant_int") [exp]
+    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_char ->
+        texp_apply (texp_ident "Trx.lift_constant_char") [exp]
+    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_bool ->
+        texp_apply (texp_ident "Trx.lift_constant_bool") [exp]
+          (* double and string are handled by dyn_quote *)
+    | _ -> raise CannotLift
+
+(* TODO: similarly handle Const_nativeint, Const_int32, Const_int64 *)
+let lift_constant_int : int -> code_repr = fun x -> 
+  open_code
+  {pexp_loc  = Location.none;
+   pexp_desc = Pexp_constant (Const_int x)}
+
+let lift_constant_char : char -> code_repr = fun x -> 
+  open_code
+  {pexp_loc  = Location.none;
+   pexp_desc = Pexp_constant (Const_char x)}
+
+let lift_constant_bool : bool -> code_repr = fun x -> 
+  let b = if x then "true" else "false" in 
+  open_code
+  {pexp_loc  = Location.none;
+   pexp_desc = Pexp_construct (Location.mknoloc (Longident.Lident b), 
+                               None, false)}
+
+
+(* Lift the run-time value v into a Parsetree for the code that, when
+   run, will produce v.
+   We do not have the type information for v, but we can examine
+   its run-time representation, to decide if we lift it is a source
+   literal or as a CSP.
+
+  TODO: also check for double_array_tag
+   and create a (structured) constant for a double array
+*)
+let dyn_quote : Obj.t -> Longident.t loc -> code_repr =
+  fun v li ->
+   let dflt = Pexp_cspval(v,li) in        (* By default, we build CSP *)
+   let desc = 
+    match Obj.is_int v with
+    | true -> dflt  (* If v looks like an int, it can represent many things: *)
+                    (* can't lift *)
+    | false when Obj.tag v = Obj.double_tag ->
+      Pexp_constant (Const_float (string_of_float (Obj.obj v)))
+    | false when Obj.tag v = Obj.string_tag ->
+      Pexp_constant (Const_string (Obj.obj v))
+    | _   -> dflt
+   in 
+   open_code
+   {pexp_loc = li.loc; pexp_desc = desc}
+
+       
+(* Build the Typedtree that lifts the variable with the given path and type.
+   Since this code receives the type of the variable, we use the
+   type to generate the lifting code for that particular type.
+   For example, we build the code to convert a float
+   0.1 to the Parsetree node Pexp_constant(Const_float "0.1")).
+   If we cannot or would not do the type-dependent lifting and we cannot
+   refer to the variable by name (e.g., because it is local),
+   we generate the call to the dynamic quoter, dyn_quote.
+   The latter will receive the actual value to quote and will generate,
+   at run-time, a Parsetree constant or CSP, based on that value.
+ *)
+let trx_csp : 
+  Typedtree.expression -> Path.t -> Longident.t loc ->
+  Typedtree.expression_desc = fun exp p li ->
+  (* First we try lifting as a constant *)
+  try lift_as_literal exp p li 
+  with CannotLift ->
+  (* Then check if we can pass by reference *)
+  if ident_can_be_quoted p then
+    texp_code ~node_id:"*id*" exp.exp_loc
+          (Pexp_ident (Location.mkloc (path_to_lid p) li.loc))
+  else
+  (* Otherwise, do the lifting at run-time *)
+  texp_apply (texp_ident "Trx.dyn_quote") [exp; texp_lid li]
+
+(*{{{ Historical: hints on native mode CSP *)
+
+(* Native mode is moved out to the `userland'
+
+let remove_texp_cspval exp =
+  if !native_mode = false then exp else
+  failwith "native mode CSP are not impemented yet"
+
+old code
+  match exp.exp_desc with
+  | Texp_cspval (v,l) ->
+      let i = add_csp_value (v,l) in
+      let exp' = {exp with exp_desc = Texp_constant (Const_int i)} in
+      let desc = if !initial_native_compilation
+        then (Texp_apply (trx_array_get exp, [(Some !local_csp_arr_texp, Required);(Some exp', Required)]))
+	else (Texp_apply (trx_get_csp_value exp, [(Some exp', Required)])) in
+      {exp with exp_desc = desc}
+  | _ -> assert false
+*)
+
+(*}}}*)
+
+(*}}}*)
+
+
+(*{{{ Translating patterns and expressions using patterns *)
+
+
+(* Analyze and translate a pattern:
+         Typedtree.pattern -> Parsetree.pattern
+  The function is somewhat similar to tools/untypeast.ml;untype_pattern
+
+  However, we also determine and return the list of bound variables.
+  The list is in the reverse of the order of variables occurring in the pattern.
+  Finally, we check that labels and constructors may be quoted.
+
+  The algorithm of determining the names of bound variables is based
+  on Typedtree.pat_bound_idents. There is one subtle issue.
+  Normally all variables within a pattern are unique (patterns are
+  always linear). Identically named variables within a list of patterns, like 
+      match ... with
+      | [x] -> 
+      | [x;y] ->
+  are _distinct_ variables. They have different Ident.t values, even though
+  their names may be the same. However, components of an OR pattern 
+  bind exactly the same identifiers. Don't count them twice!
+*)
+
+
+(* The first argument is a list of identifiers. Found identifiers are
+   prepended to that list. The order of identifiers is important!
+   If you change the traversal order, be sure to modify pattern_subst below!
+*)
+let rec trx_pattern : 
+    (Ident.t * string loc) list -> Typedtree.pattern -> 
+     Parsetree.pattern * (Ident.t * string loc) list = fun acc pat ->
+ if not (pat.pat_extra = []) then
+   not_supported pat.pat_loc
+    "patterns with unpack, constraints, and other pat_extra";
+  let (pd,acc) = match pat.pat_desc with
+  | Tpat_any -> (Ppat_any, acc)
+  | Tpat_var (id, name) when 
+      (match (Ident.name id).[0] with 'A'..'Z' -> true | _ -> false) ->
+        (Ppat_unpack name,acc)        (* We don't handle modules though...*)
+  | Tpat_var (id, name) ->
+      (Ppat_var name, (id,name)::acc)
+  | Tpat_alias (p, id, name) ->
+      let (p,acc) = trx_pattern acc p in
+      (Ppat_alias (p, name),(id,name)::acc)
+  | Tpat_constant cst -> (Ppat_constant cst, acc)
+  | Tpat_tuple lst ->
+    let (pl,acc) = map_accum trx_pattern acc lst
+    in (Ppat_tuple pl, acc)
+  | Tpat_construct (li, cdesc, args, explicit_arity) ->
+      let lid = qualify_ctor li cdesc in
+      let (args,acc) = map_accum trx_pattern acc args in
+      (Ppat_construct (lid,
+          (match args with
+          | []  -> None 
+          | [x] -> Some x 
+          | _   -> Some {ppat_desc = Ppat_tuple args; ppat_loc = pat.pat_loc}),
+          explicit_arity),
+       acc)
+  | Tpat_variant (label, None, _) -> (Ppat_variant (label,None),acc)
+  | Tpat_variant (label, Some p, _) ->
+      let (p,acc) = trx_pattern acc p 
+      in (Ppat_variant (label,Some p),acc)
+  | Tpat_record (lst, closed) ->
+      let dolab acc (li,ldesc,pat) =
+        let lid = qualify_label li ldesc in
+        let (pat,acc) = trx_pattern acc pat in
+        ((lid,pat),acc)
+      in
+      let (lpl,acc) = map_accum dolab acc lst in
+      (Ppat_record (lpl,closed),acc)
+  | Tpat_array lst -> 
+    let (pl,acc) = map_accum trx_pattern acc lst
+    in (Ppat_array pl, acc)
+  | Tpat_or (p1, p2, _) -> 
+      (* Invariant : both arguments bind the same variables *)
+      let (p1,acc) = trx_pattern acc p1 in
+      let (p2,_)   = trx_pattern acc p2 in (* ignore vars in p2 *)
+      (Ppat_or (p1,p2),acc)
+  | Tpat_lazy p -> 
+      let (p,acc) = trx_pattern acc p in (Ppat_lazy p,acc)
+  in
+  ({ ppat_desc = pd; ppat_loc = pat.pat_loc}, acc)
+
+
+(* Process all patterns in the pattern-expression list *)
+(* Patterns are processed left-to-right. The result is the processed
+   pattern list plus the list of names of the bound variables.
+   The variables are listed in the order they occur in the pattern.
+   Thus the following should hold:
+      let (pats,names,_) = trx_pel pel in
+      let (pats',acc) =  pattern_subst_list names pats in
+      assert (pats = pats');
+      assert (acc = [])
+   The final result of trx_pel is the pattern binding the names.
+   We build an array pattern rather than a more appropriate tuple.
+   Using array forces a single type to all arguments. Although
+   it is phantom anyway, it is still a bummer. But we the tuple
+   we can't generically write build_fun.
+   The second argument, typ_expr, should normally be a code type.
+
+   This function is used when translating a future-stage function as the 
+   present-stage whose argument is an array of variables.
+   See trx_bracket for functions, let, match and try
+*)
+let trx_pel : (Typedtree.pattern * Typedtree.expression) list -> type_expr ->
+     Parsetree.pattern list * string loc list * Typedtree.pattern
+   = fun pel typ -> 
+   let (pats, lst) = map_accum (fun acc (p,_) -> trx_pattern acc p) [] pel in
+   let idnames = List.rev lst in
+   let (loc,env) = 
+     match pel with (p,_)::_ -> (p.pat_loc, p.pat_env) |_ -> assert false in
+    (* Pattern representing one binding variable *)
+   let var_pat (id,name) =
+    {pat_loc = loc; pat_extra = []; pat_env = env;
+     pat_desc = Tpat_var (id,name);
+     pat_type = typ} in
+   (pats, List.map snd idnames,
+    {pat_loc = loc; pat_extra = []; pat_env = env;
+     pat_desc = Tpat_array (List.map var_pat idnames);
+     pat_type = Ctype.instance_def (Predef.type_array typ)})
+
+(* Substitute the names of bound variables in the pattern.
+   The new names are given in the string loc list. We
+   take advantage of the fact that patterns are linear and
+   the list of new names is ordered, in the order the bound
+   variables occur in the pattern. Therefore, we substitute based
+   on position.
+   OR-patterns bring complexity however: both branches of an OR
+   pattern bind exactly the same variables (but the order of
+   variable occurrence within branches may be different).
+   So for OR patterns we substitute by name, taking advantage
+   of the fact the new names differ from the old ones in _nnn
+   suffix. OR patterns are uncommon, so the complication of their processing
+   is not that bad.
+
+   This function is closely related to trx_pattern; It relies on the
+   same pattern traversal order as trx_pattern.
+ *)
+
+         (* two strings are the same up to (and including) n *)
+let rec same_upto s1 s2 n =
+  n < 0 || (s1.[n] = s2.[n] && same_upto s1 s2 (n-1))
+
+let rec pattern_subst : ?by_name:bool ->
+    string loc list -> Parsetree.pattern -> 
+     Parsetree.pattern * string loc list = fun ?(by_name=false) acc pat ->
+ if acc = [] then (pat,acc) else           (* no more variables to subst *)
+ let subst old_name acc =
+   if by_name then begin
+     let new_name =
+       try List.find (fun n -> 
+         same_upto old_name.txt n.txt (String.rindex n.txt '_' - 1)) acc 
+       with _ ->
+         begin
+           Format.fprintf Format.str_formatter "old_name %s %a\n"
+             old_name.txt Location.print old_name.loc;
+           List.iter (fun n -> Format.fprintf Format.str_formatter
+               "new name %s %a\n" n.txt Location.print n.loc) acc;
+           failwith (Format.flush_str_formatter ())
+         end
+     in
+     (new_name, acc)                       (* don't bother removing from acc*)
+   end
+   else match acc with
+   | h::t -> (h,t)
+   | _    -> assert false
+ in
+ let (desc,acc) = match pat.ppat_desc with
+  | Ppat_any as x -> (x,acc)
+  | Ppat_var old_name ->
+      let (new_name,acc) = subst old_name acc in (Ppat_var new_name,acc)
+  | Ppat_alias (p,old_name) ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     let (new_name,acc) = subst old_name acc in 
+     (Ppat_alias (p,new_name),acc)
+  | Ppat_constant _ as x -> (x,acc)
+  | Ppat_tuple pl ->
+      let (pl,acc) = map_accum (pattern_subst ~by_name) acc pl in
+      (Ppat_tuple pl,acc)
+  | Ppat_construct (_,None,_) as x -> (x,acc)
+  | Ppat_construct (lid,Some p,b) ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     (Ppat_construct (lid,Some p,b),acc)
+  | Ppat_variant (_,None) as x -> (x,acc)
+  | Ppat_variant (l,Some p) ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     (Ppat_variant (l,Some p),acc)
+  | Ppat_record (pl,cf) ->
+      let (pl,acc) = map_accum (fun acc (l,p) -> 
+          let (p,acc) = pattern_subst ~by_name acc p in ((l,p),acc)) acc pl in
+      (Ppat_record (pl,cf),acc)
+  | Ppat_array pl ->
+      let (pl,acc) = map_accum (pattern_subst ~by_name) acc pl in
+      (Ppat_array pl,acc)
+  | Ppat_or (p1,p2) ->
+     let (p1,acc') = pattern_subst ~by_name acc p1 in
+     let (p2,_)   = pattern_subst ~by_name:true acc p2 in
+     (Ppat_or (p1,p2), acc')
+  | Ppat_constraint (p,cty) ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     (Ppat_constraint (p,cty), acc)
+  | Ppat_type _ as x -> (x,acc)
+  | Ppat_lazy p ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     (Ppat_lazy p, acc)
+  | Ppat_unpack _ as x -> (x,acc)
+ in
+ ({pat with ppat_desc = desc}, acc)
+
+
+let pattern_subst_list :
+    string loc list -> Parsetree.pattern list -> 
+     Parsetree.pattern list * string loc list = fun acc pl ->
+ map_accum (pattern_subst ~by_name:false) acc pl
+
+
+
+(* Build the general fun Parsetree *)
+let build_fun : 
+  Location.t -> string -> 
+  (* The following argument is a pair: a pattern list for the clauses
+     of the function, and the list of names of bound variables, in order.
+  *)
+  (Parsetree.pattern list * string loc list) -> 
+  (code_repr array -> code_repr array) -> code_repr =
+  fun l label (pats,old_names) fbodies -> 
+    let (names,vars,ebodies) = with_binding_region_gen l old_names fbodies in
+    let pats = 
+      if names = [] then pats else
+      let (pats,acc) = pattern_subst_list names pats in
+      assert (acc = []); pats
+    in
+    Code(vars,
+      {pexp_loc = l; 
+       pexp_desc = Pexp_function (label,None,
+                                  List.map2 (fun p e -> (p,e)) pats ebodies)})
+
+(* Build the general let-Parsetree (like the fun-Parsetree) *)
+let build_let : 
+  Location.t -> bool -> 
+  (Parsetree.pattern list * string loc list) -> code_repr array ->
+  (code_repr array -> code_repr array) -> code_repr =
+  fun l recf (pats,old_names) ecs fbodies ->
+    let (names,bvars,ebodies) = with_binding_region_gen l old_names fbodies in
+    let ebody = match ebodies with [x] -> x | _ -> assert false in
+    let pats = 
+      if names = [] then pats else
+      let (pats,acc) = pattern_subst_list names pats in
+      assert (acc = []); pats
+    in
+    let (es,evars) = validate_vars_list l (Array.to_list ecs) in
+    Code (merge evars bvars,
+          {pexp_loc = l; 
+           pexp_desc = 
+             Pexp_let ((if recf then Default else Nonrecursive), 
+                       List.map2 (fun p e -> (p,e)) pats es,ebody)})
+
+
+(* build match and try: both are very similar and similar to build_fun *)
+let build_match : 
+  Location.t -> (Parsetree.pattern list * string loc list) -> code_repr ->
+  (code_repr array -> code_repr array) -> code_repr =
+  fun l (pats,old_names) ec fbodies ->
+    let (names,bvars,ebodies) = with_binding_region_gen l old_names fbodies in
+    let pats = 
+      if names = [] then pats else
+      let (pats,acc) = pattern_subst_list names pats in
+      assert (acc = []); pats
+    in
+    let Code (evars,exp) = validate_vars l ec in
+    Code (merge evars bvars,
+     {pexp_loc = l; 
+      pexp_desc = Pexp_match (exp, List.map2 (fun p e -> (p,e)) pats ebodies)})
+
+
+(* Essentially the same as build_match.
+   TODO: implement the same check on the timestamp of the expression to try
+*)
+let build_try : 
+  Location.t -> (Parsetree.pattern list * string loc list) -> code_repr ->
+  (code_repr array -> code_repr array) -> code_repr =
+  fun l (pats,old_names) ec fbodies ->
+    let (names,bvars,ebodies) = with_binding_region_gen l old_names fbodies in
+    let pats = 
+      if names = [] then pats else
+      let (pats,acc) = pattern_subst_list names pats in
+      assert (acc = []); pats
+    in
+    let Code (evars,exp) = validate_vars l ec in
+    Code (merge evars bvars,
+     {pexp_loc = l; 
+      pexp_desc = Pexp_try (exp, List.map2 (fun p e -> (p,e)) pats ebodies)})
+
+
+(*}}}*)
+
+(* ------------------------------------------------------------------------ *)
+(* The main function to translate away brackets. It receives
+   an expression at the level n > 0.
+
+   Since bracket-translation is somewhat similar to un-typechecking,
+   see tools/untypeast.ml for hints on mapping Typedtree.expression
+   to Parsetree.expression.
+
+TODO: an optimization idea. Consider <assert e> as a typical expression.
+We translate it to the invocation of build_assert that will construct
+the Parsetree node at run-time. However, of 'e' is simple (e.g., a constant)
+then we can construct the Parsetree node at compile time and pass it
+as a CSP. There are no longer any functions calls to make at run-time.
+So, we can modify the translation of <assert e> below to detect
+if the translation of e produced Texp_cspval. We extract the CSP value,
+invoke build_assert (at compile time, when trx.ml is run) to build
+the Pexp_assert node, and wrap it as a CSP.
+
+Essentially the result of trx_bracket should be like
+   Transl_bracket of Parsetree.expression option * Typedtree.expression
+The first part of the result is the code built-in at compile time.
+This part is None of the expression to translate contains an escape
+or a true CSP (global id is OK). Sometimes we need both parts: consider
+       <fun x -> x + ~(...)>
+When we translate x we don't know if we can take a shortcut and
+build the function code at translation time. So, we have to account
+for both possibilities. If we can build the function at compile time,
+we don't even need to rename the bound variable!
+
+*)
+
+(* Given a type [ty], return [ty code code ... code] (n times code).
+   When we push the bracket in, expressions that had type ty before
+   will have the type ty code.
+   Here, ty code is an abstract type whose concrete representation
+   is code_repr.
+   Generally speaking we don't have to adjust the types since the
+   type checking is finished. However, code generator may look
+   at types; it's better if we don't lie. Thus, as trx_bracket
+   translates the expression, it should also adjust the types.
+*)
+
+let rec wrap_ty_in_code : int -> type_expr -> type_expr = fun n ty ->
+  if n=0 then ty else
+  (* let clsfier = Btype.newgenvar () in *)
+  wrap_ty_in_code (n-1) (Predef.type_code ty)
+
+let map_option : ('a -> 'b) -> 'a option -> 'b option = fun f -> function
+  | None   -> None
+  | Some x -> Some (f x)
+
+
+let rec trx_bracket : 
+  (expression -> expression) -> (* 0-level traversal *)
+  int -> (expression -> expression) = fun trx_exp n exp ->
+  let new_desc = match exp.exp_desc with
+    (* Don't just do when vd.val_kind = Val_reg 
+       because (+) or Array.get are Val_prim *)
+  | Texp_ident (p,li,vd)  ->
+    let stage = try Env.find_stage p exp.exp_env
+	        with Not_found ->
+                  if false then
+                    debug_print ("Stage for var is set to implicit 0:" ^ 
+	                         Path.name p ^ "\n");  0 in
+    (* We make CSP only if the variable is bound at the stage 0.
+       Variables bound at stage > 0 are subject to renaming.
+       They are translated into stage 0 variable but of a different
+       type (t code), as explained in the title comments.
+     *)
+    if stage = 0 then trx_csp exp p li 
+    else
+         (* Future-stage bound variable becomes the present-stage
+            bound-variable, but at a different type.
+          *)
+      let () = assert (vd.val_kind = Val_reg) in
+      (* The drawback is that exp.exp_loc disappears. If the scope extrusion
+         is reported for a simple expression like <x>, we can no longer
+         print in the error message the location that <x> appeared.
+         We can only print the location x was bound.
+      *)
+      Texp_ident (p,li,{vd with val_type = wrap_ty_in_code n vd.val_type})
+
+  | Texp_constant cst -> 
+      texp_code ~node_id:"*cst*" exp.exp_loc (Pexp_constant cst)
+
+     (* Recursive let: 
+         let rec f = e1 [and g = e2 ...] in body
+        According to transl_let in bytecomp/translcore.ml,
+        the patterns in recursive let are very restrictive: elther
+          let rec var = ...
+        or
+          let rec _ as var = ...
+       For instance, let rec (x1,x2) = ... is not allowed.
+       We do this test here. For simplicity, we are not going to support
+          let rec _ as var = ...
+       pattern.
+      *)
+  | Texp_let (Recursive,pel,ebody) ->
+      let names =                       (* in the order of appearance *)
+        let rec loop = function
+          | [] -> []
+          | ({pat_desc = Tpat_var (_,name)},_) :: rest -> name :: loop rest
+          | _ -> trx_error ~loc:exp.exp_loc (fun ppf -> Format.fprintf ppf
+                "Only variables are allowed as left-hand side of `let rec'")
+        in loop pel
+      in
+      (* code for body followed by the code for e's *)
+      let es_body = texp_array (
+        trx_bracket trx_exp n ebody ::
+          (List.map (fun (_,e) -> trx_bracket trx_exp n e) pel)) in
+      texp_apply (texp_ident "Trx.build_letrec") 
+        [texp_loc exp.exp_loc;
+         texp_array (List.map texp_string_loc names);
+             (* Translate the future-stage function as the present-stage 
+                function whose argument is an array of variables 
+                (should be a tuple, really) and the type
+                   some_targ code array -> tres code array
+                See the comment at Texp_function below for details.
+              *)
+         let pats = List.map (fun (p,_) -> 
+                      {p with pat_type = wrap_ty_in_code n p.pat_type}) pel in
+         let p1 = (match pats with h::_ -> h | _ -> assert false) in
+         let pat = {p1 with
+                    pat_desc = Tpat_array pats;
+                    pat_type = 
+                        Ctype.instance_def (Predef.type_array p1.pat_type)} in
+         { exp with
+           exp_desc = Texp_function ("",[(pat, es_body)],Total);
+           exp_type = {exp.exp_type with desc =
+                           Tarrow ("",pat.pat_type, es_body.exp_type, Cok)}
+         }
+       ]
+
+     (* The most common case of let-expressions: non-recursive
+        let x = e in body *)
+     (* recf = Default for a let auto-generated by the type
+        checker for the default function argument.
+      *)
+  | Texp_let (recf,[({pat_desc = Tpat_var (_,name)} as pat,e)],ebody) ->
+      let pat = {pat with pat_type = wrap_ty_in_code n pat.pat_type} in
+      texp_apply (texp_ident "Trx.build_let_simple_nonrec") 
+        [texp_loc exp.exp_loc;
+         texp_string_loc name;
+         texp_bool (recf = Default);
+         trx_bracket trx_exp n e;
+         { exp with
+           exp_desc = 
+             Texp_function ("",[(pat, trx_bracket trx_exp n ebody)],Total);
+           exp_type = 
+            {exp.exp_type with desc =
+               Tarrow ("",pat.pat_type, wrap_ty_in_code n ebody.exp_type, Cok)}
+         }
+       ]
+
+    (* General-case, non-recursive let General case. Like Texp_function *)
+  | Texp_let (recf,pel,body) ->
+      let (pl,names,binding_pat) = 
+        trx_pel pel (wrap_ty_in_code n (Btype.newgenvar ())) in
+      texp_apply (texp_ident "Trx.build_let") 
+        [texp_loc exp.exp_loc;
+         texp_bool (recf = Default);
+         texp_pats_names pl names;
+         texp_array (List.map (fun (_,e) -> trx_bracket trx_exp n e) pel);
+         (* See the comment at Texp_function below *)
+         let body = texp_array [trx_bracket trx_exp n body] in
+         { exp with
+           exp_desc = Texp_function ("",[(binding_pat, body)],Total);
+           exp_type = {exp.exp_type with desc =
+                       Tarrow ("",binding_pat.pat_type, body.exp_type, Cok)}
+         }
+       ]
+
+     (* The most common case of functions: fun x -> body *)
+  | Texp_function (l,[({pat_desc = Tpat_var (_,name)} as pat,ebody)],_) ->
+      let pat = {pat with pat_type = wrap_ty_in_code n pat.pat_type} in
+      texp_apply (texp_ident "Trx.build_fun_simple") 
+        [texp_loc exp.exp_loc;
+         texp_string l;
+         texp_string_loc name;
+         (* Translate the future-stage function as present-stage function;
+            with the same variables, but with a different type,
+            targ code -> tres code
+          *)
+         { exp with
+           exp_desc = 
+             Texp_function ("",[(pat, trx_bracket trx_exp n ebody)],Total);
+           exp_type = 
+            {exp.exp_type with desc =
+               Tarrow ("",pat.pat_type, wrap_ty_in_code n ebody.exp_type, Cok)}
+         }
+       ]
+
+  | Texp_function (l,pel,_) ->
+      begin
+      match trx_pel pel (wrap_ty_in_code n (Btype.newgenvar ())) with
+      | (pl, [], _) ->                    (* non-binding pattern *)
+          texp_apply (texp_ident "Trx.build_fun_nonbinding")
+            [texp_loc exp.exp_loc; 
+             texp_string l;
+             begin 
+               let pl_exp = texp_ident "Trx.sample_pat_list" in
+               {pl_exp with
+                exp_desc = Texp_cspval (Obj.repr pl, dummy_lid "*pl*")}
+             end;
+             texp_array (List.map (fun (_,e) -> trx_bracket trx_exp n e) pel)
+           ]
+      | (pl, names, binding_pat) ->
+          texp_apply (texp_ident "Trx.build_fun") 
+            [texp_loc exp.exp_loc;
+             texp_string l;
+             texp_pats_names pl names;
+             (* Translate the future-stage function as the present-stage 
+                function whose argument is an array of variables 
+                (should be a tuple, really) and the type
+                   some_targ code array -> tres code array
+                Using array forces a single type to all arguments. Although
+                it is phantom anyway, it is still a bummer. Instead of
+                array, we should have used a tuple. But then we can't
+                generically write build_fun.
+              *)
+               (* Pattern representing the function's argument:
+                  array of variables bound by the original pattern, in order.
+                *)
+             let body = texp_array (List.map (fun (_,e) -> 
+                                     trx_bracket trx_exp n e) pel) in
+             { exp with
+                exp_desc = Texp_function ("",[(binding_pat, body)],Total);
+                exp_type = {exp.exp_type with desc =
+                            Tarrow ("",binding_pat.pat_type, body.exp_type, 
+                                    Cok)}
+             }
+           ]
+      end
+
+  | Texp_apply (e, el) ->
+     (* first, we remove from el the information added by the type-checker *)
+     let lel = List.fold_right (function                 (* keep the order! *)
+                | (_,None,_)   -> fun acc -> acc
+                | (l,Some e,_) -> fun acc -> (l,e)::acc) el [] in
+     let lel = ("",e) :: lel in          (* Add the operator *)
+      texp_apply (texp_ident "Trx.build_apply")
+        [texp_loc exp.exp_loc; 
+         texp_array (List.map (fun (l,e) ->
+           texp_tuple [texp_string l;trx_bracket trx_exp n e]) lel)]
+
+  (* Pretty much like a function *)
+  | Texp_match (e,pel,_) ->
+      let (pl,names,binding_pat) = 
+        trx_pel pel (wrap_ty_in_code n (Btype.newgenvar ())) in
+      texp_apply (texp_ident "Trx.build_match") 
+        [texp_loc exp.exp_loc;
+         texp_pats_names pl names;
+         trx_bracket trx_exp n e;
+         (* See the comment at Texp_function above *)
+         let body = texp_array (List.map (fun (_,e) -> 
+                                     trx_bracket trx_exp n e) pel) in
+         { exp with
+           exp_desc = Texp_function ("",[(binding_pat, body)],Total);
+           exp_type = {exp.exp_type with desc =
+                       Tarrow ("",binding_pat.pat_type, body.exp_type, Cok)}
+         }
+       ]
+
+  | Texp_try (e,pel) ->                 (* same as Texp_match *)
+      let (pl,names,binding_pat) = 
+        trx_pel pel (wrap_ty_in_code n (Btype.newgenvar ())) in
+      texp_apply (texp_ident "Trx.build_try") 
+        [texp_loc exp.exp_loc;
+         texp_pats_names pl names;
+         trx_bracket trx_exp n e;
+         (* See the comment at Texp_function above *)
+         let body = texp_array (List.map (fun (_,e) -> 
+                                     trx_bracket trx_exp n e) pel) in
+         { exp with
+           exp_desc = Texp_function ("",[(binding_pat, body)],Total);
+           exp_type = {exp.exp_type with desc =
+                       Tarrow ("",binding_pat.pat_type, body.exp_type, Cok)}
+         }
+       ]
+
+  | Texp_tuple el ->
+      texp_apply (texp_ident "Trx.build_tuple")
+        [texp_loc exp.exp_loc; 
+	 texp_array (List.map (trx_bracket trx_exp n) el)]
+
+  | Texp_construct (li, cdesc, args, explicit_arity) ->
+      let lid = qualify_ctor li cdesc in
+      texp_apply (texp_ident "Trx.build_construct")
+        [texp_loc exp.exp_loc; 
+         texp_lid lid;
+	 texp_array (List.map (trx_bracket trx_exp n) args);
+         texp_bool explicit_arity]
+
+  | Texp_variant (l,eo) ->              (* polymorphic variant *)
+      texp_apply (texp_ident "Trx.build_variant")
+        [texp_loc exp.exp_loc; 
+         texp_string l;
+	 texp_option (map_option (trx_bracket trx_exp n) eo)]
+
+  | Texp_record (lel,eo) ->
+      texp_apply (texp_ident "Trx.build_record")
+        [texp_loc exp.exp_loc; 
+         texp_array (List.map (fun (li,ldesc,e) ->
+           texp_tuple [texp_lid (qualify_label li ldesc);
+                       trx_bracket trx_exp n e]) lel);
+         texp_option (map_option (trx_bracket trx_exp n) eo)]
+
+  | Texp_field (e,li,ldesc) ->
+      texp_apply (texp_ident "Trx.build_field")
+        [texp_loc exp.exp_loc; 
+         trx_bracket trx_exp n e;
+         texp_lid (qualify_label li ldesc)]
+
+  | Texp_setfield (e1,li,ldesc,e2) ->
+      texp_apply (texp_ident "Trx.build_setfield")
+        [texp_loc exp.exp_loc; 
+         trx_bracket trx_exp n e1;
+         texp_lid (qualify_label li ldesc);
+         trx_bracket trx_exp n e2]
+
+  | Texp_array el ->
+      texp_apply (texp_ident "Trx.build_array")
+        [texp_loc exp.exp_loc; 
+	 texp_array (List.map (trx_bracket trx_exp n) el)]
+
+  | Texp_ifthenelse (e,et,efo) ->
+      texp_apply (texp_ident "Trx.build_ifthenelse")
+        [texp_loc exp.exp_loc; 
+         trx_bracket trx_exp n e;
+         trx_bracket trx_exp n et;
+	 texp_option (map_option (trx_bracket trx_exp n) efo)]
+
+  | Texp_sequence (e1,e2) ->
+      texp_apply (texp_ident "Trx.build_sequence")
+        [texp_loc exp.exp_loc; 
+	 trx_bracket trx_exp n e1; trx_bracket trx_exp n e2]
+  | Texp_while (e1,e2) ->
+      texp_apply (texp_ident "Trx.build_while")
+        [texp_loc exp.exp_loc; 
+	 trx_bracket trx_exp n e1; trx_bracket trx_exp n e2]
+
+  | Texp_for (id, name, elo, ehi, dir, ebody) ->
+      texp_apply (texp_ident "Trx.build_for") 
+        [texp_loc exp.exp_loc;
+         texp_string_loc name;
+         trx_bracket trx_exp n elo;
+         trx_bracket trx_exp n ehi;
+         texp_bool (dir = Upto);
+         let var_typ = wrap_ty_in_code n (Ctype.instance_def Predef.type_int) in
+         let pat = {pat_loc = exp.exp_loc; pat_extra = [];
+                    pat_type = var_typ; pat_env = exp.exp_env;
+                    pat_desc = Tpat_var (id,name)} in
+         { exp with
+           exp_desc = 
+             Texp_function ("",[(pat, trx_bracket trx_exp n ebody)],Total);
+           exp_type = 
+            {exp.exp_type with desc =
+               Tarrow ("",var_typ, wrap_ty_in_code n ebody.exp_type, Cok)}
+         }
+       ]
+
+  | Texp_when (e1,e2) ->
+      texp_apply (texp_ident "Trx.build_when")
+        [texp_loc exp.exp_loc; 
+	 trx_bracket trx_exp n e1; trx_bracket trx_exp n e2]
+
+  | Texp_send (e,m,_) ->
+      (* We don't check the persistence of the method: after all,
+         a method name is somewhat like a polymorphic variant.
+         It's perfectly OK to have a function fun x -> x # foo
+      *)
+      texp_apply (texp_ident "Trx.build_send")
+        [texp_loc exp.exp_loc; 
+	 trx_bracket trx_exp n e;
+         texp_string (match m with
+                        | Tmeth_name name -> name
+                        | Tmeth_val id -> Ident.name id)]
+
+  | Texp_new (p,li,_) ->
+      check_path_quotable "Class" p;
+      texp_code ~node_id:"*new*" exp.exp_loc 
+        (Pexp_new (Location.mkloc (path_to_lid p) li.loc))
+
+  | Texp_instvar (p1,p2,s) ->
+      not_supported exp.exp_loc "Objects (Texp_instvar)"
+        (* Alternatively: since instance variables are always bound 
+           at level 0 (for now)
+           so this is like a csp variable 
+        call_trx_mkcsp exp None (path_to_lid p2)
+        *)
+  | Texp_setinstvar _ -> not_supported exp.exp_loc "Objects (Texp_setinstvar)"
+  | Texp_override  _  -> not_supported exp.exp_loc "Objects (Texp_override)"
+  | Texp_letmodule (id,s,me,e) -> not_supported exp.exp_loc "let module"
+
+  | Texp_assert e ->
+      texp_apply (texp_ident "Trx.build_assert")
+        [texp_loc exp.exp_loc; trx_bracket trx_exp n e]
+  | Texp_assertfalse ->
+      texp_code ~node_id:"*af*" exp.exp_loc Pexp_assertfalse
+
+  | Texp_lazy e ->
+      texp_apply (texp_ident "Trx.build_lazy")
+        [texp_loc exp.exp_loc; trx_bracket trx_exp n e]
+
+  | Texp_object (cl,fl) -> not_supported exp.exp_loc "Objects"
+  | Texp_pack _         -> not_supported exp.exp_loc "First-class modules"
+
+  | Texp_bracket e ->
+      texp_apply (texp_ident "Trx.build_bracket")
+        [texp_loc exp.exp_loc; trx_bracket trx_exp (n+1) e]
+  | Texp_escape e ->
+      if n = 1 then (trx_exp e).exp_desc	(* switch to 0 level *)
+      else
+      texp_apply (texp_ident "Trx.build_escape")
+        [texp_loc exp.exp_loc; trx_bracket trx_exp (n-1) e]
+  | Texp_cspval (v,li) ->               (* CSP is a sort of a constant *)
+      texp_code ~node_id:"*csp*" exp.exp_loc (Pexp_cspval(v,li))
+
+  (* | _ -> not_supported exp.exp_loc "not yet supported" *)
+  in                               
+  let trx_extra (extra, loc) exp = (* See untype_extra in tools/untypeast.ml *)
+   let desc =
+    match extra with
+      (* Should check that cty1 and cty2 contain only globally declared
+         type components
+       *)
+    | Texp_constraint (cty1, cty2) -> 
+        not_supported loc "Texp_constraint"
+    | Texp_open (ovf, path, lid, _) -> 
+       check_path_quotable "Texp_open" path;
+       let ovf_exp = texp_ident "Trx.sample_override_flag" in
+       let ovf_exp = {ovf_exp with exp_desc = 
+                        Texp_cspval (Obj.repr ovf, dummy_lid "*ovf*")} in
+       texp_apply (texp_ident "Trx.build_open")
+        [texp_loc exp.exp_loc;
+         texp_lid (mkloc (path_to_lid path) lid.loc);
+         ovf_exp;
+         exp]      (* exp is the result of trx_bracket *)
+    | Texp_poly cto  -> not_supported loc "Texp_poly"
+    | Texp_newtype s -> not_supported loc "Texp_newtype"
+    in {exp with exp_loc = loc; exp_desc = desc} (* type is the same: code *)
+  in
+  List.fold_right trx_extra exp.exp_extra
+  {exp with exp_type = wrap_ty_in_code n exp.exp_type;
+            exp_desc = new_desc}
+
+
+
+(*{{{ Typedtree traversal to eliminate bracket/escapes *)
+
+(* ------------------------------------------------------------------------ *)
+(* Typedtree traversal to eliminate bracket/escapes *)
+
+(* Functions to help traverse and transform a tree.
+   We assume that every tree mapping function of the type 'a -> 'a
+   throws the exception Not_modified if the tree has not been
+   modified.
+   This protocol helps minimize garbage and prevent useless tree
+   duplication.
+*)
+
+exception Not_modified
+
+let replace_list : ('a -> 'a) -> 'a list -> 'a list = fun f l ->
+  let rec loop mdf = function
+  | [] -> if mdf then [] else raise Not_modified
+  | h::t -> match (try Some (f h) with Not_modified -> None) with
+             | Some h -> h :: loop true t
+             | None   -> h :: loop mdf  t
+  in loop false l
+
+let replace_pair : ('a -> 'a) -> ('b -> 'b) -> 'a * 'b -> 'a * 'b =
+  fun f g (x,y) ->
+  match ((try Some (f x) with Not_modified -> None),
+         (try Some (g y) with Not_modified -> None)) with
+  | (None,None)      -> raise Not_modified
+  | (Some x, None)   -> (x,y)
+  | (None, Some y)   -> (x,y)
+  | (Some x, Some y) -> (x,y)
+
+let replace_opt : ('a -> 'a) -> 'a option -> 'a option = fun f -> function
+  | Some e -> Some (f e)
+  | None   -> raise Not_modified
+
+(* The main function to scan the typed tree at the 0 level and
+   detect brackets 
+*)
+
+let rec trx_struct str =
+  {str with str_items = 
+  replace_list (fun si -> {si with str_desc = trx_struct_item si.str_desc})
+           str.str_items}
+
+and trx_struct_item = function
+| Tstr_eval e -> Tstr_eval (trx_exp e)
+| Tstr_value (rf,pel) ->
+    Tstr_value(rf, replace_list (fun (p,e) -> (p, trx_exp e)) pel)
+| Tstr_primitive (_,_,_) 
+| Tstr_type _
+| Tstr_exception (_,_,_)
+| Tstr_exn_rebind (_,_,_,_) -> raise Not_modified
+| Tstr_module (i,l,me) -> Tstr_module (i, l, trx_me me)
+| Tstr_recmodule l ->
+  Tstr_recmodule (replace_list (fun (i,l,mt,me) -> (i,l,mt,trx_me me)) l)
+| Tstr_modtype (_,_,_)
+| Tstr_open (_,_,_) -> raise Not_modified
+| Tstr_class l ->
+    Tstr_class (replace_list (fun (dcl,sl,vf) -> (trx_cdcl dcl,sl,vf)) l)
+| Tstr_class_type _ -> raise Not_modified
+| Tstr_include (me,il) -> Tstr_include (trx_me me, il)
+
+and trx_me me = 
+  {me with mod_desc = trx_me_desc me.mod_desc} 
+
+and trx_me_desc = function
+| Tmod_ident _ -> raise Not_modified
+| Tmod_structure str -> Tmod_structure (trx_struct str)
+| Tmod_functor (i,l,t,me) -> Tmod_functor (i,l,t, trx_me me)
+| Tmod_apply (me1,me2,mc) ->
+  let (me1,me2) = replace_pair trx_me trx_me (me1,me2) in
+  Tmod_apply (me1, me2, mc)
+| Tmod_constraint (me,mt,mtc,mc) -> Tmod_constraint (trx_me me, mt, mtc, mc)
+| Tmod_unpack (e,mt) -> Tmod_unpack (trx_exp e,mt)
+
+and trx_cdcl class_decl =
+  {class_decl with ci_expr = trx_ce class_decl.ci_expr}
+
+and trx_ce class_expr =
+  {class_expr with cl_desc = trx_ce_desc class_expr.cl_desc}
+
+and trx_cl_struct cs =
+  {cs with cstr_fields = 
+     replace_list (fun cf -> {cf with cf_desc = trx_cf cf.cf_desc})
+                  cs.cstr_fields}
+
+and trx_ce_desc = function
+| Tcl_ident (_,_,_) -> raise Not_modified
+| Tcl_structure cs ->
+  Tcl_structure (trx_cl_struct cs)
+| Tcl_fun (l,p,el,ce,pa) ->
+  let (el,ce) = 
+        replace_pair (replace_list (fun (i,l,e) -> (i,l,trx_exp e)))
+                     trx_ce (el,ce) in
+  Tcl_fun (l,p,el,ce,pa)
+| Tcl_apply (ce,el) ->
+  let repel (l,eo,o) = (l,replace_opt trx_exp eo,o) in
+  let (ce,el) = replace_pair trx_ce (replace_list repel) (ce,el) in
+  Tcl_apply (ce,el)
+| Tcl_let (rf,el1,el2,ce) ->
+  let repel1 = replace_list (fun (p,e) -> (p,trx_exp e)) in
+  let repel2 = replace_list (fun (i,l,e) -> (i,l,trx_exp e)) in
+  let ((el1,el2),ce) = replace_pair (replace_pair repel1 repel2) trx_ce
+                        ((el1,el2),ce)
+  in Tcl_let (rf,el1,el2,ce)
+| Tcl_constraint (ce,ct,sl1,sl2,cty) ->
+  Tcl_constraint (trx_ce ce,ct,sl1,sl2,cty)
+
+and trx_cf = function
+| Tcf_inher (ofl,ce,so,sl1,sl2) ->
+  Tcf_inher (ofl,trx_ce ce,so,sl1,sl2)
+| Tcf_val (_,_,_,_,Tcfk_virtual _,_) -> raise Not_modified
+| Tcf_val (s,l,mf,i,Tcfk_concrete e,b) ->
+  Tcf_val (s,l,mf,i,Tcfk_concrete (trx_exp e),b)
+| Tcf_meth (s,l,pf,Tcfk_virtual _,_) -> raise Not_modified
+| Tcf_meth (s,l,pf,Tcfk_concrete e,b) ->
+  Tcf_meth (s,l,pf,Tcfk_concrete (trx_exp e),b)
+| Tcf_constr (_,_) -> raise Not_modified
+| Tcf_init e -> Tcf_init (trx_exp e)
+
+and trx_exp exp =
+  {exp with exp_desc = trx_expression exp.exp_desc}
+
+and trx_pelist l = replace_list (fun (p,e) -> (p,trx_exp e)) l
+and trx_expression = function
+| Texp_ident (_,_,_)
+| Texp_constant _ -> raise Not_modified
+| Texp_let (rf, el, e) ->
+  let (el,e) = replace_pair trx_pelist trx_exp (el,e)
+  in Texp_let (rf, el, e)
+| Texp_function (l,el,p) ->
+  Texp_function (l,trx_pelist el,p)
+| Texp_apply (e,el) ->
+  let repl (l,eo,op) = (l,replace_opt trx_exp eo,op) in
+  let (e,el) = replace_pair trx_exp (replace_list repl) (e,el)
+  in Texp_apply (e,el)
+| Texp_match (e,el,p) ->
+  let (e,el) = replace_pair trx_exp trx_pelist (e,el)
+  in Texp_match (e,el,p)
+| Texp_try (e,el) ->
+  let (e,el) = replace_pair trx_exp trx_pelist (e,el)
+  in Texp_try (e,el)
+| Texp_tuple l -> Texp_tuple (replace_list trx_exp l)
+| Texp_construct (l,cd,el,b) ->
+  Texp_construct (l,cd,replace_list trx_exp el,b)
+| Texp_variant (l,eo) -> Texp_variant (l,replace_opt trx_exp eo)
+| Texp_record (ll,eo) ->
+  let repll (l,ld,e) = (l,ld,trx_exp e) in
+  let (ll,eo) = replace_pair (replace_list repll) (replace_opt trx_exp) (ll,eo)
+  in Texp_record (ll,eo)
+| Texp_field (e,l,ld) -> Texp_field (trx_exp e,l,ld)
+| Texp_setfield (e1,l,ld,e2) ->
+  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
+  in Texp_setfield (e1,l,ld,e2)
+| Texp_array el -> Texp_array (replace_list trx_exp el)
+| Texp_ifthenelse (e1,e2,eo) ->
+  let ((e1,e2),eo) = replace_pair (replace_pair trx_exp trx_exp) 
+                                  (replace_opt trx_exp) ((e1,e2),eo)
+  in Texp_ifthenelse (e1,e2,eo)
+| Texp_sequence (e1,e2) -> 
+  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
+  in Texp_sequence (e1,e2)
+| Texp_while (e1,e2) ->
+  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
+  in Texp_while (e1,e2)
+| Texp_for (i,l,e1,e2,df,e3) ->
+  let ((e1,e2),e3) = replace_pair (replace_pair trx_exp trx_exp) 
+                                  trx_exp ((e1,e2),e3)
+  in Texp_for (i,l,e1,e2,df,e3)
+| Texp_when (e1,e2) ->
+  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
+  in Texp_when (e1,e2)
+| Texp_send (e1,m,eo) ->
+  let (e1,eo) = replace_pair trx_exp (replace_opt trx_exp) (e1,eo)
+  in Texp_send (e1,m,eo)
+| Texp_new (_,_,_)
+| Texp_instvar (_,_,_) -> raise Not_modified
+| Texp_setinstvar (p1,p2,l,e) -> Texp_setinstvar (p1,p2,l,trx_exp e)
+| Texp_override (p, el) ->
+  Texp_override (p, replace_list (fun (p,l,e) -> (p,l,trx_exp e)) el)
+| Texp_letmodule (i,l,me,e) ->
+  let (me,e) = replace_pair trx_me trx_exp (me,e)
+  in Texp_letmodule (i,l,me,e)
+| Texp_assert e -> Texp_assert (trx_exp e)
+| Texp_assertfalse -> raise Not_modified
+| Texp_lazy e -> Texp_lazy (trx_exp e)
+| Texp_object (cs,sl) -> Texp_object (trx_cl_struct cs,sl)
+| Texp_pack me -> Texp_pack (trx_me me)
+
+| Texp_bracket e -> 
+   let trx_exp e = try trx_exp e with Not_modified -> e in
+  (trx_bracket trx_exp 1 e).exp_desc
+
+| Texp_escape _ -> assert false         (* Not possible in well-typed code *)
+| Texp_cspval (_,_) -> raise Not_modified
+
+
+(* public interface *)
+let trx_structure str = 
+  try trx_struct str with Not_modified -> str
+
+(*}}}*)
+
+  
diff --git a/ber-metaocaml-101/patches/trx.mli b/ber-metaocaml-101/patches/trx.mli
new file mode 100644
index 0000000..4990889
--- /dev/null
+++ b/ber-metaocaml-101/patches/trx.mli
@@ -0,0 +1,128 @@
+(* BER MetaOCaml compilation
+   Transforming the Typedtree to eliminate brackets and escapes,
+   replacing them with calls to ordinary OCaml functions
+   to build the code representation (that is, Parsetree).
+*)
+
+val meta_version : string
+(** [meta_version] is the version of BER MetaOCaml*)
+
+(* The function to post-process the typed tree and translate away
+   brackets and escapes 
+*)
+val trx_structure: Typedtree.structure -> Typedtree.structure
+
+(* The following functions operate on untyped code_repr.
+   We cannot use the type constructor 'code' here since
+   it is not available in the bootstrap compiler.
+*)
+
+(* The representation of possibly code: abstract *)
+type code_repr
+
+type closed_code_repr = private Parsetree.expression
+
+(* Check that the code is closed and return the closed code *)
+val close_code_repr : code_repr -> closed_code_repr
+
+(* The same as close_code but return the closedness check as a thunk
+   rather than performing it.
+   This is useful for debugging and for showing the code:
+   If there is a scope extrusion error, it is still useful
+   to show the code with the extrusion before throwing the scope-extrusion
+   exception.
+*)
+val close_code_delay_check : code_repr -> closed_code_repr * (unit -> unit)
+
+(* Total: a closed code can always be used in slices, etc. *)
+val open_code : closed_code_repr -> code_repr
+
+(* Adjusting the implementation of stackmarks -- needed when delimited
+   control is used (other than mere exceptions).
+*)
+type stackmark = unit -> bool           (* true if valid *)
+type stackmark_region_fn = 
+    {stackmark_region_fn : 'w. (stackmark -> 'w) -> 'w}
+val set_with_stack_mark : stackmark_region_fn -> unit
+
+
+(* The following names are used by Trx itself to construct a Parsetree
+   or as templates to build the Typedtree.
+   Trx may generate code the refers to the functions below.
+   Therefore, do NOT rename the functions or change their types!
+*)
+
+val sample_lid  : Longident.t Location.loc  (* A template for lid expressions *)
+val sample_loc  : Location.t
+val sample_name : string Location.loc
+val sample_pat_list : Parsetree.pattern list
+val sample_pats_names : Parsetree.pattern list * string Location.loc list
+val sample_rec_flag : Asttypes.rec_flag
+val sample_override_flag : Asttypes.override_flag
+
+        (* Run-time quotator *)
+val dyn_quote  : Obj.t -> Longident.t Location.loc -> code_repr
+
+val lift_constant_int  : int  -> code_repr
+val lift_constant_char : char -> code_repr
+val lift_constant_bool : bool -> code_repr
+
+(* Builders of the Parsetree *)
+val build_assert   : Location.t -> code_repr -> code_repr
+val build_lazy     : Location.t -> code_repr -> code_repr
+val build_bracket  : Location.t -> code_repr -> code_repr
+val build_escape   : Location.t -> code_repr -> code_repr
+
+val build_sequence : Location.t -> code_repr -> code_repr -> code_repr
+val build_while    : Location.t -> code_repr -> code_repr -> code_repr
+val build_when     : Location.t -> code_repr -> code_repr -> code_repr
+
+val build_apply : Location.t -> (Asttypes.label * code_repr) array -> code_repr
+
+val build_tuple : Location.t -> code_repr array -> code_repr
+val build_array : Location.t -> code_repr array -> code_repr
+val build_ifthenelse : 
+  Location.t -> code_repr -> code_repr -> code_repr option -> code_repr
+val build_construct  :
+ Location.t -> Longident.t Location.loc -> code_repr array -> bool -> code_repr
+val build_record :
+ Location.t -> (Longident.t Location.loc * code_repr) array ->
+ code_repr option -> code_repr
+val build_field :
+ Location.t -> code_repr -> Longident.t Location.loc -> code_repr
+val build_setfield :
+ Location.t -> code_repr -> Longident.t Location.loc -> code_repr -> code_repr
+val build_variant  : Location.t -> string -> code_repr option -> code_repr
+val build_send     : Location.t -> code_repr -> string -> code_repr
+val build_open :
+ Location.t -> Longident.t Location.loc -> Asttypes.override_flag -> 
+   code_repr -> code_repr
+val build_fun_nonbinding : 
+  Location.t -> string -> Parsetree.pattern list -> 
+  code_repr array -> code_repr
+
+val build_fun_simple : 
+  Location.t -> string -> string Location.loc -> 
+  (code_repr -> code_repr) -> code_repr
+val build_for : 
+  Location.t -> string Location.loc -> code_repr -> code_repr -> 
+  bool -> (code_repr -> code_repr) -> code_repr
+val build_let_simple_nonrec : 
+  Location.t -> string Location.loc -> bool -> code_repr -> 
+    (code_repr -> code_repr) -> code_repr
+val build_letrec : 
+  Location.t -> string Location.loc array -> 
+    (code_repr array -> code_repr array) -> code_repr
+val build_fun : Location.t -> string -> 
+  (Parsetree.pattern list * string Location.loc list) -> 
+  (code_repr array -> code_repr array) -> code_repr
+val build_let : 
+  Location.t -> bool -> 
+  (Parsetree.pattern list * string Location.loc list) -> code_repr array ->
+  (code_repr array -> code_repr array) -> code_repr
+val build_match : 
+  Location.t -> (Parsetree.pattern list * string Location.loc list) -> 
+  code_repr -> (code_repr array -> code_repr array) -> code_repr
+val build_try : 
+  Location.t -> (Parsetree.pattern list * string Location.loc list) -> 
+  code_repr -> (code_repr array -> code_repr array) -> code_repr
diff --git a/ber-metaocaml-101/print_code.ml b/ber-metaocaml-101/print_code.ml
new file mode 100644
index 0000000..d14edde
--- /dev/null
+++ b/ber-metaocaml-101/print_code.ml
@@ -0,0 +1,45 @@
+(* Printing code expressions *)
+
+(* The original code was authored by  Ed Pizzi
+   and simplified by Jacques Carette.
+   It is latter borrowed into the main OCaml tree,
+   as parsing/pprintast.ml.
+   It was extensively rewritten by Hongbo Zhang: University of Pennsylvania
+   and modified by Thomas Gazagnaire (OCamlPro) and
+   Fabrice Le Fessant (INRIA Saclay).
+
+   We now rely on the OCaml's code.
+*)
+
+open Format
+open Runcode
+open Parsetree
+
+
+(* print code as a parse tree. Useful for debugging *)
+let print_code_as_ast cde =
+  let cde = (cde : Trx.closed_code_repr :> Parsetree.expression) in
+  Printast.implementation Format.std_formatter
+  [{ pstr_desc = Pstr_eval (cde);
+     pstr_loc  = Location.none }]
+
+let format_code : Format.formatter -> 'a closed_code -> unit = fun ppf cde ->
+  let cde = (cde : Trx.closed_code_repr :> Parsetree.expression) in
+  Pprintast.expression ppf cde
+
+(* These functions are suitable for installing as printers
+   at the toplevel, using top-level directive install printer.
+   Don't rename these functions or change their types.
+   See bertop.ml, which refers to these functions by their external
+   symbolic name.
+*)
+
+let print_closed_code  : Format.formatter -> 'a closed_code -> unit = 
+  fun ppf cde ->  
+    Format.fprintf ppf ".<@,%a>.@ " format_code cde
+
+let print_code ppf (cde : 'a code) = 
+  let (cde, check) = close_code_delay_check cde in
+  print_closed_code ppf cde;
+  try check ()
+  with e -> fprintf ppf "\n%s" (Printexc.to_string e)
diff --git a/ber-metaocaml-101/print_code.mli b/ber-metaocaml-101/print_code.mli
new file mode 100644
index 0000000..82bb97f
--- /dev/null
+++ b/ber-metaocaml-101/print_code.mli
@@ -0,0 +1,18 @@
+(* Printing code expressions *)
+
+open Runcode
+
+(* Print code values, useful as formatter.
+   The code is printed with outer brackets 
+*)
+val print_code         : Format.formatter -> 'a code -> unit
+val print_closed_code  : Format.formatter -> 'a closed_code -> unit
+
+(* Like print_closed_code, but omit the outer brackets.
+   This function is useful when saving the generated code into a file,
+   to compile later.
+*)
+val format_code : Format.formatter -> 'a closed_code -> unit
+
+(* print code as a parse tree. Useful for debugging *)
+val print_code_as_ast : 'a closed_code -> unit
diff --git a/ber-metaocaml-101/runcode.ml b/ber-metaocaml-101/runcode.ml
new file mode 100644
index 0000000..f5d6e90
--- /dev/null
+++ b/ber-metaocaml-101/runcode.ml
@@ -0,0 +1,126 @@
+(* Run the closed code: byte-code and native code *)
+
+open Format
+open Parsetree
+
+type 'a closed_code = Trx.closed_code_repr
+
+
+(* Check that the code is closed and return the closed code *)
+let close_code : 'a code -> 'a closed_code = fun cde ->
+  Trx.close_code_repr (Obj.magic cde)
+
+(* The same as close_code but return the closedness check as a thunk
+   rather than performing it.
+   This is useful for debugging and for showing the code.
+*)
+let close_code_delay_check : 'a code -> 'a closed_code * (unit -> unit) =
+  fun cde -> Trx.close_code_delay_check (Obj.magic cde)
+
+let open_code : 'a closed_code -> 'a code = fun ccde ->
+  Obj.magic (Trx.open_code ccde)
+
+
+(* Execute a thunk (which does compilation) while disabling certain
+   warnings.
+*)
+let warnings_descr =
+    [(Warnings.Partial_match "",("P","p"));
+     (Warnings.Unused_argument,("X","x"));
+     (Warnings.Unused_var "",("Y","y"));
+     (Warnings.Unused_var_strict "",("Z","z"))
+    ]
+
+let with_disabled_warnings warnings thunk =
+  let disable_str =
+    String.concat "" 
+      (List.map 
+	 (fun w -> snd (List.assoc w warnings_descr)) warnings) in
+  let curr_str = 
+    String.concat "" 
+      (List.map 
+	 (fun w -> 
+	   let state = Warnings.is_active w in
+	   (if state then fst else snd) (List.assoc w warnings_descr))
+	 warnings) in
+  let () = Warnings.parse_options false disable_str in
+  try
+    let r = thunk () in
+    Warnings.parse_options false curr_str; r
+  with e ->
+    Warnings.parse_options false curr_str;
+    raise e
+
+
+
+
+let initial_env = ref Env.empty
+
+(* Load and execute bytecode: copied from toploop/toploop.ml *)
+let load_lambda ppf lam =
+  if !Clflags.dump_rawlambda then fprintf ppf "%a@." Printlambda.lambda lam;
+  let slam = Simplif.simplify_lambda lam in
+  if !Clflags.dump_lambda then fprintf ppf "%a@." Printlambda.lambda slam;
+  let (init_code, fun_code) = Bytegen.compile_phrase slam in
+  if !Clflags.dump_instr then
+    fprintf ppf "%a%a@."
+    Printinstr.instrlist init_code
+    Printinstr.instrlist fun_code;
+  let (code, code_size, reloc) = Emitcode.to_memory init_code fun_code in
+  let can_free = (fun_code = []) in
+  let initial_symtable = Symtable.current_state() in
+  Symtable.patch_object code reloc;
+  Symtable.check_global_initialized reloc;
+  Symtable.update_global_table();
+  try
+    let retval = (Meta.reify_bytecode code code_size) () in
+    if can_free then begin
+      Meta.static_release_bytecode code code_size;
+      Meta.static_free code;
+    end;
+    retval
+  with x ->
+    if can_free then begin
+      Meta.static_release_bytecode code code_size;
+      Meta.static_free code;
+    end;
+    Symtable.restore_state initial_symtable;
+    raise x
+
+(* Patterned after toploop.ml:execute_phrase *)
+
+let run_bytecode' exp =
+  if !initial_env = Env.empty then initial_env := Compmisc.initial_env();
+  Ctype.init_def(Ident.current_time()); 
+  with_disabled_warnings [Warnings.Partial_match "";
+			  Warnings.Unused_argument;
+			  Warnings.Unused_var "";
+			  Warnings.Unused_var_strict ""]
+ (fun () ->
+   let sstr = [{pstr_desc = Pstr_eval exp; pstr_loc = Location.none}] in
+   let str = try
+    begin
+       Typecore.reset_delayed_checks ();
+       let (str, sg, newenv) = Typemod.type_toplevel_phrase !initial_env sstr in
+       let sg' = Typemod.simplify_signature sg in
+       ignore (Includemod.signatures !initial_env sg sg');
+       Typecore.force_delayed_checks (); str
+    end
+   with 
+    x -> (Errors.report_error Format.std_formatter x;
+	  Format.pp_print_newline Format.std_formatter ();
+	  failwith 
+            "Error type-checking generated code: scope extrusion?")
+  in
+  let lam = Translmod.transl_toplevel_definition str in
+  load_lambda Format.std_formatter lam
+ )
+
+let run_bytecode : 'a closed_code -> 'a = fun cde ->
+  Obj.obj (
+    run_bytecode' (cde : Trx.closed_code_repr :> Parsetree.expression))
+
+(* Abbreviations for backwards compatibility *)
+let run cde = run_bytecode (close_code cde)
+let (!.) cde = run cde
+
diff --git a/ber-metaocaml-101/runcode.mli b/ber-metaocaml-101/runcode.mli
new file mode 100644
index 0000000..6c88b39
--- /dev/null
+++ b/ber-metaocaml-101/runcode.mli
@@ -0,0 +1,32 @@
+(* Given a closed code expression, compile and run it, returning
+   its result or propagating raised exceptions.
+*)
+
+type 'a closed_code = Trx.closed_code_repr
+
+(* Check that the code is closed and return the closed code *)
+val close_code : 'a code -> 'a closed_code
+
+(* The same as close_code but return the closedness check as a thunk
+   rather than performing it.
+   This is useful for debugging and for showing the code:
+   If there is a scope extrusion error, it is still useful
+   to show the code with the extrusion before throwing the scope-extrusion
+   exception.
+*)
+val close_code_delay_check : 'a code -> 'a closed_code * (unit -> unit)
+
+(* Total: a closed code can always be used in slices, etc. *)
+val open_code : 'a closed_code -> 'a code
+
+(* Run closed code by bytecode compiling it and then executing *)
+val run_bytecode : 'a closed_code -> 'a
+
+(* Other ways of running are equally possible *)
+
+(* The following two synonyms are for backwards compatibility: 
+   They are both compositions of close_code and run_bytecode  *)
+val run  : 'a code -> 'a
+val (!.) : 'a code -> 'a
+
+
diff --git a/ber-metaocaml-101/simple.ref b/ber-metaocaml-101/simple.ref
new file mode 100644
index 0000000..7f35704
--- /dev/null
+++ b/ber-metaocaml-101/simple.ref
@@ -0,0 +1,41 @@
+BER MetaOCaml toplevel, version N 101
+        OCaml version 4.01.1+dev0-2013-09-11
+
+#   #       val tr1 : ('a -> int) code = .<fun x_1  -> 1>. 
+# * *   val tr1' : ('a -> 'b -> 'b) code = .<fun x_2  x_3_4  -> x_3_4>. 
+# * *   val tr2 : ('a -> int) code = .<fun x_5  -> 1>. 
+# * *     Exception:
+Failure
+ "The code built at Characters 72-73:\n  let tr3 = .<fun x -> .~(let x = !. .<x>. in .<x>.)>.;;\n                  ^\n is not closed: identifier x_6 bound at Characters 72-73:\n  let tr3 = .<fun x -> .~(let x = !. .<x>. in .<x>.)>.;;\n                  ^\n is free".
+#   * * * * * * * * *   Error was expected
+- : unit = ()
+#   Exception:
+Failure
+ "The code built at Characters 8-9:\n  .< fun x -> .~ (!. .< x >.) >.;;\n         ^\n is not closed: identifier x_7 bound at Characters 8-9:\n  .< fun x -> .~ (!. .< x >.) >.;;\n         ^\n is free".
+# * * * * * * * * * *   Error was expected
+- : unit = ()
+#   Characters 36-37:
+  let tr4 = .<fun x -> .~(let x = !. x in .<x>.)>.;;
+                                     ^
+Error: Wrong level: variable bound at level 1 and used at level 0
+# * * * * *   Error was expected
+- : unit = ()
+#   val tr5 : ('a -> int) code = .<fun x_8  -> Runcode.( !. )  (.< 1  >.)>. 
+# * *   #   val tr6 : ('a -> 'a) code = .<fun x_9  -> Runcode.( !. )  (.< x_9  >.)>. 
+# * *   #   val tr7 : ('a code -> 'a) code = .<fun x_10  -> Runcode.( !. )  x_10>. 
+# * * * * * * * * *   #     val tr8 : ('a -> 'a code) code = .<
+  fun x_11  -> (* cross-stage persistent value (id: y) *)>. 
+# * * *     val tr8r : '_a -> '_a code = <fun>
+# * * * * * * * * *     - : int code = .<x_11>.
+
+Failure("The code built at Characters 36-37:\n  val tr8r : '_a -> '_a code = <fun>\n                                   ^\n is not closed: identifier x_11 bound at Characters 36-37:\n  val tr8r : '_a -> '_a code = <fun>\n                                   ^\n is free")
+# * * * *   Error was expected
+- : unit = ()
+#   val tm1 : ('a -> 'a code) code = .<fun x_12  -> .< x_12  >.>. 
+# * *   - : int code = .<(* cross-stage persistent value (id: x_12) *)>. 
+# * *   #       val tg1 : '_a list ref = {contents = []}
+# * * *   val tg2 : '_a list ref = {contents = []}
+# * * *     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *     
+All Done
+- : unit = ()
+# 
diff --git a/ber-metaocaml-101/test/bool2.ml b/ber-metaocaml-101/test/bool2.ml
new file mode 100755
index 0000000..04bf32e
--- /dev/null
+++ b/ber-metaocaml-101/test/bool2.ml
@@ -0,0 +1,8 @@
+type ('a,'b) staged = Now of 'b | Later of ('a, 'b) code
+
+(* It is the *presence* of this module with a nested module which 
+ * causes the failure, even though it is empty and not used! *)
+module XXX = struct
+  module TT = struct
+  end
+end
diff --git a/ber-metaocaml-101/test/pythagorian_triples.ml b/ber-metaocaml-101/test/pythagorian_triples.ml
new file mode 100644
index 0000000..0d1ddc9
--- /dev/null
+++ b/ber-metaocaml-101/test/pythagorian_triples.ml
@@ -0,0 +1,87 @@
+(* Test of the let! notation: Fair monad for non-determinism *)
+
+module NonDet : sig
+  type 'a stream_v
+  type 'a stream = unit -> 'a stream_v
+
+  val ret  : 'a -> 'a stream
+  val fail : 'a stream
+
+      (* a.k.a bind or disjunction *)
+  val (let!) : 'a stream -> ('a -> 'b stream) -> 'b stream
+      (* a.k.a. fair disjunction *)
+  val mplus  : 'a stream -> 'a stream -> 'a stream
+
+  val guard  : bool -> unit stream
+  val yield  : 'a stream -> 'a stream
+
+  val run : int ->             (* upper bound on the number of solutions *)
+            'a stream ->
+	    'a list
+end = struct
+  type 'a stream_v = 
+    Nil | Cons of 'a * 'a stream | InC of 'a stream
+  and 'a stream = unit -> 'a stream_v
+
+  let fail  = fun () -> Nil
+  let ret a = fun () -> Cons (a,fail)
+
+  (* actually, interleave: a fair disjunction with breadth-first search*)
+  let rec mplus a b = fun () -> 
+    match a () with
+    | Nil          -> InC b
+    | Cons (a1,a2) -> Cons (a1,(mplus b a2))
+    | InC a -> 
+	begin match b () with
+	| Nil   -> InC a
+        | InC b -> InC (mplus a b)
+        | Cons (b1,b2) -> Cons (b1, (mplus a b2))
+	end
+
+  (* a fair conjunction *)
+  let rec (let!) m f = fun () -> 
+    match m () with
+    | Nil        -> fail ()
+    | InC a      -> InC ((let!) a f)
+    | Cons (a,b) -> mplus (f a) ((let!) b f) ()
+
+  let guard be = if be then ret () else fail
+  let yield m  () = InC m
+
+  let rec run n m = 
+    if n = 0 then [] else
+    match m () with
+    | Nil -> []
+    | InC a -> run n a
+    | Cons (a,b) -> (a::run (n-1) b)
+end;;
+
+open NonDet;;
+
+(* The example uses left recursion and truly infinite streams! *)
+(* Don't try this in Prolog or in Haskell's MonadPlus. *)
+
+let rec numb () = 			(* infinite stream of integers *)
+    yield (mplus (let! n = numb in ret (n+1))         (* left recursion! *)
+	       (ret 0)) ()
+;;
+
+let pyth : (int * int * int) NonDet.stream =
+  let! i  = numb in
+  let! () = guard (i>0) in
+  let! j  = numb in
+  let! () = guard (j>0) in
+  let! k  = numb in
+  let! () = guard (k>0) in
+  (* Just to illustrate the `let' form within let! *)
+  let test x = x*x = j*j + k*k in
+  let! () = guard (test i) in
+  ret (i,j,k)
+;;
+
+let [(5, 4, 3); (5, 3, 4); (10, 8, 6); (10, 6, 8); (13, 12, 5); (13, 5, 12);
+     (15, 12, 9); (15, 9, 12); (17, 15, 8); (17, 8, 15)]
+ =
+run 10 pyth;;
+
+print_endline "\nAll done";;
diff --git a/ber-metaocaml-101/test/quick_test.ml b/ber-metaocaml-101/test/quick_test.ml
new file mode 100644
index 0000000..a920f84
--- /dev/null
+++ b/ber-metaocaml-101/test/quick_test.ml
@@ -0,0 +1,615 @@
+(* Quick test of BER MetaOCaml. From PEPM09 and PEPM08 papers:
+
+     Closing the Stage: From staged code to typed closures.
+     Yukiyoshi Kameyama, Oleg Kiselyov, and Chung-chieh Shan
+
+*)
+open Runcode;;
+
+(* ---------------------------------------------------------------------- *)
+(* The power example, Sec 2 *)
+
+let square x = x * x
+let rec power : int -> int code -> int code = 
+   fun n -> fun x ->
+    if n = 0 then .<1>.
+       else if n mod 2 = 0 
+           then .< (*csp*)square .~(power (n/2) x)>.
+           else .<.~x * .~(power (n-1) x)>.
+;;
+let power7_cde = .<fun x -> .~(Printf.printf "power\n"; power 7 .<x>.)>.;;
+(* "power" printed once *)
+(*
+val power7_cde : (int -> int) code = .<
+  fun x_22  ->
+    x_22 *
+      (((* cross-stage persistent value (id: square) *))
+         (x_22 *
+            (((* cross-stage persistent value (id: square) *)) (x_22 * 1))))>.
+*)
+let power7 : int -> int = !. power7_cde;;
+let (128, 2187) = (power7 2, power7 3);;
+(* nothing is printed...
+  val res : int * int = (128, 2187)
+*)
+
+(* Before N101, the following didn't work *)
+let power7 : int -> int = 
+  !. .<fun x -> .~(Printf.printf "power\n"; power 7 .<x>.)>.;;
+
+(* But the following does. It is the explicit version of the above *)
+let power7 : int -> int = 
+  Runcode.run_bytecode (Runcode.close_code 
+               .<fun x -> .~(Printf.printf "power\n"; power 7 .<x>.)>.);;
+(* "power" printed once *)
+let (128, 2187) = (power7 2, power7 3);;
+(* nothing is printed...
+  val res : int * int = (128, 2187)
+*)
+
+
+(* ---------------------------------------------------------------------- *)
+(* The ef example. *)
+
+(* The source code *)
+let ef = fun z -> .<fun x -> .~z + x>.;;
+let ef1 = .<fun y -> .~(ef .<y>.)>.;;
+(*
+val ef1 : (int -> int -> int) code = .<fun y_27  x_28  -> y_27 + x_28>. 
+*)
+let 5 = (!. ef1) 2 3;; (* 5 *)
+
+let ef2 = .<fun x -> fun y -> .~(ef .<x*y>.)>.;;
+(*
+val ef2 : (int -> int -> int -> int) code = .<
+  fun x_29  y_30  x_31  -> (x_29 * y_30) + x_31>. 
+*)
+let 10 = (!. ef2) 2 3 4;; (* 10 *)
+
+(* ---------------------------------------------------------------------- *)
+(* The eta example. *)
+
+let (5,10,34) = 
+  let eta f = .<fun x -> .~(f .<x>.)>. in
+    (!.
+       .< fun y ->         
+             .~(eta (fun z -> .< .~z + y   >.)) >.)
+    2 3,
+    (!.
+       .< fun y -> fun w -> 
+             .~(eta (fun z -> .< .~z + y*w >.)) >.)
+    2 3 4,
+    (!.
+       .< fun x u -> 
+             .~(eta (fun z -> .<fun y -> .~z + u*x*y >.)) >.)
+    2 3 4 5
+ ;;
+
+
+(* ---------------------------------------------------------------------- *)
+(* Cross-stage presistence *)
+
+(* This example includes persistence of a code value, which we
+ specifically exclude in the paper. *)
+
+let cspe =
+ .<fun x -> .~(let u = .<x>. in 
+     (!. .<fun y -> .<.~u>.>.) ()) >.;;
+
+(*
+    val cspe : ('a -> 'a) code = .<fun x_41  -> x_41>. 
+*)
+
+let 42 = (!. cspe) 42;;
+
+(* This CSP example does fit our restriction *)
+
+let rec scspe x = .<(fun y -> x) (scspe 1)>.;;
+(*
+val scspe : int -> int code = <fun>
+# scspe 10;;
+- : ('a, int) code =
+.<((fun y_1 -> 10) (((* cross-stage persistent value (as id: scspe) *)) 1))>.
+# !. (scspe 10);;
+- : int = 10
+*)
+
+let 10 = !. (scspe 10);;
+
+(* ---------------------------------------------------------------------- *)
+(* Scope extrusion via mutable state *)
+
+(*
+let extr = let x = ref .<1>. in
+    let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+    !x;;
+
+(* It does type-check ... but printing it produces an error *)
+
+    val extr : int code = .<v_45>.
+  
+Failure("The code built at Characters 50-51:\n      let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in\n                    ^\n is not closed: identifier v_45 bound at Characters 50-51:\n      let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in\n                    ^\n is free")
+*)
+
+(* Previously:
+    val extr : ('a, int) code = .<v_1>.
+
+    # !. extr ;;
+    Unbound value v_1
+    Exception: Trx.TypeCheckingError.
+*)
+
+(* The run-time error is reported on an attempt to run the code *)
+let true = 
+ try !. (let x = ref .<1>. in
+    let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+    !x); false
+ with Failure e -> print_string e; true
+;;
+(*
+Scope extrusion at Characters 75-76:
+      let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+                                   ^
+ for the identifier v_66 bound at Characters 60-61:
+      let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+                    ^
+*)
+
+(* The run-time error is reported on an attempt to splice the code *)
+let true = 
+ try let x = ref .<1>. in
+     let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+     .<1 + .~(!x)>.; false     (* triggers an error with the message below *)
+ with Failure e -> print_string e; true
+;;
+(*
+Scope extrusion detected at Characters 97-107:
+       .<1 + .~(!x)>.; false     (* triggers an error with the message below *)
+         ^^^^^^^^^^
+ for code built at Characters 57-58:
+       let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+                     ^
+ for the identifier v_47 bound at Characters 57-58:
+       let _ = .<fun v -> .~(x := .<v>.; .<()>.)>. in
+                     ^
+*)
+
+
+(*
+ *  In this example, we compute a staged power function while tracking how many
+ *  multiplications the generated code performs.  This example demonstrates the
+ *  utility of our environment-passing translation, in two ways.  First, it is
+ *  easiest to write this example if we use a side effect such as mutable state
+ *  in MetaOCaml, but such an extension (a piece of state of type int) has not
+ *  been shown sound except through our translation.  Second, we can write this
+ *  example in pure MetaOCaml (more awkwardly) using our translation.
+ *
+ *  Thanks to Olivier Danvy for suggesting this example.
+ *)
+
+let rec powerc = function
+    | 0 -> (.<fun x -> 1>.,0)
+    | 1 -> (.<fun x -> x>.,1)
+    | n -> let (c,n1) = powerc (pred n) in
+           (.<fun x -> (.~c x) * x>.,succ n1)
+;;
+(*
+  val powerc : int -> (int -> int) code * int = <fun>
+*)
+
+let test = powerc 5;;
+(*
+val test : (int -> int) code * int =
+  (.<
+   fun x_52  ->
+     ((fun x_51  ->
+         ((fun x_50  ->
+             ((fun x_49  -> ((fun x_48  -> x_48) x_49) * x_49) x_50) * x_50)
+            x_51)
+           * x_51) x_52)
+       * x_52>.
+   , 5)
+*)
+
+let 32 = (!. (fst test)) 2;;
+(*
+val testc : int = 32
+*)
+
+let mul x y = .<.<.~.~x * .~.~y>.>.;;
+(*
+val mul : int code code -> int code code -> int code code = <fun>
+*)
+
+let rec powerd = function
+    | 0 -> (.<fun x -> .<1>.>.,0)
+    | 1 -> (.<fun x -> x>.,1)
+    | n -> let (c,n1) = powerd (pred n) in
+           (.<fun x -> .~(mul .<.~c x>. .<x>.)>.,succ n1)
+;;
+(*
+val powerd : int -> (int code -> int code) code * int = <fun>
+*)
+
+let test1 = powerd 5;;
+(*
+val test1 : (int code -> int code) code * int =
+  (.<
+   fun x_57  ->
+     .<
+       (.~(fun x_56  ->
+             .<
+               (.~(fun x_55  ->
+                     .<
+                       (.~(fun x_54  ->
+                             .< (.~(fun x_53  -> x_53) x_54) * (.~(x_54))  >.)
+                            x_55)
+                         * (.~(x_55))  >.) x_56)
+                 * (.~(x_56))  >.) x_57)
+         * (.~(x_57))  >.>.
+   , 5)
+*)
+
+let testd = !. (fst (powerd 5));;
+let testdd = .<fun x -> .~(testd .<x>.)>.;;
+(*
+val testdd : (int -> int) code = .<
+  fun x_63  -> (((x_63 * x_63) * x_63) * x_63) * x_63>. 
+*)
+
+(* An attempt to write testd without overt use of multiple levels:
+   no nested brackets.
+*)
+let one = .<1>.;;
+let mul1 x y = .<.~x * .~y>.;;
+let mull x y = .<mul1 .~x  .~y>.;;
+
+let rec powerd1 = function
+    | 0 -> (.<fun x -> one>.,0)
+    | 1 -> (.<fun x -> x>.,1)
+    | n -> let (c,n1) = powerd1 (pred n) in
+           (.<fun x -> .~(mull .<.~c x>. .<x>.)>.,succ n1)
+;;
+(*
+val powerd1 : int -> (int code -> int code) code * int = <fun>
+*)
+
+let test11 = powerd1 5;;
+(*
+val test11 : (int code -> int code) code * int =
+  (.<
+   fun x_68  ->
+     ((* cross-stage persistent value (id: mul1) *))
+       ((fun x_67  ->
+           ((* cross-stage persistent value (id: mul1) *))
+             ((fun x_66  ->
+                 ((* cross-stage persistent value (id: mul1) *))
+                   ((fun x_65  ->
+                       ((* cross-stage persistent value (id: mul1) *))
+                         ((fun x_64  -> x_64) x_65) x_65) x_66) x_66) x_67)
+             x_67) x_68) x_68>.
+   , 5)
+*)
+
+let testd1 () = !. (fst (powerd1 5));;
+let testdd1 = .<fun x -> .~(testd1 () .<x>.)>.;;
+(*
+val testdd1 : (int -> int) code = .<
+  fun x_69  -> (((x_69 * x_69) * x_69) * x_69) * x_69>. 
+*)
+let 32 = (Runcode.run .<fun x -> .~(testd1 () .<x>.)>.) 2;;
+
+
+(* Meta-programming with delimited continuations *)
+(* Writing an efficient specialized version of Gibonacci,
+   without using any fix-point combinators, etc.
+*)
+
+open Printf;;
+
+(* The original Gibonacci *)
+
+let rec gib x y n =
+  if n = 0 then x else 
+  if n = 1 then y else
+  gib x y (n-1) + gib x y (n-2) 
+;;
+let 8 = gib 1 1 5;;
+
+(* Naively staged Gibonacci, to the statically known value of n *)
+
+let rec gibgen x y n =
+  if n = 0 then x else 
+  if n = 1 then y else
+  .<.~(gibgen x y (n-1)) + .~(gibgen x y (n-2))>.
+;;
+(* 
+  val gibgen : ('cl, int) code -> ('cl, int) code -> int -> ('cl, int) code 
+*)
+let test_gibgen n = .<fun x y -> .~(gibgen .<x>. .<y>. n)>.;;
+(* val test_gibgen : int -> ('a, int -> int -> int) code = <fun> *)
+let test_gibgen5 = test_gibgen 5;;
+(*
+val test_gibgen5 : (int -> int -> int) code = .<
+  fun x_1  y_2  ->
+    (((y_2 + x_1) + y_2) + (y_2 + x_1)) + ((y_2 + x_1) + y_2)>.
+*)
+let 8 = (!. test_gibgen5) 1 1;;
+
+(* Clearly, the naive Gibonacci is inefficient. 
+   The specialized code test_gibgen5 shows why:
+   the computation (y_2 + x_1) is repeated thrice within such a short fragment
+*)
+
+(* To improve Gibonacci, we have to add memoization *)
+
+(* First we define the abstract data types of memoization table 
+   with integer keys *)
+
+(* For the sake of the closest correspondence with circle-shift.elf,
+   we use pairs to emulate 'a option data type. In the rest of the
+   code, 'a maybe is an abstract data type.
+*)
+module Maybe :
+ sig
+   type 'a maybe
+   val nothing   : 'a maybe
+   val just      : 'a -> 'a maybe
+   val ifnothing : 'a maybe -> bool
+   val fromjust  : 'a maybe -> 'a
+ end = struct
+   type 'a maybe  = bool * (unit -> 'a)
+   let nothing    = (true,  fun () -> failwith "nothing")
+   let just x     = (false, fun () -> x)
+   let ifnothing  = fst
+   let fromjust x = snd x ()
+end;;
+open Maybe;;
+
+module Memo :
+ sig
+   type 'a memo
+   val empty  : 'a memo
+   val lookup : int -> 'a memo -> 'a maybe
+   val ext    : 'a memo -> int -> 'a -> 'a memo
+ end = struct
+   (* The following implementation uses functions, for compatibility
+      with circle-shift.elf. The rest of the code does not depend
+      on the implementation and can't even know it.
+    *)
+   type 'a memo = int -> 'a maybe
+   let empty    = fun key -> nothing
+   let lookup   = fun n table -> table n
+   let ext      = fun table n v -> 
+                     fun key -> if key = n then just v else table key
+end;;
+open Memo;;
+
+(* we can write the standard, textbook memoizer *)
+(* It memoizes the result of the application of function f to the integer n.
+ *)
+
+let new_memo () =
+  let table = ref empty in
+  fun f n ->
+    let r = lookup n !table in
+    if ifnothing r 
+    then                                (* memo table miss *)
+      let v = f n in			(* compute the value *)
+      table := ext !table n v; v
+    else fromjust r			(* else return the memoized value *)
+;;
+
+
+(* Now we can memoize Gibonacci and obtain an improved version *)
+let gibo x y =
+  let memo = new_memo () in
+  let rec loop n =
+    if n = 0 then x else 
+    if n = 1 then y else
+    memo loop (n-1) + memo loop (n-2)
+ in loop
+;;
+
+let 8  = gibo 1 1 5;;  (* 8 *)
+let 1346269 = gibo 1 1 30;;
+(* 1346269, without memoization it would've taken a while...*)
+
+(* We may try to stage it, naively *)
+
+let sgibo_naive x y =
+  let memo = new_memo () in
+  let rec loop n =
+    if n = 0 then x else 
+    if n = 1 then y else
+    .<.~(memo loop (n-1)) + .~(memo loop (n-2))>.
+ in loop
+;;
+
+let test_sgibo_naive5  = 
+  .<fun x y -> .~(sgibo_naive .<x>. .<y>. 5)>.;;
+(*
+val test_sgibo_naive5 : (int -> int -> int) code = .<
+  fun x_3  y_4  ->
+    (((y_4 + x_3) + y_4) + (y_4 + x_3)) + ((y_4 + x_3) + y_4)>.
+*)
+
+(* Alas, the result shows the duplication of computations. The result of
+  loop, in sgibo_naive, is a present-stage value but future-stage
+  computation. We saved effort at the present stage but we saved no
+  computation at the future stage. We need let insertion to save 
+  future-stage computations.
+*)
+
+(* But the let-insertion isn't that easy! The naive version *)
+
+let sgibo1_naive x y =
+  let memo = new_memo () in
+  let rec loop n =
+    if n = 0 then x else 
+    if n = 1 then y else
+    .<let t1 = .~(memo loop (n-1)) and t2 = .~(memo loop (n-2))
+      in t1 + t2>.
+ in loop
+;;
+
+let test_sgibo1_naive5  = 
+  .<fun x y -> .~(sgibo1_naive .<x>. .<y>. 5)>.
+(*
+val test_sgibo1_naive5 : (int -> int -> int) code = .<
+  fun x_105  y_106  ->
+    let t1_113 =
+      let t1_111 =
+        let t1_109 = let t1_107 = y_106 and t2_108 = x_105 in t1_107 + t2_108
+        and t2_110 = y_106 in t1_109 + t2_110
+      and t2_112 = let t1_107 = y_106 and t2_108 = x_105 in t1_107 + t2_108 in
+      t1_111 + t2_112
+    and t2_114 =
+      let t1_109 = let t1_107 = y_106 and t2_108 = x_105 in t1_107 + t2_108
+      and t2_110 = y_106 in t1_109 + t2_110 in
+    t1_113 + t2_114>.
+*)
+
+(* the naive version obviously doesn't do any good: It creates even bigger
+   duplicated computations *)
+  
+(* We have to change the memo table implementation. Our memo table should
+   contain only those future-stage computations that are future-stage
+   values. So, we need to do let-insertion after we detected a miss.
+   But for that, we have to re-write everything in CPS. We have to write
+   the memo-table implementation in CPS:
+*)
+   
+let new_memo_let_CPS () =
+  let table = ref empty in
+  fun f n k ->
+    let r = lookup n !table in
+    if ifnothing r 
+    then                                (* memo table miss *)
+      f n 				(* compute the value *)
+       (fun v -> .<let t = .~v in 
+                     .~(table := ext !table n .<t>.; k .<t>.)>.)
+    else k (fromjust r)			(* else return the memoized value *)
+;;
+
+(* but we also must re-write sgibo in CPS! *)
+
+let sgibo_CPS x y =
+  let memo = new_memo_let_CPS () in
+  let rec loop n k =
+    if n = 0 then k x else 
+    if n = 1 then k y else
+    memo loop (n-1) (fun r1 ->
+    memo loop (n-2) (fun r2 ->
+    k .<.~r1 + .~r2>.))
+  in loop
+;;
+
+let test_sgibo_CPS5  = 
+  .<fun x y -> .~(sgibo_CPS .<x>. .<y>. 5 (fun x ->x))>.;;
+
+(*
+val test_sgibo_CPS5 : (int -> int -> int) code = .<
+  fun x_2  y_3  ->
+    let t_4 = y_3 in
+    let t_5 = x_2 in
+    let t_6 = t_4 + t_5 in
+    let t_7 = t_6 + t_4 in let t_8 = t_7 + t_6 in t_8 + t_7>.
+*)
+let 8 = (!. test_sgibo_CPS5) 1 1;;
+
+(* Now we get the desired result: no duplicate computations.
+   At the cost of changing all of our code, even sgibo, in CPS.
+   Memoization is no longer easy -- it becomes very intrusive.
+*)
+
+(* Not only this approach inconvenient, it is also unsafe.
+   The mutation in maintaining the table in new_memo_let_CPS
+   results in unsafety. We store in the `global' memo table code
+   values like .<t>. -- with variables bound in the scope 
+   that is more narrow than the dynamic scope of the table.
+ *)
+
+(* Let's make a simple `pessimization' of sgibo1_CPS. Let's suppose the
+   programmer didn't want to rewrite gib in CPS, and continued to use
+   memoization in `direct style'.
+*)
+
+let sgibo1_bad x y =
+  let memo = new_memo_let_CPS () in
+  let rec loop n =
+    if n = 0 then x else 
+    if n = 1 then y else
+    .<.~(memo (fun n k -> k (loop n)) (n-1) (fun x ->x)) + 
+      .~(memo (fun n k -> k (loop n)) (n-2) (fun x ->x))>.
+ in loop
+;;
+
+let true =
+ try
+   let test_sgibo1_bad  = 
+     .<fun x y -> .~(sgibo1_bad .<x>. .<y>. 5)>. in
+   false
+ with Failure e -> print_string e; true
+;;
+
+(* Previously (before version N100) it worked:
+  val test_sgibo1_bad : ('a, int -> int -> int) code =
+  .<fun x_1 ->
+   fun y_2 ->
+    (let t_7 = (t_6 + t_5) in t_7 +
+      let t_6 =
+       (let t_5 = (t_3 + let t_4 = x_1 in t_4) in t_5 + let t_3 = y_2 in t_3) in
+      t_6)>.
+*)
+
+(* Although the result appears efficient -- only four additions --
+   it is incorrect! Please notice how variable t_6 is referenced before
+   it is bound. Attempting to run this code gives
+
+!. test_sgibo1_bad;;
+  Unbound value t_6
+  Exception: Trx.TypeCheckingError.
+*)
+
+(* But now we get a scope extrusion error
+Scope extrusion detected at Characters 133-243:
+  .............................ng e; true;;
+   for code built at Characters 242-243:
+   for the identifier t_131 bound at Characters 242-243:
+*)
+
+(* To rely on MetaOCaml's type soundness, we must not use any side effects
+   in our code generator.  We could write our memoizing gib without state,
+   by including state-passing in our continuation-passing, as follows.
+*)
+
+let new_memo_let_CPS_only f n k table =
+   let r = lookup n table in
+   if ifnothing r
+   then
+     f n
+      (fun v table -> .<let t = .~v in
+                    .~(k .<t>. (ext table n .<t>.))>.)
+      table
+   else
+     k (fromjust r) table
+;;
+
+let sgibo_CPS_only x y =
+  let memo = new_memo_let_CPS_only in
+  let rec loop n k =
+    if n = 0 then k x else 
+    if n = 1 then k y else
+    memo loop (n-1) (fun r1 ->
+    memo loop (n-2) (fun r2 ->
+    k .<.~r1 + .~r2>.))
+  in loop
+;;
+
+let test_sgibo_CPS_only5  = 
+  .<fun x y -> .~(sgibo_CPS_only .<x>. .<y>. 5 (fun r table -> r) empty)>.;;
+
+let 8 = (!. test_sgibo_CPS_only5) 1 1;;
+
+Printf.printf "\nAll Done\n";;
diff --git a/ber-metaocaml-101/test/simple.ml b/ber-metaocaml-101/test/simple.ml
new file mode 100644
index 0000000..2624d81
--- /dev/null
+++ b/ber-metaocaml-101/test/simple.ml
@@ -0,0 +1,179 @@
+(* Various simple (one-liner) examples and NON-examples  *)
+open Runcode;;
+
+(* Safety of run *)
+
+let tr1 = .<fun x -> .~(!. .<.<1>.>.)>.;;
+(*
+val tr1 : ('a -> int) code = .<fun x_54  -> 1>. 
+*)
+let tr1' = .<fun x -> .~(!. .<.<fun x -> x>.>.)>.;;
+(*
+val tr1' : ('a -> 'b -> 'b) code = .<fun x_55  x_56_57  -> x_56_57>. 
+*)
+let tr2 = .<fun x -> .~(let x = !. .<1>. in .<x>.)>.;;
+(*
+val tr2 : ('a -> int) code = .<fun x_58  -> 1>. 
+*)
+
+let tr3 = .<fun x -> .~(let x = !. .<x>. in .<x>.)>.;;
+
+(*
+Exception:
+Failure
+ "The code built at Characters 16-17:\n  let tr3 = .<fun x -> .~(let x = !. .<x>. in .<x>.)>.;;\n                  ^\n is not closed: identifier x_59 bound at Characters 16-17:\n  let tr3 = .<fun x -> .~(let x = !. .<x>. in .<x>.)>.;;\n                  ^\n is free".
+
+Was:
+  let tr3 = .<fun x -> .~(let x = !. .<x>. in .<x>.)>.;;
+                                     ^^^^^
+Error: !. error: 'a not generalizable in ('a, 'b) code
+*)
+print_endline "Error was expected";;
+
+.< fun x -> .~ (!. .< x >.) >.;;
+(*
+Exception:
+Failure
+ "The code built at Characters 7-8:\n  .< fun x -> .~ (!. .< x >.) >.;;\n         ^\n is not closed: identifier x_60 bound at Characters 7-8:\n  .< fun x -> .~ (!. .< x >.) >.;;\n         ^\n is free".
+
+Was:
+Characters 15-26:
+  .< fun x -> .~ (!..< x >.) >.;;
+                 ^^^^^^^^^^^
+Error: !. occurs check error: 'cl occurs in ('cl, ('cl, 'a) code) code
+*)
+print_endline "Error was expected";;
+
+let tr4 = .<fun x -> .~(let x = !. x in .<x>.)>.;;
+(*
+Characters 35-36:
+  let tr4 = .<fun x -> .~(let x = !. x in .<x>.)>.;;
+                                     ^
+Error: Wrong level: variable bound at level 1 and used at level 0
+*)
+print_endline "Error was expected";;
+
+let tr5 = .<fun x -> !. .<1>.>.;;
+(*
+val tr5 : ('a -> int) code = .<fun x_61  -> Runcode.( !. )  (.< 1  >.)>. 
+*)
+let 1 = (!. tr5) true;;
+
+let tr6 = .<fun x -> !. .<x>.>.;;
+(*
+val tr6 : ('a -> 'a) code = .<fun x_62  -> Runcode.( !. )  (.< x_62  >.)>. 
+*)
+let 1 = (!. tr6) 1;;
+
+let tr7 = .<fun x -> !. x>.;;
+(*
+val tr7 : ('a code -> 'a) code = .<fun x_63  -> Runcode.( !. )  x_63>. 
+
+Was:
+Characters 24-25:
+  let tr7 = .<fun x -> !. x>.;;
+                          ^
+Error: !. error: 'a not generalizable in ('a, 'b) code
+print_endline "Error was expected";;
+*)
+let 10 = !. tr7 .<10>.;;
+
+ (* Bizzare CSP *)
+let tr8 = .<fun x -> .~(let y = .<x>. in .<y>.)>.;;
+(*
+val tr8 : ('a -> 'a code) code = .<
+  fun x_65  -> (* cross-stage persistent value (id: y) *)>. 
+*)
+(* But it cannot be run! *)
+let tr8r = !. tr8;;
+(*
+val tr8r : '_a -> '_a code = <fun>
+
+Was
+Characters 14-17:
+  let tr8r = !. tr8;;
+                ^^^
+Error: !. occurs check error: 'a occurs in ('a, 'b -> ('a, 'b) code) code
+print_endline "Error was expected";;
+*)
+(* And it cannot be run indeed *)
+!. tr8 10;;
+(*
+- : int code = .<x_65>.
+
+Failure("The code built at Characters 16-17:\n   is not closed: identifier x_65 bound at Characters 16-17:\n   is free")
+*)
+print_endline "Error was expected";;
+
+let tm1 = .<fun x -> .< x >. >.;;
+(*
+val tm1 : ('a -> 'a code) code = .<fun x_66  -> .< x_66  >.>. 
+*)
+!. tm1 10;;
+(*
+- : int code = .<(* cross-stage persistent value (id: x_66) *)>. 
+*)
+let 10 = !. (!. tm1 10);;
+
+(* Generalization *)
+
+let tg1 = !. ((fun x -> .<x>.) (ref []));;
+(*
+val tg1 : '_a list ref = {contents = []}
+   should not be polymorphic!
+*)
+let tg2 = !. .<ref []>.;;
+(*
+val tg2 : '_a list ref = {contents = []}
+   should not be polymorphic!
+*)
+
+(*
+(* First-class polymorphism *)
+
+(* Recall, in runcode.mli:
+
+type 'a cde = {cde : 'c. ('c,'a) code}  (* Type of the closed code *)
+
+*)
+
+(* In all previous versions of MetaOCaml, up to BER N004:
+
+# Runcode.run;;
+- : 'a Runcode.cde -> 'a = <fun>
+# {Runcode.cde = .<1>.};;
+- : int Runcode.cde = .<1>.
+# Runcode.run {Runcode.cde = .<1>.};;
+- : int = 1
+# .<{Runcode.cde = .<1>.}>.;;
+- : ('a, int Runcode.cde) code = .<{Runcode.cde = .<1>.}>.
+# !. .<{Runcode.cde = .<1>.}>.;;
+Characters 22-23:
+  !. .<{Runcode.cde = .<1>.}>.;;
+                        ^
+Error: This expression has type ('a, int) code
+       but an expression was expected of type ('b, int) code
+
+Exception: Trx.TypeCheckingError.
+*)
+
+(* Now *)
+let tfc1 = {Runcode.cde = .<1>.};;
+(* - : int Runcode.cde = .<1>. *)
+let 1 = Runcode.run {Runcode.cde = .<1>.};;
+
+let tfc2 = .<{Runcode.cde = .<1>.}>.;;
+(*
+- : ('cl, int Runcode.cde) code = .<{Runcode.cde = .<1>.}>. 
+*)
+let tfc3 = !. .<{Runcode.cde = .<1>.}>.;;
+(* - : int Runcode.cde = .<1>.  *)
+let tfc4 = {Runcode.cde= .<{Runcode.cde = .<1>.}>.};;
+(* - : int Runcode.cde Runcode.cde = .<{Runcode.cde = .<1>.}>.  *)
+let tfc5 = Runcode.run {Runcode.cde= .<{Runcode.cde = .<1>.}>.};;
+(* - : int Runcode.cde = .<1>.  *)
+let 1 = Runcode.run (Runcode.run {Runcode.cde= .<{Runcode.cde = .<1>.}>.});;
+(* - : int = 1 *)
+*)
+
+Printf.printf "\nAll Done\n";;
diff --git a/ber-metaocaml-101/test/simple_true.ml b/ber-metaocaml-101/test/simple_true.ml
new file mode 100644
index 0000000..a620212
--- /dev/null
+++ b/ber-metaocaml-101/test/simple_true.ml
@@ -0,0 +1,137 @@
+(* Various simple tests, all should pass. Whenever an error is discovered,
+   please add here.
+*)
+open Runcode;;
+
+(* From Problems.txt  Wed Oct  2 08:39:04 BST 2002
+  Occurrences of a csp value share the same instantiated type
+*)
+
+let f1 x = x;;                             (* polymophic *)
+let t1 = .<(f1 1, f1 true)>.;;
+(*
+val t1 : (int * bool) code = .<
+  ((((* cross-stage persistent value (id: f1) *)) 1),
+    (((* cross-stage persistent value (id: f1) *)) true))>.
+*)
+let (1,true) = !. t1;;
+
+(* From Problems.txt Thu Oct 24 09:55:36 BST 2002
+  CSP at level n+2 gives Segmentation fault
+*)
+(* use f1 above *)
+let t2 = .<(.<f1 1>., .<f1 true>.)>.;;
+(*
+val t2 : (int code * bool code) code = .<
+  ((.< ((* cross-stage persistent value (id: f1) *)) 1  >.),
+    (.< ((* cross-stage persistent value (id: f1) *)) true  >.))>.
+*)
+let 1 = !. (fst (!. t2));;
+let true = !. (snd (!. t2));;
+
+(* From Problems.txt Mon Nov 25 10:10:32 GMT 2002
+  CSP of array ops gives internal errors
+*)
+
+let t3 = .<Array.get [|1|] 0>.;;
+(*
+val t3 : int code = .<[|1|].(0)>. 
+*)
+let 1 = !. t3;;
+
+(* From Problems.txt Tue Jan 20 12:18:00 GMTST 2004
+  typechecker broken for csp ids, e.g. we get the wrong type
+  We get the incorrect typing (inner and outer code forced to be both 'a)
+   # .<fun x -> .<x>.>.;;
+*)
+
+let t4 = .<fun x -> .<x>.>.;;
+(*
+val t4 : ('a -> 'a code) code = .<fun x_67  -> .< x_67  >.>. 
+*)
+let true = !. ((!. t4) true);;
+
+(* From Problems.txt  Mon Jan 10 18:51:21 GMTST 2005
+  CSP constants in Pervasives (and similar) are type checked only once for
+  a given occurrence.
+   # let f x  = .< ref .~ x>.
+     in (!. (f .<3>.), !. (f .<1.3>.));;
+   This expression has type int but is here used with type float
+*)
+
+let t5 =
+  let f x  = .< ref .~ x>.
+  in (!. (f .<3>.), !. (f .<1.3>.));;
+
+(*
+val t5 : int ref * float ref = ({contents = 3}, {contents = 1.3})
+*)
+
+(* From Problems.txt Tue Jan 18 14:08:52 GMTST 2005
+  type aliases are not handled correctly in code, example:
+    # type a = int;;
+    # let f (x:a) = 1;;
+    # !. .<f 1>.;;
+*)
+type a = int;;
+let 1 =
+  let f (x:a) = 1 in
+  !. .<f 1>.;;
+
+(* From Problems.txt Oct 3, 2006 Printing of records in brackets *)
+
+let t7 = 
+  let open Complex in
+  .<let x = {re=1.0; im=2.0} in
+    let y = {x with re = 2.0} in
+    y>.
+ ;;
+
+(*
+val t7 : Complex.t code = .<
+  let x_14 = { Complex.re = 1.0; Complex.im = 2.0 } in
+  let y_15 = { x_14 with Complex.re = 2.0 } in y_15>. 
+*)
+
+let {Complex.re=2.0; im=2.0} = !. t7;;
+
+(* First-class polymorphism *)
+(*
+let tfc1 = {Runcode.cde = .<1>.};;
+(* - : int Runcode.cde = .<1>. *)
+let 1 = Runcode.run {Runcode.cde = .<1>.};;
+
+let tfc2 = .<{Runcode.cde = .<1>.}>.;;
+(*
+- : ('cl, int Runcode.cde) code = .<{Runcode.cde = .<1>.}>. 
+*)
+let tfc3 = !. .<{Runcode.cde = .<1>.}>.;;
+(* - : int Runcode.cde = .<1>.  *)
+let tfc4 = {Runcode.cde= .<{Runcode.cde = .<1>.}>.};;
+(* - : int Runcode.cde Runcode.cde = .<{Runcode.cde = .<1>.}>.  *)
+let tfc5 = Runcode.run {Runcode.cde= .<{Runcode.cde = .<1>.}>.};;
+(* - : int Runcode.cde = .<1>.  *)
+let 1 = Runcode.run (Runcode.run {Runcode.cde= .<{Runcode.cde = .<1>.}>.});;
+(* - : int = 1 *)
+*)
+
+(* complex runs *)
+let tr1 = .<fun x -> .~(!. .<.<1>.>.)>.;;
+let 1 = (!. tr1) 42;;
+(*
+val tr1 : ('a -> int) code = .<fun x_17  -> 1>. 
+*)
+
+let tr1' = .<fun x -> .~(!. .<.<fun x -> x>.>.)>.;;
+(*
+val tr1' : ('a -> 'b -> 'b) code = .<fun x_70  x_71_72  -> x_71_72>. 
+*)
+let 2 = (!. tr1') 1 2;;
+
+let tr2 = .<fun x -> .~(let x = !. .<1>. in .<x>.)>.;;
+(*
+val tr2 : ('a -> int) code = .<fun x_73  -> 1>. 
+*)
+let 1 = (!. tr2) 42;;
+
+Printf.printf "\nAll Done\n";;
diff --git a/ber-metaocaml-101/test/t4.ml b/ber-metaocaml-101/test/t4.ml
new file mode 100644
index 0000000..e783be3
--- /dev/null
+++ b/ber-metaocaml-101/test/t4.ml
@@ -0,0 +1,110 @@
+
+(* Author:  Walid Taha and Cristiano Calcagno
+   Date:    Fri Aug 31 03:03:11 EDT 2001 *)
+
+open Runcode;;
+open T4types;;
+
+let unJ(J i) = i
+let unF(F f) = f
+
+let term0 = A(L("x",V"x"),I 7)
+
+let term1 = A(R ("f","n", C(V "n",I 42,A (V "f",D (V "n")))),I 1000000)
+
+exception Yiikes
+;;
+
+let env0 = fun x -> raise Yiikes;;
+
+let ext env x v = fun y -> if x=y then v else env y
+
+let rec eval e env =
+match e with
+  I i -> J i
+| V s -> env s
+| A (e1,e2) -> (unF(eval e1 env)) (eval e2 env)
+| L (x,e) -> F (fun v -> eval e (ext env x v))
+| D e -> J ((unJ (eval e env))-1)
+| C (e1,e2,e3) -> if (unJ(eval e1 env))=0 
+                     then (eval e2 env)
+                     else (eval e3 env)
+| R (f,x,e) -> F (let rec ff xx = eval e (ext (ext env x xx)
+                                              f (F ff))
+                  in ff)
+;;
+
+let J 42 = eval term1 env0;; (* Unstaged *)
+
+let rec eval' e env =
+match e with
+  I i -> .<J i>.
+| V s -> env s
+| A (e1,e2) -> .<(unF .~(eval' e1 env)) (.~(eval' e2 env))>.
+| L (x,e) -> .<F (fun v -> .~(eval' e (ext env x .<v>.)))>.
+| D e -> .<J (unJ .~(eval' e env) - 1)>.
+| C (e1,e2,e3) -> .< if (unJ .~(eval' e1 env)) = 0 
+                              then .~(eval' e2 env)
+                              else .~(eval' e3 env) >.
+| R (f,x,e) ->
+  .<F (let rec ff xx = .~(eval' e (ext (ext env x .<xx>.) f .<F ff>.)) in ff)>.
+;;
+
+let stage1Running = eval' term1 env0;;
+
+(*
+val stage1Running : ('a, dom) code =
+  .<((((* cross-stage persistent value (as id: unF) *))
+     (F
+       (let rec ff_1 =
+         fun xx_2 ->
+          if ((((* cross-stage persistent value (as id: unJ) *)) xx_2) = 0) then
+           (J (42))
+          else
+           ((((* cross-stage persistent value (as id: unF) *)) (F (ff_1)))
+             (J
+               ((((* cross-stage persistent value (as id: unJ) *)) xx_2) - 1))) in
+        ff_1))) (J (1000000)))>.
+
+*)
+let compiling = !. .<fun () -> .~ stage1Running>.;;
+
+let J 42 = compiling ();;
+
+let unJ' = .<fun (J i) -> i>.
+let unF' = .<fun (F f) -> f>.
+
+let rec eval'' e env =
+match e with
+  I i -> .<J i>.
+| V s -> env s
+| A (e1,e2) -> .<.~unF' .~(eval'' e1 env) .~(eval'' e2 env)>.
+| L (x,e) -> .<F (fun v -> .~(eval'' e (ext env x .<v>.)))>.
+| D e -> .<J (.~unJ' .~(eval'' e env) - 1)>.
+| C (e1,e2,e3) -> .<if .~unJ' .~(eval'' e1 env) = 0 
+                              then .~(eval'' e2 env)
+                              else .~(eval'' e3 env)>.
+| R (f,x,e) ->
+  .<F (let rec ff xx = .~(eval'' e (ext (ext env x .<xx>.) f (.<F ff>.))) in ff)>.
+;;
+
+let stage1Running' = eval'' term1 env0;;
+
+(*
+val stage1Running' : ('a, dom) code =
+  .<((fun F (f_2) -> f_2)
+    (F
+      (let rec ff_1 =
+        fun xx_2 ->
+         if (((fun J (i_1) -> i_1) xx_2) = 0) then (J (42))
+         else
+          ((fun F (f_2) -> f_2) (F (ff_1))
+            (J (((fun J (i_1) -> i_1) xx_2) - 1))) in
+       ff_1)) (J (1000000)))>.
+*)
+
+let compiling' = !. .<fun () -> .~ stage1Running'>.;;
+
+let J 42 = (compiling' ());;
+
+Printf.printf "\n4.ml Done\n";;
diff --git a/ber-metaocaml-101/test/t4types.mli b/ber-metaocaml-101/test/t4types.mli
new file mode 100644
index 0000000..f200310
--- /dev/null
+++ b/ber-metaocaml-101/test/t4types.mli
@@ -0,0 +1,17 @@
+(* Data type declarations for the staged eval example by 
+   Walid Taha and Cristiano Calcagno
+
+In MetaOCaml N100, all data types used within brackets must be 
+in separate .ml or .mli files
+*)
+
+type exp = I of int
+         | V of string
+         | A of exp * exp
+         | L of string * exp
+         | D of exp
+         | C of exp * exp * exp
+         | R of string * string * exp
+
+type dom = J of int
+         | F of (dom -> dom)
diff --git a/ber-metaocaml-101/test/test20.ml b/ber-metaocaml-101/test/test20.ml
new file mode 100755
index 0000000..10effa7
--- /dev/null
+++ b/ber-metaocaml-101/test/test20.ml
@@ -0,0 +1,20 @@
+open Bool2
+
+type ('a,'b,'c) unary = {
+  unow : 'b -> 'c ;
+  ulater : ('a,'b) code -> ('a, 'c) code
+}
+
+module type SET =
+sig
+  type n
+  val to_string : ('a, n, string) unary
+end
+
+module E2 (N : SET) = struct
+    let to_str p = match p with
+      | Now (x,y) -> Now ((N.to_string.unow x) ^ (N.to_string.unow y))
+      | Later p -> Later (.< let (x, y) = .~p in 
+                .~(N.to_string.ulater .<x>.) ^ 
+                .~(N.to_string.ulater .<y>.) >. )
+end
diff --git a/ber-metaocaml-101/test/test21.ml b/ber-metaocaml-101/test/test21.ml
new file mode 100755
index 0000000..deb2a72
--- /dev/null
+++ b/ber-metaocaml-101/test/test21.ml
@@ -0,0 +1,5 @@
+(* this generates an error in BER-meta but not in meta-309-alpha-030 *)
+module Bool = struct module C = struct end end
+
+let h = .<"" ^ "">. 
+
diff --git a/ber-metaocaml-101/test/trivial.ml b/ber-metaocaml-101/test/trivial.ml
new file mode 100644
index 0000000..f22a6c9
--- /dev/null
+++ b/ber-metaocaml-101/test/trivial.ml
@@ -0,0 +1,1009 @@
+(* Trivial tests of MetaOCaml, which are also regression tests *)
+open Runcode;;
+
+3+2;;
+(* - : int = 5 *)
+let rec fact = function | 0 -> 1 | n -> n * fact (n-1);;
+(* val fact : int -> int = <fun> *)
+let 120 = fact 5;;
+
+.<1>.;;
+(* - : int code = .<1>. *)
+.<"aaa">.;;
+(* - : string code = .<"aaa">. *)
+let 1 = !. .<1>.;;
+(* - : int = 1 *)
+
+close_code .<1>.;;
+(* - : int Runcode.closed_code = .<1>.  *)
+
+
+.<fun x -> .~(let y = x in y)>.;;
+(*
+Characters 22-23:
+  .<fun x -> .~(let y = x in y)>.;;
+                        ^
+Error: Wrong level: variable bound at level 1 and used at level 0
+*)
+print_endline "Error was expected";;
+
+.<fun x -> 1 + .~(.<true>.)>.;;
+(*
+Characters 20-24:
+  .<fun x -> 1 + .~(.<true>.)>.;;
+                      ^^^^
+Error: This expression has type bool but an expression was expected of type
+         int
+*)
+print_endline "Error was expected";;
+
+
+(* CSP *)
+
+let x = 1 in .<x>.;;
+(*
+- : int code = .<1>.
+*)
+let x = 1.0 in .<x>.;;
+(*
+- : float code = .<1.>.
+*)
+let x = true in .<x>.;;
+(*
+- : bool code = .<true>.
+*)
+let x = "aaa" in .<x>.;;
+(*
+- : string code = .<"aaa">.
+*)
+let x = 'a' in .<x>.;;
+(*
+- : char code = .<'a'>.
+*)
+let x = ['a'] in .<x>.;;
+(*
+- : char list code = .<(* cross-stage persistent value (as id: x) *)>.
+*)
+
+let l x = .<x>.;;                       (* polymorphic *)
+(* val l : 'a -> ('cl, 'a) code = <fun> *)
+l 1;;
+(*
+- : int code = .<(* cross-stage persistent value (as id: x) *)>.
+*)
+let 1 = !. (l 1);;
+l 1.0;;                  (* better printing in N100 *)
+(*
+- : float code = .<1.>.
+*)
+let 1.0 = !. (l 1.0);;
+
+.<List.rev>.;;
+(*
+- : ('a list -> 'a list) code = .<List.rev>.
+*)
+
+.<Array.get>.;;
+(*
+- : ('a array -> int -> 'a) code = .<Array.get>.
+*)
+.<(+)>.;;
+(*
+- : (int -> int -> int) code = .<(+)>.
+*)
+
+
+let x = true in .<assert x>.;;
+(*
+- : unit code = .<assert true>.
+*)
+
+(* Applications and labels *)
+.<succ 1>.;;
+(*
+- : int code = .<succ 1>.
+*)
+
+let 2 = !. .<succ 1>.;;
+
+.<1 + 2>.;;
+(*
+- : int code = .<(1 + 2)>.
+*)
+let 3 = !. .<(1 + 2)>.;;
+
+.<String.length "abc">.;;
+(*
+- : int code = .<String.length "abc">.
+*)
+let 3 = 
+  !. .<String.length "abc">.;;
+
+.<StringLabels.sub ?pos:1 ?len:2 "abc">.;;
+(*
+- : string code = .<(StringLabels.sub "abc" ~pos:1 ~len:2>.
+*)
+let "bc" =
+  !. .<StringLabels.sub ?pos:1 ?len:2 "abc">.;;
+
+.<StringLabels.sub ~len:2 ~pos:1 "abc">.;;
+(*
+- : string code = .<(StringLabels.sub "abc" ~pos:1 ~len:2>.
+*)
+let "bc" =
+  !. .<StringLabels.sub ~len:2 ~pos:1 "abc">.;;
+
+(* Nested brackets and escapes and run *)
+.<.<1>.>.;;
+(* - : int code code = .<.< 1  >.>. *)
+!. .<.<1>.>.;;
+(* - : int code = .<1>. *)
+let 1 = !. !. .<.<1>.>.;;
+(* - : int = 1 *)
+.<!. .<1>.>.;;
+(*
+- : int code = .<Runcode.( !. )  (.< 1  >.)>. 
+*)
+let 1 = !. .<!. .<1>.>.;;
+.<1 + .~(let x = 2 in .<x>.)>.;;
+(*
+- : int code = .<(1 + 2)>.
+*)
+let x = .< 2 + 4 >. in .< .~ x + .~ x >. ;;
+(*
+- : int code = .<((2 + 4) + (2 + 4))>.
+*)
+let 12 = !. (let x = .< 2 + 4 >. in .< .~ x + .~ x >. );;
+
+.<1 + .~(let x = 2 in .<.<x>.>.)>.;;
+(*
+Characters 24-29:
+  .<1 + .~(let x = 2 in .<.<x>.>.)>.;;
+                          ^^^^^
+Error: This expression has type 'a code
+       but an expression was expected of type int
+*)
+print_endline "Error was expected";;
+.<1 + !. .~(let x = 2 in .<.<x>.>.)>.;;
+(*
+- : int code = .<1 + (Runcode.( !. )  (.< 2  >.))>. 
+*)
+let 3 = !. .<1 + !. .~(let x = 2 in .<.<x>.>.)>.;;
+!. .<1 + .~ (.~(let x = 2 in .<.<x>.>.))>.;;
+(*
+Characters 12-40:
+  !. .<1 + .~ (.~(let x = 2 in .<.<x>.>.))>.;;
+              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Error: Wrong level: escape at level 0
+*)
+print_endline "Error was expected";;
+
+.<.<.~(.<1>.)>.>.;;
+(*
+- : int code code = .<.< .~.< 1  >.  >.>. 
+- : ('cl, ('cl0, int) code) code = .<.<.~(.<1>.)>.>.
+*)
+!. .<.<.~(.<1>.)>.>.;;
+(*
+- : int code = .<1>.
+*)
+.<.<.~.~(.<.<1>.>.)>.>.;;
+(*
+- : int code code = .<.< .~.< 1  >.  >.>. 
+- : ('cl, ('cl0, int) code) code = .<.<.~(.<1>.)>.>.
+*)
+
+(* Lazy *)
+.<lazy 1>.;;
+(*
+- : int lazy_t code = .<lazy 1>. 
+*)
+let 1 = Lazy.force (!. .<lazy 1>.);;
+
+(* Tuples *)
+.<(1,"abc")>.;;
+(*
+- : (int * string) code = .<(1, "abc")>. 
+*)
+.<(1,"abc",'d')>.;;
+(*
+- : (int * string * char) code = .<(1, "abc", 'd')>. 
+*)
+let "abc" =
+  match !. .<(1,"abc",'d')>. with (_,x,_) -> x;;
+
+(* Arrays *)
+.<[||]>.;;
+(*
+- : 'a array code = .<[||]>. 
+*)
+let x = .<1+2>. in .<[|.~x;.~x|]>.;;
+(*
+- : int array code = .<[|(1 + 2);(1 + 2)|]>. 
+*)
+
+(* Constructors and enforcing externality *)
+.<raise Not_found>.;;
+(*
+- : 'a code = .<(raise (Not_found)>.
+*)
+.<raise (Scan_failure "")>.;;
+(*
+Characters 8-25:
+  .<raise (Scan_failure "")>.;;
+          ^^^^^^^^^^^^^^^^^
+Error: Unbound constructor Scan_failure
+*)
+print_endline "Error was expected";;
+.<raise (Scanf.Scan_failure "")>.;;
+(*
+- : 'a code = .<(raise (Scanf.Scan_failure (""))>.
+*)
+open Scanf;;
+.<raise (Scan_failure "")>.;;
+(*
+- : 'a code = .<Pervasives.raise (Scanf.Scan_failure "")>. 
+*)
+!. .<raise (Scan_failure "")>.;;
+(*
+Exception: Scanf.Scan_failure "".
+*)
+print_endline "Exception was expected";;
+
+
+.<true>.;;
+(*
+- : bool code = .<true>. 
+*)
+.<Some 1>.;;
+(*
+- : int option code = .<Some 1>. 
+*)
+.<Some [1]>.;;
+(*
+- : int list option code = .<Some [1]>. 
+*)
+let Some [1] = !. .<Some [1]>.;;
+.<None>.;;
+(*
+- : 'a option code = .<None>. 
+*)
+let None = !. .<None>.;;
+
+.<Genlex.Int 1>.;;
+(*
+- : Genlex.token code = .<Genlex.Int 1>. 
+*)
+open Genlex;;
+.<Int 1>.;;
+(*
+- : Genlex.token code = .<Genlex.Int 1>. 
+*)
+let Int 1 = !. .<Int 1>.;;
+
+module Foo = struct exception E end;;
+.<raise Foo.E>.;;
+(*
+Fatal error: exception Trx.TrxError("Exception Foo.E cannot be used within brackets. Put into a separate file.")
+*)
+print_endline "Error was expected";;
+
+type foo = Bar;;
+.<Bar>.;;
+(*
+Characters 2-5:
+  .<Bar>.;;
+    ^^^
+Error: Unqualified constructor Bar cannot be used within brackets. Put into a separate file.
+*)
+print_endline "Error was expected";;
+
+module Foo = struct type foo = Bar end;;
+.<Foo.Bar>.;;
+(*
+Characters 2-9:
+  .<Foo.Bar>.;;
+    ^^^^^^^
+Error: Constructor Bar cannot be used within brackets. Put into a separate file.
+*)
+print_endline "Error was expected";;
+
+(* Records *)
+
+.<{Complex.re = 1.0; im = 2.0}>.;;
+(*
+- : ('cl, Complex.t) code = .<{Complex.re = 1.0; Complex.im = 2.0}>.
+*)
+let {Complex.re = 1.; Complex.im = -2.} =
+  Complex.conj (!. .<{Complex.re = 1.0; im = 2.0}>.);;
+let x = {Complex.re = 1.0; im = 2.0} in .<x.re>.;;
+(*
+Characters 44-46:
+  let x = {Complex.re = 1.0; im = 2.0} in .<x.re>.;;
+                                              ^^
+Warning 40: re was selected from type Complex.t.
+It is not visible in the current scope, and will not 
+be selected if the type becomes unknown.
+- : float code = .<((* cross-stage persistent value (id: x) *)).Complex.re>. 
+*)
+
+let x = {Complex.re = 1.0; im = 2.0} in .<x.Complex.re>.;;
+(*
+- : float code =
+.<((* cross-stage persistent value (as id: x) *)).Complex.re>.
+*)
+let 1.0 = !.(let x = {Complex.re = 1.0; im = 2.0} in .<x.Complex.re>.);;
+let x = ref 1 in .<x.contents>.;;       (* Pervasive record *)
+(*
+- : int code =
+.<((* cross-stage persistent value (as id: x) *)).contents>.
+*)
+let 1 = !.(let x = ref 1 in .<x.contents>.);;
+let x = ref 1 in .<x.contents <- 2>.;;
+(*
+- : unit code =
+.<((* cross-stage persistent value (as id: x) *)).contents <- 2>.
+*)
+let x = ref 1 in (!. .<x.contents <- 2>.); x;;
+(* - : int ref = {contents = 2} *)
+
+open Complex;;
+.<{re = 1.0; im = 2.0}>.;;
+(*
+- : Complex.t code = .<{Complex.re = 1.0; Complex.im = 2.0}>.
+*)
+let 5.0 = norm (!. .<{re = 3.0; im = 4.0}>.);;
+let x = {re = 1.0; im = 2.0} in .<x.re>.;;
+(*
+- : float code =
+.<((* cross-stage persistent value (as id: x) *)).Complex.re>.
+*)
+let 1.0 = !.(let x = {re = 1.0; im = 2.0} in .<x.re>.);;
+
+type foo = {fool : int};;
+.<{fool = 1}>.;;
+(*
+Characters 3-7:
+  .<{fool = 1}>.;;
+     ^^^^
+Error: Unqualified label fool cannot be used within brackets. Put into a separate file.
+*)
+print_endline "Error was expected";;
+
+(* Conditional *)
+
+.<if true then 1 else 2>.;;
+(* - : int code = .<if true then 1 else 2>. *)
+.<if Some 1 = None then print_string "weird">.;;
+(*
+- : unit code = .<if (Some 1) = None then Pervasives.print_string "weird">. 
+*)
+let () = !. .<if Some 1 = None then print_string "weird">.;;
+
+(* Polymorphic variants *)
+.<`Foo>.;;
+(*
+- : [> `Foo ] code = .<`Foo>. 
+*)
+.<`Bar 1>.;;
+(*
+- : [> `Bar of int ] code = .<`Bar 1>. 
+*)
+let 1 = match !. .<`Bar 1>. with `Bar x -> x ;;
+
+(* Some support for modules *)
+let f = fun x -> .<x # foo>.;;
+(*
+val f : < foo : 'a; .. > -> 'a code = <fun>
+*)
+let x = object method foo = 1 end;;
+(*
+val x : < foo : int > = <obj>
+*)
+f x;;
+(*
+- : int code = .<((* cross-stage persistent value (id: x) *))#foo>. 
+*)
+let 1 = !. (f x);;
+
+(* Local open *)
+let 5.0 = !. .<Complex.(norm {re=3.0; im = 4.0})>.;;
+
+let 5.0 = !. .<let open Complex in norm {re=4.0; im = 3.0}>.;;
+
+(* For-loop *)
+
+.<for i=1 to 5 do Printf.printf "ok %d %d\n" i (i+1) done>.;;
+(*
+- : unit code = .<
+for i_1 = 1 to 5 do Printf.printf "ok %d %d\n" i_1 (i_1 + 1) done>. 
+*)
+!. .<for i=1 to 5 do Printf.printf "ok %d %d\n" i (i+1) done>.;;
+(*
+ok 1 2
+ok 2 3
+ok 3 4
+ok 4 5
+ok 5 6
+*)
+
+.<for i=5 downto 1 do Printf.printf "ok %d %d\n" i (i+1) done>.;;
+(*
+- : unit code = .<
+for i_3 = 5 downto 1 do Printf.printf "ok %d %d\n" i_3 (i_3 + 1) done>. 
+*)
+!. .<for i=5 downto 1 do Printf.printf "ok %d %d\n" i (i+1) done>.;;
+(*
+ok 5 6
+ok 4 5
+ok 3 4
+ok 2 3
+ok 1 2
+*)
+
+.<for i=1 to 2 do for j=1 to 3 do Printf.printf "ok %d %d\n" i j done done>.;;
+(*
+- : unit code = .<
+for i_5 = 1 to 2 do
+  for j_6 = 1 to 3 do Printf.printf "ok %d %d\n" i_5 j_6 done
+done>. 
+*)
+!. .<for i=1 to 2 do 
+     for j=1 to 3 do Printf.printf "ok %d %d\n" i j done done>.;;
+(*
+ok 1 1
+ok 1 2
+ok 1 3
+ok 2 1
+ok 2 2
+ok 2 3
+*)
+
+let c = .<for i=1 to 2 do .~(let x = .<i>. in 
+             .<for i=1 to 3 do Printf.printf "ok %d %d\n" i .~x done>.) done>.;;
+(*
+val c : unit code = .<
+  for i_9 = 1 to 2 do
+    for i_10 = 1 to 3 do Printf.printf "ok %d %d\n" i_10 i_9 done
+  done>. 
+*)
+!. c;;
+(*
+ok 1 1
+ok 2 1
+ok 3 1
+ok 1 2
+ok 2 2
+ok 3 2
+*)
+
+(* Scope extrusion test *)
+
+.<fun x -> .~(!. .<x>.; .<1>.)>.;;
+(*
+Exception:
+Failure
+ "The code built at Characters 6-7:\n  .<fun x -> .~(!. .<x>.; .<1>.)>.;;\n        ^\n is not closed: identifier x_28 bound at Characters 6-7:\n  .<fun x -> .~(!. .<x>.; .<1>.)>.;;\n        ^\n is free".
+
+Was:
+Characters 14-22:
+  .<fun x -> .~(!. .<x>.; .<1>.)>.;;
+                ^^^^^^^^
+Error: !. error: 'cl not generalizable in ('cl, 'a) code
+*)
+print_endline "Error was expected";;
+
+let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<0>.; .<()>.) done>.; 
+                     .<for i=1 to 5 do ignore (.~(!r)) done>.;;
+(*
+- : unit code = .<for i_13 = 1 to 5 do Pervasives.ignore 0 done>. 
+*)
+
+let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i>.; .<()>.) done>.; 
+                     .<for i=1 to 5 do ignore (.~(!r)) done>.;;
+(*
+Exception:
+Failure
+ "Scope extrusion detected at Characters 110-125:\n                       .<for i=1 to 5 do ignore (.~(!r)) done>.;;\n                                         ^^^^^^^^^^^^^^^\n for code built at Characters 27-28:\n  let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i>.; .<()>.) done>.; \n                             ^\n for the identifier i_14 bound at Characters 27-28:\n  let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i>.; .<()>.) done>.; \n                             ^\n".
+*)
+print_endline "Error was expected";;
+
+(* Better error message *)
+let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i+1>.; .<()>.) done>.; 
+                     .<for i=1 to 5 do ignore (.~(!r)) done>.;;
+
+(*
+Characters 21-70:
+  let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i+1>.; .<()>.) done>.; 
+                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Warning 10: this expression should have type unit.
+Exception:
+Failure
+ "Scope extrusion detected at Characters 112-127:\n                       .<for i=1 to 5 do ignore (.~(!r)) done>.;;\n                                         ^^^^^^^^^^^^^^^\n for code built at Characters 49-52:\n  let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i+1>.; .<()>.) done>.; \n                                                   ^^^\n for the identifier i_16 bound at Characters 27-28:\n  let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i+1>.; .<()>.) done>.; \n                             ^\n".
+*)
+print_endline "Error was expected";;
+
+(* Simple functions *)
+.<fun x -> x>.;;
+(*
+- : ('a -> 'a) code = .<fun x_7  -> x_7>. 
+*)
+let 42 = (!. .<fun x -> x>.) 42;;
+
+.<fun x y -> x + y>.;;
+(*
+- : (int -> int -> int) code = .<fun x_9  y_10  -> x_9 + y_10>. 
+*)
+let 5 = (!. .<fun x y -> x + y>.) 2 3;;
+
+.<fun x -> fun x -> x + x >.;;
+(*
+- : ('a -> int -> int) code = .<fun x_13  x_14  -> x_14 + x_14>. 
+*)
+let 8 = !. .<fun x -> fun x -> x + x >. 3 4;;
+
+(* Testing hygiene  *)
+let eta f = .<fun x -> .~(f .<x>.)>.;;
+(*
+val eta : ('a code -> 'b code) -> ('a -> 'b) code = <fun>
+*)
+eta (fun x -> .<1 + .~x>.);;
+(*
+- : (int -> int) code = .<fun x_17  -> 1 + x_17>. 
+*)
+eta (fun y -> .<fun x -> x + .~y>.);;
+(*
+- : (int -> int -> int) code = .<fun x_18  x_19  -> x_19 + x_18>. 
+*)
+let 5 = (!. (eta (fun y -> .<fun x -> x + .~y>.))) 2 3;;
+
+(* new identifiers must be generated at run-time *)
+let rec fhyg = fun y -> function
+  | 0 -> y
+  | n -> .<(fun x -> .~(fhyg .<.~y + x>. (n-1))) n>.;;
+(*
+val fhyg : int -> int code = <fun>
+*)
+fhyg .<1>. 3;;
+(*
+- : int code = .<
+(fun x_7  -> (fun x_8  -> (fun x_9  -> ((1 + x_7) + x_8) + x_9) 1) 2) 3>. 
+*)
+let 7 = !. (fhyg .<1>. 3);;
+
+(* pattern-matching, general functions *)
+
+.<fun () -> 1>.;;
+(* - : ('cl, unit -> int) code = .<fun () -> 1>. *)
+!. .<fun () -> 1>.;;
+(* - : unit -> int = <fun> *)
+let 1 = (!. .<fun () -> 1>.) ();;
+
+.<function true -> 1 | false -> 0>.;;
+(*
+- : ('cl, bool -> int) code = .<function | true -> 1 | false -> 0>. 
+*)
+let 1 = (!. .<function true -> 1 | false -> 0>.) true;;
+
+.<fun (true,[]) -> 1>.;;
+(*
+- : ('cl, bool * 'a list -> int) code = .<fun (true, []) -> 1>. 
+*)
+(!. .<fun (true,[]) -> 1>.) (true,[1]);;
+(*
+Exception: Match_failure ("//toplevel//", 1, 6).
+*)
+print_endline "Error was expected";;
+let 1 = (!. .<fun (true,[]) -> 1>.) (true,[]);;
+
+.<fun [|true;false;false|] -> 1>.;;
+(*
+- : ('cl, bool array -> int) code = .<fun [|true; false; false|] -> 1>. 
+*)
+let 1 = (!. .<fun [|true;false;false|] -> 1>.) [|true;false;false|];;
+
+.<function `F 1 -> true | _ -> false>.;;
+(*
+- : ('cl, [> `F of int ] -> bool) code = .<
+function | (`F 1) -> true | _ -> false>. 
+*)
+let true = (!. .<function `F 1 -> true | _ -> false>.) (`F 1);;
+.<function `F 1 | `G 2 -> true | _ -> false>.;;
+(*
+- : ('cl, [> `F of int | `G of int ] -> bool) code = .<
+function | ((`F 1) | (`G 2)) -> true | _ -> false>. 
+*)
+
+.<function (1,"str") -> 1 | (2,_) -> 2>.;;
+(*
+- : ('cl, int * string -> int) code = .<
+function | (1, "str") -> 1 | (2, _) -> 2>. 
+*)
+let 1 = (!. .<function (1,"str") -> 1 | (2,_) -> 2>.) (1,"str");;
+let 2 = (!. .<function (1,"str") -> 1 | (2,_) -> 2>.) (2,"str");;
+let 1 = (!. .<fun [1;2] -> 1>.) [1;2];;
+
+let 2 = (!. .<function None -> 1 | Some [1] -> 2>.) (Some [1]);;
+
+let 2 = (!. .<function (Some (Some true)) -> 1 | _ -> 2>.) (Some None);;
+let 1 = (!. .<function (Some (Some true)) -> 1 | _ -> 2>.) (Some (Some true));;
+let 2 = (!. .<function (Some (Some true)) -> 1 | _ -> 2>.) (Some (Some false));;
+let 2 = (!. .<function (Some (Some true)) -> 1 | _ -> 2>.) None;;
+
+open Complex;;
+.<function {re=1.0} -> 1 | {im=2.0; re = 2.0} -> 2 | {im=_} -> 3>.;;
+(*
+- : ('cl, Complex.t -> int) code = .<
+function
+| {Complex.re = 1.0} -> 1
+| {Complex.re = 2.0; Complex.im = 2.0} -> 2
+| {Complex.im = _} -> 3>. 
+*)
+
+let 1 = (!. .<function {re=1.0} -> 1 | {im=2.0; re = 2.0} -> 2 | {im=_} -> 3>.)
+        {re=1.0; im=2.0};;
+let 2 = (!. .<function {re=1.0} -> 1 | {im=2.0; re = 2.0} -> 2 | {im=_} -> 3>.)
+        {re=2.0; im=2.0};;
+(* - : int = 2 *)
+let 3 = (!. .<function {re=1.0} -> 1 | {im=2.0; re = 2.0} -> 2 | {im=_} -> 3>.)
+        {re=2.0; im=3.0};;
+
+(* General functions *)
+
+(* Non-binding pattern *)
+.<fun () -> 1>.;;
+(*
+- : (unit -> int) code = .<fun ()  -> 1>. 
+*)
+let 1 = !. .<fun () -> 1>. ();;
+
+.<fun _ -> true>.;;
+(* - : ('a -> bool) code = .<fun _  -> true>. *)
+let true = !. .<fun _ -> true>. 1;;
+
+.<fun (x,y) -> x + y>.;;
+(*
+- : (int * int -> int) code = .<fun (x_1,y_2)  -> x_1 + y_2>. 
+*)
+let 5 = (!. .<fun (x,y) -> x + y>.) (2,3);;
+.<function (Some x) as y -> x | _ ->  2>.;;
+(*
+- : (int option -> int) code = .<function | Some x_5 as y_6 -> x_5 | _ -> 2>. 
+*)
+let 1 = (!. .<function (Some x) as y -> x | _ ->  2>.) (Some 1);;
+let 2 = (!. .<function (Some x) as y -> x | _ ->  2>.) None;;
+.<function [x;y;z] -> x - y + z | [x;y] -> x - y>.;;
+(*
+- : (int list -> int) code = .<
+function
+| x_11::y_12::z_13::[] -> (x_11 - y_12) + z_13
+| x_14::y_15::[] -> x_14 - y_15>. 
+*)
+let 2 = (!. .<function [x;y;z] -> x - y + z | [x;y] -> x - y>.) [1;2;3];;
+
+ (* OR patterns *)
+.<function ([x;y] | [x;y;_]) -> x - y>.;;
+(*
+- : (int list -> int) code = .<
+fun (x_21::y_22::[]|x_21::y_22::_::[])  -> x_21 - y_22>. 
+*)
+let -1 = (!. .<function ([x;y] | [x;y;_]) -> x - y>.) [1;2];;
+let -1 = (!. .<function ([x;y] | [x;y;_]) -> x - y>.) [1;2;3];;
+(!. .<function ([x;y] | [x;y;_]) -> x - y>.) [1;2;3;4];;
+(* Exception: Match_failure ("//toplevel//", 1, 6). *)
+print_endline "Error was expected";;
+
+.<function ([x;y] | [x;y;_]| [y;x;_;_]) -> x - y>.;;
+(*
+- : (int list -> int) code = .<
+fun (x_29::y_30::[]|x_29::y_30::_::[]|y_30::x_29::_::_::[])  -> x_29 - y_30>. 
+*)
+let -1 = (!. .<function ([x;y] | [x;y;_]| [y;x;_;_]) -> x - y>.) [1;2];;
+let -1 = (!. .<function ([x;y] | [x;y;_]| [y;x;_;_]) -> x - y>.) [1;2;3];;
+let  1 = (!. .<function ([x;y] | [x;y;_]| [y;x;_;_]) -> x - y>.) [1;2;3;4];;
+
+.<function (`F x | `G x) -> x | `E x -> x>.;;
+(*
+- : ([< `E of 'a | `F of 'a | `G of 'a ] -> 'a) code = .<
+function | `F x_37|`G x_37 -> x_37 | `E x_38 -> x_38>. 
+*)
+let 2 = (!. .<function (`F x | `G x) -> x | `E x -> x>.) (`F 2);;
+open Complex;;
+.<function {re=x} -> x | {im=x; re=y} -> x -. y>.;;
+(*
+- : (Complex.t -> float) code = .<
+function
+| { Complex.re = x_41 } -> x_41
+| { Complex.re = y_42; Complex.im = x_43 } -> x_43 -. y_42>. 
+*)
+.<function {re=x; im=2.0} -> x | {im=x; re=y} -> x -. y>.;;
+(*
+- : (Complex.t -> float) code = .<
+function
+| { Complex.re = x_44; Complex.im = 2.0 } -> x_44
+| { Complex.re = y_45; Complex.im = x_46 } -> x_46 -. y_45>. 
+*)
+let 0. = (!. .<function {re=x; im=2.0} -> x | {im=x; re=y} -> x -. y>.) 
+         {re=1.0; im=1.0};;
+let 1. = (!. .<function {re=x; im=2.0} -> x | {im=x; re=y} -> x -. y>.) 
+         {re=1.0; im=2.0};;
+.<function (Some x) as y when x  > 0 -> y | _ -> None>.;;
+(*
+- : (int option -> int option) code = .<
+function | Some x_53 as y_54 when x_53 > 0 -> y_54 | _ -> None>. 
+*)
+let Some 1 = (!. .<function (Some x) as y when x  > 0 -> y | _ -> None>.)
+             (Some 1);;
+let None = (!. .<function (Some x) as y when x  > 0 -> y | _ -> None>.)
+           (Some 0);;
+
+(* pattern-matching *)
+.<match 1 with 1 -> true>.;;
+(*
+- : bool code = .<match 1 with | 1 -> true>. 
+*)
+let true = !. .<match 1 with 1 -> true>.;;
+
+.<match (1,2) with (1,x) -> true | x -> false>.;;
+(*
+- : bool code = .<match (1, 2) with | (1,x_5) -> true | x_6 -> false>. 
+*)
+.<match [1;2] with [x] -> x | [x;y] -> x + y>.;;
+(*
+- : int code = .<
+match [1; 2] with | x_7::[] -> x_7 | x_8::y_9::[] -> x_8 + y_9>. 
+*)
+let 3 = 
+  !. .<match [1;2] with [x] -> x | [x;y] -> x + y>.;;
+
+(* OR patterns *)
+.<match [1;2] with [x] -> x | [x;y] | [x;y;_] -> x + y>.;;
+(*
+- : int code = .<
+match [1; 2] with
+| x_13::[] -> x_13
+| x_14::y_15::[]|x_14::y_15::_::[] -> x_14 + y_15>. 
+*)
+let 3 = !. .<match [1;2] with [x] -> x | [x;y] | [x;y;_] -> x + y>.;;
+
+.<match [1;2;3;4] with [x] -> x | [x;y] | [x;y;_] | [y;x;_;_] -> x - y>.;;
+(*
+- : int code = .<
+match [1; 2; 3; 4] with
+| x_19::[] -> x_19
+| x_20::y_21::[]|x_20::y_21::_::[]|y_21::x_20::_::_::[] -> x_20 - y_21>. 
+*)
+let 1 =
+  !. .<match [1;2;3;4] with [x] -> x | [x;y] | [x;y;_] | [y;x;_;_] -> x - y>.;;
+
+.<fun x -> match x with (`F x | `G x) -> x | `E x -> x>.;;
+(*
+- : ([< `E of 'a | `F of 'a | `G of 'a ] -> 'a) code = .<
+fun x_25  -> match x_25 with | `F x_26|`G x_26 -> x_26 | `E x_27 -> x_27>. 
+*)
+
+let 1 = (!. .<fun x -> match x with (`F x | `G x) -> x | `E x -> x>.) (`G 1);;
+
+open Complex;;
+.<fun x -> match x with {re=x; im=2.0} -> x | {im=x; re=y} -> x -. y>.;;
+(*
+- : (Complex.t -> float) code = .<
+fun x_31  ->
+  match x_31 with
+  | { Complex.re = x_32; Complex.im = 2.0 } -> x_32
+  | { Complex.re = y_33; Complex.im = x_34 } -> x_34 -. y_33>.
+*)
+
+let 1.0 =
+  (!. .<fun x -> match x with {re=x; im=2.0} -> x | {im=x; re=y} -> x -. y>.)
+    {im=2.0; re=1.0};;
+
+
+(* try *)
+.<fun x -> try Some (List.assoc x [(1,true); (2,false)]) with Not_found -> None>.;;
+(*
+- : (int -> bool option) code = .<
+fun x_39  ->
+  try Some (List.assoc x_39 [(1, true); (2, false)])
+  with | Not_found  -> None>.
+*)
+let Some true =
+  (!. .<fun x -> try Some (List.assoc x [(1,true); (2,false)]) with Not_found -> None>.) 1;;
+let Some false =
+ (!. .<fun x -> try Some (List.assoc x [(1,true); (2,false)]) with Not_found -> None>.) 2;;
+let None =
+ (!. .<fun x -> try Some (List.assoc x [(1,true); (2,false)]) with Not_found -> None>.) 3;;
+
+.<fun x -> let open Scanf in try sscanf x "%d" (fun x -> string_of_int x) with Scan_failure x -> "fail " ^ x>.;;
+(*
+- : (string -> string) code = .<
+fun x_43  ->
+  let open Scanf in
+    try Scanf.sscanf x_43 "%d" (fun x_44  -> Pervasives.string_of_int x_44)
+    with | Scanf.Scan_failure x_45 -> "fail " ^ x_45>.
+*)
+
+let "1" = 
+  (!. .<fun x -> let open Scanf in try sscanf x "%d" (fun x -> string_of_int x) with Scan_failure x -> "fail " ^ x>.) "1";;
+let "fail scanf: bad input at char number 0: 'character 'x' is not a decimal digit'" =
+ (!. .<fun x -> let open Scanf in try sscanf x "%d" (fun x -> string_of_int x) with Scan_failure x -> "fail " ^ x>.) "xxx";;
+
+(* Simple let *)
+
+.<let x = 1 in x>.;;
+(*
+- : int code = .<let x_1 = 1 in x_1>. 
+*)
+let 1 = 
+  !. .<let x = 1 in x>.;;
+.<let x = 1 in let x = x + 1 in x>.;;
+(*
+- : int code = .<let x_55 = 1 in let x_56 = x_55 + 1 in x_56>. 
+*)
+let 2 = 
+  !. .<let x = 1 in let x = x + 1 in x>.;;
+.<let rec f = fun n -> if n = 0 then 1 else n * f (n-1) in f 5>.;;
+(*
+- : int code = .<
+let rec f_7 n_8 = if n_8 = 0 then 1 else n_8 * (f_7 (n_8 - 1)) in f_7 5>. 
+*)
+let 120 =
+  !. .<let rec f = fun n -> if n = 0 then 1 else n * f (n-1) in f 5>.;;
+
+(* Recursive vs. non-recursive bindings *)
+.<let f = fun x -> x in 
+  let rec f = fun n -> if n = 0 then 1 else n * f (n-1) in f 5>.;;
+(*
+  Characters 6-7:
+  .<let f = fun x -> x in 
+        ^
+Warning 26: unused variable f.
+- : int code = .<
+let f_12 x_11 = x_11 in
+let rec f_13 n_14 = if n_14 = 0 then 1 else n_14 * (f_13 (n_14 - 1)) in
+f_13 5>. 
+*)
+
+let 120 = !. .<let f = fun x -> x in 
+               let rec f = fun n -> if n = 0 then 1 else n * f (n-1) in f 5>.;;
+
+.<let f = fun x -> x in 
+  let f = fun n -> if n = 0 then 1 else n * f (n-1) in f 5>.;;
+(*
+  - : int code = .<
+let f_20 x_19 = x_19 in
+let f_22 n_21 = if n_21 = 0 then 1 else n_21 * (f_20 (n_21 - 1)) in f_22 5>. 
+*)
+let 20 = !. .<let f = fun x -> x in 
+              let f = fun n -> if n = 0 then 1 else n * f (n-1) in f 5>.;;
+
+.<let rec [] = [] in []>.
+(*
+Characters 2-23:
+  .<let rec [] = [] in []>.;;
+    ^^^^^^^^^^^^^^^^^^^^^
+Error: Only variables are allowed as left-hand side of `let rec'
+*)
+print_endline "Error was expected";;
+
+.<let rec f = f in f>.
+(*
+Exception:
+Failure
+ "Recursive let binding Characters 2-20:\n  .<let rec f = f in f>.;;\n    ^^^^^^^^^^^^^^^^^^\n must be to a function Characters 10-11:\n  .<let rec f = f in f>.;;\n            ^\n".
+*)
+print_endline "Error was expected";;
+
+(* General let rec *)
+.<fun x -> let rec even = function 0 -> true | x -> odd (x-1) and 
+                   odd  = function 0 -> false | x -> even (x-1) in even x>.;;
+(*
+  - : (int -> bool) code = .<
+fun x_80  ->
+  let rec even_81 = function | 0 -> true | x_84 -> odd_82 (x_84 - 1)
+  and odd_82 = function | 0 -> false | x_83 -> even_81 (x_83 - 1) in
+  even_81 x_80>.
+*)
+let true = (!. .<fun x -> let rec even = function 0 -> true | x -> odd (x-1) and odd = function 0 -> false | x -> even (x-1) in even x>.) 42;;
+let false = (!. .<fun x -> let rec even = function 0 -> true | x -> odd (x-1) and odd = function 0 -> false | x -> even (x-1) in even x>.) 43;;
+
+
+(* General let *)
+.<let x = 1 and y = 2 in x + y>.;;
+(*
+- : int code = .<let x_73 = 1 and y_74 = 2 in x_73 + y_74>. 
+*)
+let 3 = !. .<let x = 1 and y = 2 in x + y>.;;
+
+.<let x = 1 in let x = x+1 and y = x+1 in x + y>.;;
+(*
+- : int code = .<
+let x_77 = 1 in let x_78 = x_77 + 1 and y_79 = x_77 + 1 in x_78 + y_79>. 
+*)
+let 4 = !. .<let x = 1 in let x = x+1 and y = x+1 in x + y>.;;
+.<fun x -> let (Some x) = x in x + 1>.;;
+(*
+Characters 15-23:
+  .<fun x -> let (Some x) = x in x + 1>.;;
+                 ^^^^^^^^
+Warning 8: this pattern-matching is not exhaustive.
+Here is an example of a value that is not matched:
+None
+- : (int option -> int) code = .<
+fun x_83  -> let Some x_84 = x_83 in x_84 + 1>. 
+*)
+let 3 = (!. .<fun x -> let (Some x) = x in x + 1>.) (Some 2);;
+(!. .<fun x -> let (Some x) = x in x + 1>.) None;;
+(*
+Characters 19-27:
+  (!. .<fun x -> let (Some x) = x in x + 1>.) None;;
+                     ^^^^^^^^
+Warning 8: this pattern-matching is not exhaustive.
+Here is an example of a value that is not matched:
+None
+Exception: Match_failure ("//toplevel//", 1, 19).
+*)
+print_endline "Error was expected";;
+
+
+
+(* testing scope extrusion *)
+let r = ref .<0>. in let _ = .<fun x -> .~(r := .<1>.; .<0>.)>. in !r ;;
+(* - : int code = .<1>.  *)
+let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in !r ;;
+(*
+- : int code = .<x_30>.
+
+Failure("The code built at Characters 35-36:\n  let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in !r ;;\n                                     ^\n is not closed: identifier x_30 bound at Characters 35-36:\n  let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in !r ;;\n                                     ^\n is free")
+*)
+print_endline "Error was expected";;
+
+let c = let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in (!r) in !. c;;
+(*
+Exception:
+Failure
+ "The code built at Characters 43-44:\n  let c = let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in (!r) in !. c;;\n                                             ^\n is not closed: identifier x_31 bound at Characters 43-44:\n  let c = let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in (!r) in !. c;;\n                                             ^\n is free".
+*)
+print_endline "Error was expected";;
+
+let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in !r ;;
+(*
+- : ('_a -> '_a) code = .<fun y_34  -> x_33>.
+
+Failure("The code built at Characters 57-67:\n  let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in !r ;;\n                                                           ^^^^^^^^^^\n is not closed: identifier x_33 bound at Characters 42-43:\n  let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in !r ;;\n                                            ^\n is free")
+
+*)
+print_endline "Error was expected";;
+
+(* Error message is reported on splice *)
+let r = ref .<fun y->y>. in 
+let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in .<fun x -> .~(!r) 1>. ;;
+(*
+Exception:
+Failure
+ "Scope extrusion detected at Characters 95-103:\n  let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in .<fun x -> .~(!r) 1>. ;;\n                                                                    ^^^^^^^^\n for code built at Characters 58-68:\n  let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in .<fun x -> .~(!r) 1>. ;;\n                               ^^^^^^^^^^\n for the identifier x_36 bound at Characters 43-44:\n  let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in .<fun x -> .~(!r) 1>. ;;\n                ^\n".
+*)
+print_endline "Error was expected";;
+
+(* Unlike BER N100, the test is exact. The following is accepted with BER N101
+   (it wasn't with BER N100) 
+*)
+let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> y>.; .<0>.)>. in !r ;;
+(*
+- : ('_a -> '_a) code = .<fun y_41  -> y_41>. 
+*)
+(* Was in N100: print_endline "Error was expected";; *)
+
+(* The following are OK though *)
+let r = ref .<fun y->y>. in .<fun x -> .~(r := .<fun y -> y>.; !r)>.;;
+(*
+- : ('_a -> '_b -> '_b) code = .<fun x_43  y_44  -> y_44>. 
+*)
+let r = ref .<fun y->y>. in .<fun x -> .~(r := .<fun y -> x>.; !r)>.;;
+(*
+- : ('_a -> '_a -> '_a) code = .<fun x_46  y_47  -> x_46>. 
+*)
+let 3 = 
+ let r = ref .<fun y->y>. in !. .<fun x -> .~(r := .<fun y -> x>.; !r)>. 3 4;;
+
+print_endline "\nAll done\n";;
diff --git a/ber-metaocaml-101/trivial.ref b/ber-metaocaml-101/trivial.ref
new file mode 100644
index 0000000..5ec59d7
--- /dev/null
+++ b/ber-metaocaml-101/trivial.ref
@@ -0,0 +1,341 @@
+BER MetaOCaml toplevel, version N 101
+        OCaml version 4.01.1+dev0-2013-09-11
+
+#   #   - : int = 5
+#   val fact : int -> int = <fun>
+#   #   - : int code = .<1>. 
+#   - : string code = .<"aaa">. 
+#   #     - : int Runcode.closed_code = .<1>. 
+#       Characters 67-68:
+  .<fun x -> .~(let y = x in y)>.;;
+                        ^
+Error: Wrong level: variable bound at level 1 and used at level 0
+# * * * * *   Error was expected
+- : unit = ()
+#   Characters 21-25:
+  .<fun x -> 1 + .~(.<true>.)>.;;
+                      ^^^^
+Error: This expression has type bool but an expression was expected of type
+         int
+# * * * * * *   Error was expected
+- : unit = ()
+#         - : int code = .<1>. 
+# * *   - : float code = .<1.>. 
+# * *   - : bool code = .<true>. 
+# * *   - : string code = .<"aaa">. 
+# * *   - : char code = .<'a'>. 
+# * *   - : char list code = .<(* cross-stage persistent value (id: x) *)>. 
+# * *     val l : 'a -> 'a code = <fun>
+#   - : int code = .<(* cross-stage persistent value (id: x) *)>. 
+# * *   # - : float code = .<1.>. 
+# * *   #   - : ('a list -> 'a list) code = .<List.rev>. 
+# * *     - : ('a array -> int -> 'a) code = .<Array.get>. 
+# * *   - : (int -> int -> int) code = .<Pervasives.( + ) >. 
+# * *       - : unit code = .<assert true>. 
+# * *       - : int code = .<Pervasives.succ 1>. 
+# * *     #   - : int code = .<1 + 2>. 
+# * *   #   - : int code = .<String.length "abc">. 
+# * *     #   - : string code = .<StringLabels.sub "abc" ~pos:1 ~len:2>. 
+# * *     #   - : string code = .<StringLabels.sub "abc" ~pos:1 ~len:2>. 
+# * *     #     - : int code code = .<.< 1  >.>. 
+#   - : int code = .<1>. 
+#   #   - : int code = .<Runcode.( !. )  (.< 1  >.)>. 
+# * *   # - : int code = .<1 + 2>. 
+# * *   - : int code = .<(2 + 4) + (2 + 4)>. 
+# * *   #   Characters 25-30:
+  .<1 + .~(let x = 2 in .<.<x>.>.)>.;;
+                          ^^^^^
+Error: This expression has type 'a code
+       but an expression was expected of type int
+# * * * * * *   Error was expected
+- : unit = ()
+# - : int code = .<1 + (Runcode.( !. )  (.< 2  >.))>. 
+# * *   # Characters 12-40:
+  !. .<1 + .~ (.~(let x = 2 in .<.<x>.>.))>.;;
+              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Error: Wrong level: escape at level 0
+# * * * * *   Error was expected
+- : unit = ()
+#   - : int code code = .<.< .~.< 1  >.  >.>. 
+# * * *   - : int code = .<1>. 
+# * *   - : int code code = .<.< .~.< 1  >.  >.>. 
+# * * *       - : int lazy_t code = .<lazy 1>. 
+# * *   #     - : (int * string) code = .<(1, "abc")>. 
+# * *   - : (int * string * char) code = .<(1, "abc", 'd')>. 
+# * *     #     - : 'a array code = .<[||]>. 
+# * *   - : int array code = .<[|(1 + 2);(1 + 2)|]>. 
+# * *       - : 'a code = .<Pervasives.raise Not_found>. 
+# * *   Characters 52-64:
+  .<raise (Scan_failure "")>.;;
+           ^^^^^^^^^^^^
+Error: Unbound constructor Scan_failure
+# * * * * *   Error was expected
+- : unit = ()
+# - : 'a code = .<Pervasives.raise (Scanf.Scan_failure "")>. 
+# * *   # - : 'a code = .<Pervasives.raise (Scanf.Scan_failure "")>. 
+# * *   Exception: Scanf.Scan_failure "".
+# * *   Exception was expected
+- : unit = ()
+#     - : bool code = .<true>. 
+# * *   - : int option code = .<Some 1>. 
+# * *   - : int list option code = .<Some [1]>. 
+# * *   # - : 'a option code = .<None>. 
+# * *   #   - : Genlex.token code = .<Genlex.Int 1>. 
+# * *   # - : Genlex.token code = .<Genlex.Int 1>. 
+# * *   #   module Foo : sig exception E end
+# Characters 8-13:
+  .<raise Foo.E>.;;
+          ^^^^^
+Error: Exception Foo.E cannot be used within brackets. Put into a separate file.
+# * *   Error was expected
+- : unit = ()
+#   type foo = Bar
+# Characters 2-5:
+  .<Bar>.;;
+    ^^^
+Error: Unqualified constructor Bar cannot be used within brackets. Put into a separate file.
+# * * * * *   Error was expected
+- : unit = ()
+#   module Foo : sig type foo = Bar end
+# Characters 2-9:
+  .<Foo.Bar>.;;
+    ^^^^^^^
+Error: Constructor Bar cannot be used within brackets. Put into a separate file.
+# * * * * *   Error was expected
+- : unit = ()
+#       - : Complex.t code = .<{ Complex.re = 1.0; Complex.im = 2.0 }>. 
+# * *     # - : float code = .<((* cross-stage persistent value (id: x) *)).Complex.re>. 
+# * * * * * * * *     - : float code = .<((* cross-stage persistent value (id: x) *)).Complex.re>. 
+# * * *   # - : int code = .<
+((* cross-stage persistent value (id: x) *)).Pervasives.contents>. 
+# * * *   # - : unit code = .<
+((* cross-stage persistent value (id: x) *)).Pervasives.contents <- 2>. 
+# * * *   - : int ref = {contents = 2}
+#     # - : Complex.t code = .<{ Complex.re = 1.0; Complex.im = 2.0 }>. 
+# * *   # - : float code = .<((* cross-stage persistent value (id: x) *)).Complex.re>. 
+# * * *   #   type foo = { fool : int; }
+# Characters 3-7:
+  .<{fool = 1}>.;;
+     ^^^^
+Error: Unqualified label fool cannot be used within brackets. Put into a separate file.
+# * * * * *   Error was expected
+- : unit = ()
+#       - : int code = .<if true then 1 else 2>. 
+#   - : unit code = .<if (Some 1) = None then Pervasives.print_string "weird">. 
+# * *   #     - : [> `Foo ] code = .<`Foo>. 
+# * *   - : [> `Bar of int ] code = .<`Bar 1>. 
+# * *   #     val f : < foo : 'a; .. > -> 'a code = <fun>
+# * *   val x : < foo : int > = <obj>
+# * *   - : int code = .<((* cross-stage persistent value (id: x) *))#foo>. 
+# * *   #     #   #       - : unit code = .<
+for i_1 = 1 to 5 do Printf.printf "ok %d %d\n" i_1 (i_1 + 1) done>. 
+# * * *   ok 1 2
+ok 2 3
+ok 3 4
+ok 4 5
+ok 5 6
+- : unit = ()
+# * * * * * *     - : unit code = .<
+for i_3 = 5 downto 1 do Printf.printf "ok %d %d\n" i_3 (i_3 + 1) done>. 
+# * * *   ok 5 6
+ok 4 5
+ok 3 4
+ok 2 3
+ok 1 2
+- : unit = ()
+# * * * * * *     - : unit code = .<
+for i_5 = 1 to 2 do
+  for j_6 = 1 to 3 do Printf.printf "ok %d %d\n" i_5 j_6 done
+done>. 
+# * * * * *     ok 1 1
+ok 1 2
+ok 1 3
+ok 2 1
+ok 2 2
+ok 2 3
+- : unit = ()
+# * * * * * * *       val c : unit code = .<
+  for i_9 = 1 to 2 do
+    for i_10 = 1 to 3 do Printf.printf "ok %d %d\n" i_10 i_9 done
+  done>. 
+# * * * * *   ok 1 1
+ok 2 1
+ok 3 1
+ok 1 2
+ok 2 2
+ok 3 2
+- : unit = ()
+# * * * * * * *         Exception:
+Failure
+ "The code built at Characters 83-84:\n  .<fun x -> .~(!. .<x>.; .<1>.)>.;;\n        ^\n is not closed: identifier x_11 bound at Characters 83-84:\n  .<fun x -> .~(!. .<x>.; .<1>.)>.;;\n        ^\n is free".
+# * * * * * * * * * *   Error was expected
+- : unit = ()
+#     - : unit code = .<for i_13 = 1 to 5 do Pervasives.ignore 0 done>. 
+# * *       Exception:
+Failure
+ "Scope extrusion detected at Characters 184-199:\n                       .<for i=1 to 5 do ignore (.~(!r)) done>.;;\n                                         ^^^^^^^^^^^^^^^\n for code built at Characters 101-102:\n  let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i>.; .<()>.) done>.; \n                             ^\n for the identifier i_14 bound at Characters 101-102:\n  let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i>.; .<()>.) done>.; \n                             ^\n".
+# * * * *   Error was expected
+- : unit = ()
+#       Exception:
+Failure
+ "Scope extrusion detected at Characters 140-155:\n                       .<for i=1 to 5 do ignore (.~(!r)) done>.;;\n                                         ^^^^^^^^^^^^^^^\n for code built at Characters 77-80:\n  let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i+1>.; .<()>.) done>.; \n                                                   ^^^\n for the identifier i_16 bound at Characters 55-56:\n  let r = ref .<0>. in .<for i=1 to 5 do .~(r := .<i+1>.; .<()>.) done>.; \n                             ^\n".
+#   * * * * * * * *   Error was expected
+- : unit = ()
+#     - : ('a -> 'a) code = .<fun x_18  -> x_18>. 
+# * *   #   - : (int -> int -> int) code = .<fun x_20  y_21  -> x_20 + y_21>. 
+# * *   #   - : ('a -> int -> int) code = .<fun x_24  x_25  -> x_25 + x_25>. 
+# * *   #     val eta : ('a code -> 'b code) -> ('a -> 'b) code = <fun>
+# * *   - : (int -> int) code = .<fun x_28  -> 1 + x_28>. 
+# * *   - : (int -> int -> int) code = .<fun x_29  x_30  -> x_30 + x_29>. 
+# * *   #         val fhyg : int code -> int -> int code = <fun>
+# * *   - : int code = .<
+(fun x_33  -> (fun x_34  -> (fun x_35  -> ((1 + x_33) + x_34) + x_35) 1) 2) 3>.
+
+# * * *   #       - : (unit -> int) code = .<fun ()  -> 1>. 
+#   - : unit -> int = <fun>
+#   #   - : (bool -> int) code = .<function | true  -> 1 | false  -> 0>. 
+# * *   #   - : (bool * 'a list -> int) code = .<fun (true ,[])  -> 1>. 
+# * *   Exception: Match_failure ("//toplevel//", 441, 6).
+# * *   Error was expected
+- : unit = ()
+# #   - : (bool array -> int) code = .<fun [|true ;false ;false |]  -> 1>. 
+# * *   #   - : ([> `F of int ] -> bool) code = .<function | `F 1 -> true | _ -> false>. 
+# * * *   # - : ([> `F of int | `G of int ] -> bool) code = .<
+function | `F 1|`G 2 -> true | _ -> false>. 
+# * * *     - : (int * string -> int) code = .<function | (1,"str") -> 1 | (2,_) -> 2>. 
+# * * *   # # #   #   # # # #   # - : (Complex.t -> int) code = .<
+function
+| { Complex.re = 1.0 } -> 1
+| { Complex.re = 2.0; Complex.im = 2.0 } -> 2
+| { Complex.im = _ } -> 3>. 
+# * * * * * *       #   #     #         - : (unit -> int) code = .<fun ()  -> 1>. 
+# * *   #   - : ('a -> bool) code = .<fun _  -> true>. 
+#   #   - : (int * int -> int) code = .<fun (x_39,y_40)  -> x_39 + y_40>. 
+# * *   # - : (int option -> int) code = .<
+function | Some x_43 as y_44 -> x_43 | _ -> 2>. 
+# * *   # # - : (int list -> int) code = .<
+function
+| x_49::y_50::z_51::[] -> (x_49 - y_50) + z_51
+| x_52::y_53::[] -> x_52 - y_53>. 
+# * * * * *   #     - : (int list -> int) code = .<
+fun (x_59::y_60::[]|x_59::y_60::_::[])  -> x_59 - y_60>. 
+# * * *   # # Exception: Match_failure ("//toplevel//", 505, -90).
+#   Error was expected
+- : unit = ()
+#   - : (int list -> int) code = .<
+fun (x_67::y_68::[]|x_67::y_68::_::[]|y_68::x_67::_::_::[])  -> x_67 - y_68>. 
+# * * *   # # #   - : ([< `E of 'a | `F of 'a | `G of 'a ] -> 'a) code = .<
+function | `F x_75|`G x_75 -> x_75 | `E x_76 -> x_76>. 
+# * * *   # # - : (Complex.t -> float) code = .<
+function
+| { Complex.re = x_79 } -> x_79
+| { Complex.re = y_80; Complex.im = x_81 } -> x_81 -. y_80>. 
+# * * * * *   - : (Complex.t -> float) code = .<
+function
+| { Complex.re = x_82; Complex.im = 2.0 } -> x_82
+| { Complex.re = y_83; Complex.im = x_84 } -> x_84 -. y_83>. 
+# * * * * *     #   # - : (int option -> int option) code = .<
+function | Some x_91 as y_92 when x_91 > 0 -> y_92 | _ -> None>. 
+# * * *     #   #     - : bool code = .<match 1 with | 1 -> true>. 
+# * *   #   - : bool code = .<match (1, 2) with | (1,x_97) -> true | x_98 -> false>. 
+# * *   - : int code = .<
+match [1; 2] with | x_99::[] -> x_99 | x_100::y_101::[] -> x_100 + y_101>. 
+# * * *     #     - : int code = .<
+match [1; 2] with
+| x_105::[] -> x_105
+| x_106::y_107::[]|x_106::y_107::_::[] -> x_106 + y_107>. 
+# * * * * *   #   - : int code = .<
+match [1; 2; 3; 4] with
+| x_111::[] -> x_111
+| x_112::y_113::[]|x_112::y_113::_::[]|y_113::x_112::_::_::[] ->
+    x_112 - y_113>.
+
+# * * * * *     #   - : ([< `E of 'a | `F of 'a | `G of 'a ] -> 'a) code = .<
+fun x_117  ->
+  match x_117 with | `F x_118|`G x_118 -> x_118 | `E x_119 -> x_119>.
+
+# * * *     #   # - : (Complex.t -> float) code = .<
+fun x_123  ->
+  match x_123 with
+  | { Complex.re = x_124; Complex.im = 2.0 } -> x_124
+  | { Complex.re = y_125; Complex.im = x_126 } -> x_126 -. y_125>.
+
+# * * * * * *         #       - : (int -> bool option) code = .<
+fun x_131  ->
+  try Some (List.assoc x_131 [(1, true); (2, false)])
+  with | Not_found  -> None>.
+
+# * * * * *     #   #   #   - : (string -> string) code = .<
+fun x_135  ->
+  let open Scanf in
+    try
+      Scanf.sscanf x_135 "%d" (fun x_136  -> Pervasives.string_of_int x_136)
+    with | Scanf.Scan_failure x_137 -> "fail " ^ x_137>.
+
+# * * * * * *       #   #       - : int code = .<let x_144 = 1 in x_144>. 
+# * *     # - : int code = .<let x_146 = 1 in let x_147 = x_146 + 1 in x_147>. 
+# * *     # - : int code = .<
+let rec f_150 n_151 = if n_151 = 0 then 1 else n_151 * (f_150 (n_151 - 1)) in
+f_150 5>. 
+# * * *     #       - : int code = .<
+let f_155 x_154 = x_154 in
+let rec f_156 n_157 = if n_157 = 0 then 1 else n_157 * (f_156 (n_157 - 1)) in
+f_156 5>. 
+# * * * * * * * * *       #     - : int code = .<
+let f_163 x_162 = x_162 in
+let f_165 n_164 = if n_164 = 0 then 1 else n_164 * (f_163 (n_164 - 1)) in
+f_165 5>. 
+# * * * *     #     * * * * *   Characters 1-26:
+  .<let rec [] = [] in []>.
+  ^^^^^^^^^^^^^^^^^^^^^^^^^
+Error: This expression has type 'a list code
+       This is not a function; it cannot be applied.
+#     * * * *   Characters 1-23:
+  .<let rec f = f in f>.
+  ^^^^^^^^^^^^^^^^^^^^^^
+Error: This expression has type 'a code
+       This is not a function; it cannot be applied.
+#       - : (int -> bool) code = .<
+fun x_170  ->
+  let rec even_171 = function | 0 -> true | x_174 -> odd_172 (x_174 - 1)
+  and odd_172 = function | 0 -> false | x_173 -> even_171 (x_173 - 1) in
+  even_171 x_170>.
+
+# * * * * * *   # #       - : int code = .<let x_185 = 1 and y_186 = 2 in x_185 + y_186>. 
+# * *   #   - : int code = .<
+let x_189 = 1 in let x_190 = x_189 + 1 and y_191 = x_189 + 1 in x_190 + y_191>.
+
+# * * *   # - : (int option -> int) code = .<
+fun x_195  -> let Some x_196 = x_195 in x_196 + 1>. 
+# * * * * * * * * *   # Exception: Match_failure ("//toplevel//", 691, -265).
+# * * * * * * * *   Error was expected
+- : unit = ()
+#         - : int code = .<1>. 
+#   - : int code = .<x_202>.
+
+Failure("The code built at Characters 63-64:\n  let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in !r ;;\n                                     ^\n is not closed: identifier x_202 bound at Characters 63-64:\n  let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in !r ;;\n                                     ^\n is free")
+# * * * *   Error was expected
+- : unit = ()
+#   Exception:
+Failure
+ "The code built at Characters 44-45:\n  let c = let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in (!r) in !. c;;\n                                             ^\n is not closed: identifier x_203 bound at Characters 44-45:\n  let c = let r = ref .<0>. in let _ = .<fun x -> .~(r := .<x>.; .<0>.)>. in (!r) in !. c;;\n                                             ^\n is free".
+# * * * *   Error was expected
+- : unit = ()
+#   - : ('_a -> '_a) code = .<fun y_206  -> x_205>.
+
+Failure("The code built at Characters 58-68:\n  let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in !r ;;\n                                                           ^^^^^^^^^^\n is not closed: identifier x_205 bound at Characters 43-44:\n  let r = ref .<fun y->y>. in let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in !r ;;\n                                            ^\n is free")
+# * * * * *   Error was expected
+- : unit = ()
+#       Exception:
+Failure
+ "Scope extrusion detected at Characters 138-146:\n  let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in .<fun x -> .~(!r) 1>. ;;\n                                                                    ^^^^^^^^\n for code built at Characters 101-111:\n  let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in .<fun x -> .~(!r) 1>. ;;\n                               ^^^^^^^^^^\n for the identifier x_208 bound at Characters 86-87:\n  let _ = .<fun x -> .~(r := .<fun y -> x>.; .<0>.)>. in .<fun x -> .~(!r) 1>. ;;\n                ^\n".
+# * * * * *   Error was expected
+- : unit = ()
+#   * *   - : ('_a -> '_a) code = .<fun y_213  -> y_213>. 
+# * *         - : ('_a -> '_b -> '_b) code = .<fun x_215  y_216  -> y_216>. 
+# * *   - : ('_a -> '_a -> '_a) code = .<fun x_218  y_219  -> x_218>. 
+# * *     #   
+All done
+
+- : unit = ()
+# 
diff --git a/bytecomp/lambda.ml b/bytecomp/lambda.ml
index cfced85..cca6409 100644
--- a/bytecomp/lambda.ml
+++ b/bytecomp/lambda.ml
@@ -143,6 +143,7 @@ type structured_constant =
   | Const_block of int * structured_constant list
   | Const_float_array of string list
   | Const_immstring of string
+  | Const_csp_value of Obj.t                   (* NNN: immediate CSP *)
 
 type function_kind = Curried | Tupled
 
diff --git a/bytecomp/lambda.mli b/bytecomp/lambda.mli
index 17da073..dbcef13 100644
--- a/bytecomp/lambda.mli
+++ b/bytecomp/lambda.mli
@@ -143,6 +143,7 @@ type structured_constant =
   | Const_block of int * structured_constant list
   | Const_float_array of string list
   | Const_immstring of string
+  | Const_csp_value of Obj.t                   (* NNN: immediate CSP *)
 
 type function_kind = Curried | Tupled
 
diff --git a/bytecomp/printlambda.ml b/bytecomp/printlambda.ml
index 6531670..14bcf05 100644
--- a/bytecomp/printlambda.ml
+++ b/bytecomp/printlambda.ml
@@ -39,6 +39,8 @@ let rec struct_const ppf = function
       let floats ppf fl =
         List.iter (fun f -> fprintf ppf "@ %s" f) fl in
       fprintf ppf "@[<1>[|@[%s%a@]|]@]" f1 floats fl
+  | Const_csp_value _ ->                        (* NNN *)
+      fprintf ppf "(CSP_value)"(* NNN; or use print_obj from tools/dumpobj.ml *)
 
 let boxed_integer_name = function
   | Pnativeint -> "nativeint"
diff --git a/bytecomp/symtable.ml b/bytecomp/symtable.ml
index 63374f8..f50d6ec 100644
--- a/bytecomp/symtable.ml
+++ b/bytecomp/symtable.ml
@@ -218,6 +218,7 @@ let rec transl_const = function
       block
   | Const_float_array fields ->
       Obj.repr(Array.of_list(List.map (fun f -> float_of_string f) fields))
+  | Const_csp_value v -> v                                  (* NNN *)
 
 (* Build the initial table of globals *)
 
diff --git a/bytecomp/translcore.ml b/bytecomp/translcore.ml
index 36b79da..a5a0907 100644
--- a/bytecomp/translcore.ml
+++ b/bytecomp/translcore.ml
@@ -881,6 +881,13 @@ and transl_exp0 e =
           cl_loc = e.exp_loc;
           cl_type = Cty_signature cty;
           cl_env = e.exp_env }
+  | Texp_cspval (v,_) ->  Lconst(Const_csp_value v)         (* NNN *)
+  | Texp_escape _  | Texp_bracket _ ->                      (* NNN begin *)
+      Printtyped.implementation Format.err_formatter
+        {str_type = []; str_final_env = e.exp_env;
+         str_items = [{str_env = e.exp_env; str_loc = Location.none; 
+                       str_desc =Tstr_eval e}]};
+      fatal_error "Translcore.trans_exp with meta stuff"    (* NNN end *)
 
 and transl_list expr_list =
   List.map transl_exp expr_list
diff --git a/ocamldoc/Makefile b/ocamldoc/Makefile
index 144b95d..d7332cb 100644
--- a/ocamldoc/Makefile
+++ b/ocamldoc/Makefile
@@ -137,6 +137,7 @@ LIBCMOFILES=$(CMOFILES)
 LIBCMXFILES= $(LIBCMOFILES:.cmo=.cmx)
 LIBCMIFILES= $(LIBCMOFILES:.cmo=.cmi)
 
+# NNN add trx.ml and printtyped.cmo
 # Les cmo et cmx de la distrib OCAML
 OCAMLCMOFILES=$(OCAMLSRCDIR)/parsing/printast.cmo \
 	$(OCAMLSRCDIR)/typing/ident.cmo \
@@ -178,7 +179,9 @@ OCAMLCMOFILES=$(OCAMLSRCDIR)/parsing/printast.cmo \
 	$(OCAMLSRCDIR)/typing/typeclass.cmo \
 	$(OCAMLSRCDIR)/typing/mtype.cmo \
 	$(OCAMLSRCDIR)/typing/includemod.cmo \
+	$(OCAMLSRCDIR)/typing/trx.cmo \
 	$(OCAMLSRCDIR)/typing/typemod.cmo \
+	$(OCAMLSRCDIR)/typing/printtyped.cmo \
 	$(OCAMLSRCDIR)/bytecomp/lambda.cmo \
 	$(OCAMLSRCDIR)/bytecomp/typeopt.cmo \
 	$(OCAMLSRCDIR)/bytecomp/printlambda.cmo \
diff --git a/otherlibs/labltk/browser/searchpos.ml b/otherlibs/labltk/browser/searchpos.ml
index 13847e2..d4ab0bb 100644
--- a/otherlibs/labltk/browser/searchpos.ml
+++ b/otherlibs/labltk/browser/searchpos.ml
@@ -818,6 +818,7 @@ and search_pos_expr ~pos exp =
       search_pos_class_structure ~pos cls
   | Texp_pack modexp ->
       search_pos_module_expr modexp ~pos
+  | (Texp_bracket _|Texp_escape _|Texp_cspval (_, _)) -> ()
   end;
   add_found_str (`Exp(`Expr, exp.exp_type)) ~env:exp.exp_env ~loc:exp.exp_loc
   end
diff --git a/parsing/ast_mapper.ml b/parsing/ast_mapper.ml
index 1584e2e..6cb65e9 100644
--- a/parsing/ast_mapper.ml
+++ b/parsing/ast_mapper.ml
@@ -319,6 +319,11 @@ module E = struct
   let newtype ?loc a b = mk ?loc (Pexp_newtype (a, b))
   let pack ?loc a = mk ?loc (Pexp_pack a)
   let open_ ?loc a b c = mk ?loc (Pexp_open (a, b, c))
+  (* NNN begin *)
+  let bracket ?loc a = mk ?loc (Pexp_bracket a)
+  let escape ?loc a = mk ?loc (Pexp_escape a)
+  let cspval ?loc a b = mk ?loc (Pexp_cspval (a, b))
+  (* NNN end *)
 
   let lid ?(loc = Location.none) lid = ident ~loc (mkloc (Longident.parse lid) loc)
   let apply_nolabs ?loc f el = apply ?loc f (List.map (fun e -> ("", e)) el)
@@ -360,6 +365,10 @@ module E = struct
     | Pexp_newtype (s, e) -> newtype ~loc s (sub # expr e)
     | Pexp_pack me -> pack ~loc (sub # module_expr me)
     | Pexp_open (ovf, lid, e) -> open_ ~loc ovf (map_loc sub lid) (sub # expr e)
+  (* NNN through the end of the clause *)
+    | Pexp_bracket e -> bracket ~loc (sub # expr e)
+    | Pexp_escape e  -> escape  ~loc (sub # expr e)
+    | Pexp_cspval (v,lid)  -> cspval ~loc v (map_loc sub lid)
 end
 
 module P = struct
diff --git a/parsing/lexer.mll b/parsing/lexer.mll
index ae69b37..47a1e7b 100644
--- a/parsing/lexer.mll
+++ b/parsing/lexer.mll
@@ -255,6 +255,8 @@ let identchar_latin1 =
   ['A'-'Z' 'a'-'z' '_' '\192'-'\214' '\216'-'\246' '\248'-'\255' '\'' '0'-'9']
 let symbolchar =
   ['!' '$' '%' '&' '*' '+' '-' '.' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~']
+let symbolcharnodot =                                                  (* NNN *)
+ ['!' '$' '%' '&' '*' '+' '-' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~'] (* NNN *)
 let decimal_literal =
   ['0'-'9'] ['0'-'9' '_']*
 let hex_literal =
@@ -277,6 +279,9 @@ rule token = parse
       }
   | blank +
       { token lexbuf }
+  | ".<" { DOTLESS }     (* NNN *)
+  | ">." { GREATERDOT }  (* NNN *)
+  | ".~" { DOTTILDE }    (* NNN *)
   | "_"
       { UNDERSCORE }
   | "~"
@@ -431,8 +436,10 @@ rule token = parse
             { PREFIXOP(Lexing.lexeme lexbuf) }
   | ['~' '?'] symbolchar +
             { PREFIXOP(Lexing.lexeme lexbuf) }
-  | ['=' '<' '>' '|' '&' '$'] symbolchar *
+  | ['=' '<' '|' '&' '$'] symbolchar *	         (* NNN: ">." is not INFIXOP0 *)
             { INFIXOP0(Lexing.lexeme lexbuf) }
+  | ['>'] symbolcharnodot symbolchar *           (* NNN exclude ">." case *)
+            { INFIXOP0(Lexing.lexeme lexbuf) }   (* NNN *)
   | ['@' '^'] symbolchar *
             { INFIXOP1(Lexing.lexeme lexbuf) }
   | ['+' '-'] symbolchar *
@@ -441,6 +448,8 @@ rule token = parse
             { INFIXOP4(Lexing.lexeme lexbuf) }
   | ['*' '/' '%'] symbolchar *
             { INFIXOP3(Lexing.lexeme lexbuf) }
+  | "let" symbolchar*                            (* NNN *)
+            { LETOP(Lexing.lexeme lexbuf) }      (* NNN *)
   | eof { EOF }
   | _
       { raise (Error(Illegal_character (Lexing.lexeme_char lexbuf 0),
diff --git a/parsing/parser.mly b/parsing/parser.mly
index 429d6be..d567a85 100644
--- a/parsing/parser.mly
+++ b/parsing/parser.mly
@@ -298,10 +298,25 @@ let wrap_type_annotation newtypes core_type body =
   in
   (exp, ghtyp(Ptyp_poly(newtypes,varify_constructors newtypes core_type)))
 
+    (* NNN: the whole definition *)
+let let_operator op bindings cont =
+  let pat, expr =
+    match List.rev bindings with
+    | []  -> assert false
+    | [x] -> x
+    | l   ->
+        let pats, exprs = List.split l in
+        ghpat (Ppat_tuple pats), ghexp (Pexp_tuple exprs)
+    in
+      mkexp(Pexp_apply(op, [("", expr); 
+                            ("", ghexp(Pexp_function("", None, [pat, cont])))]))
 %}
 
 /* Tokens */
 
+%token DOTLESS     /* NNN */
+%token GREATERDOT  /* NNN */
+%token DOTTILDE    /* NNN */
 %token AMPERAMPER
 %token AMPERSAND
 %token AND
@@ -365,6 +380,7 @@ let wrap_type_annotation newtypes core_type body =
 %token LESS
 %token LESSMINUS
 %token LET
+%token <string> LETOP /* NNN */
 %token <string> LIDENT
 %token LPAREN
 %token MATCH
@@ -441,6 +457,7 @@ The precedences must be listed from low to high.
 %nonassoc below_SEMI
 %nonassoc SEMI                          /* below EQUAL ({lbl=...; lbl=...}) */
 %nonassoc LET                           /* above SEMI ( ...; let ... in ...) */
+%nonassoc LETOP           /* NNN */
 %nonassoc below_WITH
 %nonassoc FUNCTION WITH                 /* below BAR  (match ... with ...) */
 %nonassoc AND             /* above WITH (module rec A: SIG with ... and ...) */
@@ -465,6 +482,7 @@ The precedences must be listed from low to high.
 %nonassoc prec_unary_minus prec_unary_plus /* unary - */
 %nonassoc prec_constant_constructor     /* cf. simple_expr (C versus C x) */
 %nonassoc prec_constr_appl              /* above AS BAR COLONCOLON COMMA */
+%left	  prec_escape    /* NNN */
 %nonassoc below_SHARP
 %nonassoc SHARP                         /* simple_expr/toplevel_directive */
 %nonassoc below_DOT
@@ -968,6 +986,8 @@ expr:
       { mkexp(Pexp_apply($1, List.rev $2)) }
   | LET rec_flag let_bindings IN seq_expr
       { mkexp(Pexp_let($2, List.rev $3, $5)) }
+  | let_operator let_bindings IN seq_expr     /* NNN */
+      { let_operator $1 $2 $4 }               /* NNN */
   | LET MODULE UIDENT module_binding IN seq_expr
       { mkexp(Pexp_letmodule(mkrhs $3 3, $4, $6)) }
   | LET OPEN override_flag mod_longident IN seq_expr
@@ -1076,6 +1096,10 @@ simple_expr:
       { reloc_exp $2 }
   | LPAREN seq_expr error
       { unclosed "(" 1 ")" 3 }
+  | DOTLESS expr GREATERDOT                 /* NNN */
+      { mkexp(Pexp_bracket $2) }            /* NNN */
+  | DOTTILDE simple_expr %prec prec_escape  /* NNN */
+      { mkexp(Pexp_escape $2) }             /* NNN */
   | BEGIN seq_expr END
       { reloc_exp $2 }
   | BEGIN END
@@ -1705,6 +1729,7 @@ operator:
   | INFIXOP2                                    { $1 }
   | INFIXOP3                                    { $1 }
   | INFIXOP4                                    { $1 }
+  | LETOP                                       { $1 } /* NNN */
   | BANG                                        { "!" }
   | PLUS                                        { "+" }
   | PLUSDOT                                     { "+." }
@@ -1720,6 +1745,15 @@ operator:
   | AMPERAMPER                                  { "&&" }
   | COLONEQUAL                                  { ":=" }
 ;
+    /* NNN: the whole definition */
+let_operator:
+    LETOP                                   { mkexp (Pexp_ident(
+                                                     mkloc (Lident $1)
+                                                           (symbol_rloc ()))) }
+  | mod_longident DOT LETOP                 { mkexp (Pexp_ident(
+                                                     mkloc (Ldot($1,$3))
+                                                           (symbol_rloc ()))) }
+;
 constr_ident:
     UIDENT                                      { $1 }
 /*  | LBRACKET RBRACKET                           { "[]" } */
diff --git a/parsing/parsetree.mli b/parsing/parsetree.mli
index ce6ac36..eed78cb 100644
--- a/parsing/parsetree.mli
+++ b/parsing/parsetree.mli
@@ -119,6 +119,9 @@ and expression_desc =
   | Pexp_newtype of string * expression
   | Pexp_pack of module_expr
   | Pexp_open of override_flag * Longident.t loc * expression
+  | Pexp_bracket of expression (* NNN *)
+  | Pexp_escape of expression  (* NNN *)
+  | Pexp_cspval of Obj.t * Longident.t loc (* NNN *)
 
 (* Value descriptions *)
 
diff --git a/parsing/pprintast.ml b/parsing/pprintast.ml
index 0965ca6..fdea70d 100644
--- a/parsing/pprintast.ml
+++ b/parsing/pprintast.ml
@@ -47,7 +47,9 @@ let fixity_of_string  = function
   | _ -> `Normal
 
 let view_fixity_of_exp = function
-  | {pexp_desc = Pexp_ident {txt=Lident l;_};_} -> fixity_of_string l
+  | {pexp_desc = Pexp_ident {txt=Lident l}} -> fixity_of_string l
+  | {pexp_desc = Pexp_ident {txt=Ldot (Lident "Pervasives",l)}} 
+    -> fixity_of_string l
   | _ -> `Normal  ;;
 
 let is_infix  = function  | `Infix _ -> true | _  -> false
@@ -632,6 +634,23 @@ class printer  ()= object(self:'self)
           self#expression  e
     | Pexp_variant (l,Some eo) ->
         pp f "@[<2>`%s@;%a@]" l  self#simple_expr eo
+(* NNN through the end of the case *)
+    | Pexp_bracket (e) ->
+        pp f "@[<hov2>.<@ %a @ >.@]" self#expression e
+    | Pexp_escape (e) ->
+        let simple_exp = match e.pexp_desc with
+        | Pexp_ident (_) -> true
+        | _ -> false
+        in
+        pp f ".~%a" (self#paren simple_exp self#expression) e
+    | Pexp_cspval (v,li) ->
+      (* was: compiled code omitted
+         however, CSP values's are not always compiled code:
+           let f x = x in
+           let g   = .!.<fun x -> f x>. *)
+      pp f "(* cross-stage persistent value (id: %a) *)"
+          self#longident_loc li
+ (* NNN end *)
     | _ -> self#expression1 f x
   method expression1 f x =
     match x.pexp_desc with
diff --git a/parsing/printast.ml b/parsing/printast.ml
index 22c68ee..caedb66 100644
--- a/parsing/printast.ml
+++ b/parsing/printast.ml
@@ -338,6 +338,15 @@ and expression i ppf x =
       line i ppf "Pexp_open %a \"%a\"\n" fmt_override_flag ovf
         fmt_longident_loc m;
       expression i ppf e
+(* NNN through the end of the case *)
+  | Pexp_bracket (e) ->
+      line i ppf "Pexp_bracket\n";
+      expression i ppf e;
+  | Pexp_escape (e) ->
+      line i ppf "Pexp_escape\n";
+      expression i ppf e;
+  | Pexp_cspval (v,li) ->
+      line i ppf "Pexp_cspval <compiled_code> (as id: %a)" fmt_longident_loc li
 
 and value_description i ppf x =
   line i ppf "value_description %a\n" fmt_location x.pval_loc;
diff --git a/tools/depend.ml b/tools/depend.ml
index 328ca49..4a463f0 100644
--- a/tools/depend.ml
+++ b/tools/depend.ml
@@ -178,6 +178,10 @@ let rec add_expr bv exp =
   | Pexp_newtype (_, e) -> add_expr bv e
   | Pexp_pack m -> add_module bv m
   | Pexp_open (_ovf, m, e) -> addmodule bv m; add_expr bv e
+(* NNN through the rest of the pattern-match *)
+  | Pexp_bracket e -> add_expr bv e
+  | Pexp_escape e  -> add_expr bv e
+  | Pexp_cspval _  -> ()
 
 and add_pat_expr_list bv pel =
   List.iter (fun (p, e) -> let bv = add_pattern bv p in add_expr bv e) pel
diff --git a/tools/dumpobj.ml b/tools/dumpobj.ml
index b2af788..4a4a9ef 100644
--- a/tools/dumpobj.ml
+++ b/tools/dumpobj.ml
@@ -104,6 +104,8 @@ let rec print_struct_const = function
       printf "[|";
       List.iter (fun f -> print_float f; printf "; ") a;
       printf "|]"
+  | Const_csp_value obj ->                    (* NNN *)
+      printf "CSP_value"  (* print_obj obj *)    (* NNN *)
 
 (* Print an obj *)
 
diff --git a/tools/ocamlprof.ml b/tools/ocamlprof.ml
index 72c9900..5cd2fcd 100644
--- a/tools/ocamlprof.ml
+++ b/tools/ocamlprof.ml
@@ -283,6 +283,9 @@ and rw_exp iflag sexp =
   | Pexp_newtype (_, sexp) -> rewrite_exp iflag sexp
   | Pexp_open (_ovf, _, e) -> rewrite_exp iflag e
   | Pexp_pack (smod) -> rewrite_mod iflag smod
+(* NNN through the rest of the pattern-match *)
+  | Pexp_bracket e | Pexp_escape e -> rewrite_exp iflag e
+  | Pexp_cspval _ -> ()
 
 and rewrite_ifbody iflag ghost sifbody =
   if !instr_if && not ghost then
diff --git a/tools/tast_iter.ml b/tools/tast_iter.ml
index b02a4d2..dddd6c6 100644
--- a/tools/tast_iter.ml
+++ b/tools/tast_iter.ml
@@ -160,6 +160,9 @@ let expression sub exp =
       sub # class_structure cl
   | Texp_pack (mexpr) ->
       sub # module_expr mexpr
+  | Texp_bracket e -> sub # expression exp  (* NNN *)
+  | Texp_escape e  -> sub # expression exp  (* NNN *)
+  | Texp_cspval (v,li) -> ()                (* NNN *)
 
 
 let package_type sub pack =
diff --git a/tools/untypeast.ml b/tools/untypeast.ml
index 6cbbc55..29eaccf 100644
--- a/tools/untypeast.ml
+++ b/tools/untypeast.ml
@@ -289,6 +289,9 @@ and untype_expression exp =
         Pexp_object (untype_class_structure cl)
     | Texp_pack (mexpr) ->
         Pexp_pack (untype_module_expr mexpr)
+    | Texp_bracket e -> Pexp_bracket (untype_expression e) (* NNN *)
+    | Texp_escape e  -> Pexp_escape (untype_expression e)  (* NNN *)
+    | Texp_cspval (v,li) -> Pexp_cspval (v,li)             (* NNN *)
   in
   List.fold_right untype_extra exp.exp_extra
     { pexp_loc = exp.exp_loc;
diff --git a/typing/env.ml b/typing/env.ml
index 506975f..b23d416 100644
--- a/typing/env.ml
+++ b/typing/env.ml
@@ -98,6 +98,20 @@ end  = struct
 
 end
 
+(* NNN added a new component of the environment: stage.
+   It maps a term variable to the staging level, 0 for the present stage.
+   It ued to be a list of type_expr -- actually, the list
+   of type variables, that is, env classifiers.
+   We only care about stage level for term variables.
+   Every key in the 'stage' map (the Ident) must occur in
+   the 'values' map.
+*)
+(* NNN
+  The current stage, 0 for the present stage.
+  It used to be a list of active classifiers, whose length
+  was the stage level of a variable.
+*)
+type stage = int	(* NNN *)
 
 type summary =
     Env_empty
@@ -109,6 +123,7 @@ type summary =
   | Env_class of summary * Ident.t * class_declaration
   | Env_cltype of summary * Ident.t * class_type_declaration
   | Env_open of summary * Path.t
+  | Env_stage of summary * Ident.t * stage (* NNN *)
 
 module EnvTbl =
   struct
@@ -171,6 +186,7 @@ type t = {
   classes: (Path.t * class_declaration) EnvTbl.t;
   cltypes: (Path.t * class_type_declaration) EnvTbl.t;
   summary: summary;
+  stage: (Path.t * stage) EnvTbl.t;		(* NNN *)
   local_constraints: bool;
   gadt_instances: (int * TypeSet.t ref) list;
   in_signature: bool;
@@ -183,6 +199,9 @@ and module_components_repr =
     Structure_comps of structure_components
   | Functor_comps of functor_components
 
+(* NNN there are no stage levels here: modules must occur at the 0 level.
+   No modules in brackets.
+*)
 and structure_components = {
   mutable comp_values: (string, (value_description * int)) Tbl.t;
   mutable comp_constrs: (string, (constructor_description * int) list) Tbl.t;
@@ -214,6 +233,7 @@ let empty = {
   modules = EnvTbl.empty; modtypes = EnvTbl.empty;
   components = EnvTbl.empty; classes = EnvTbl.empty;
   cltypes = EnvTbl.empty;
+  stage = EnvTbl.empty;                 (* NNN *)
   summary = Env_empty; local_constraints = false; gadt_instances = [];
   in_signature = false;
  }
@@ -289,6 +309,7 @@ let check_consistency filename crcs =
       (fun (name, crc) -> Consistbl.check crc_units name crc filename)
       crcs
   with Consistbl.Inconsistency(name, source, auth) ->
+    Printf.eprintf "failed check_consistency %s %s %s\n" name source auth; (* NNNN *)
     raise(Error(Inconsistent_import(name, auth, source)))
 
 (* Reading persistent structures from .cmi files *)
@@ -425,6 +446,13 @@ and find_class =
   find (fun env -> env.classes) (fun sc -> sc.comp_classes)
 and find_cltype =
   find (fun env -> env.cltypes) (fun sc -> sc.comp_cltypes)
+(* NNN there is no comp_stage since all modules are at stage 0 *)
+let find_stage path env =			(* NNN entire function *)
+  match path with
+  | Pident id -> 
+      let (p, data) = EnvTbl.find_same id env.stage
+      in data
+  | _         -> raise Not_found
 
 let find_type p env =
   fst (find_type_full p env)
@@ -647,6 +675,9 @@ and lookup_class =
   lookup (fun env -> env.classes) (fun sc -> sc.comp_classes)
 and lookup_cltype =
   lookup (fun env -> env.cltypes) (fun sc -> sc.comp_cltypes)
+(* NNN there is no comp_stage since all modules are at stage 0 *)
+let lookup_stage =			(* NNN *)
+  lookup_simple (fun env -> env.stage) (fun sc -> raise Not_found) (* NNN *)
 
 let mark_value_used name vd =
   try Hashtbl.find value_declarations (name, vd.val_loc) ()
@@ -1255,6 +1286,11 @@ and store_cltype slot id path desc env renv =
     cltypes = EnvTbl.add "class type" slot id (path, desc) env.cltypes
                          renv.cltypes;
     summary = Env_cltype(env.summary, id, desc) }
+and store_stage slot id path st env renv =     (* NNN whole clause *)
+  { env with
+    stage = EnvTbl.add "stage" slot id (path, st) env.stage renv.stage;
+    summary = Env_stage(env.summary, id, st) } (* NNN end *)
+
 
 (* Compute the components of a functor application in a path. *)
 
@@ -1300,6 +1336,9 @@ and add_class id ty env =
 and add_cltype id ty env =
   store_cltype None id (Pident id) ty env env
 
+let add_stage id st env =		        (* NNN *)
+  store_stage None id (Pident id) st env env    (* NNN *)
+
 let add_local_constraint id info elv env =
   match info with
     {type_manifest = Some ty; type_newtype_level = Some (lv, _)} ->
diff --git a/typing/env.mli b/typing/env.mli
index 38d8cee..b070b79 100644
--- a/typing/env.mli
+++ b/typing/env.mli
@@ -14,6 +14,8 @@
 
 open Types
 
+type stage = int        (* NNN; in N100 was type_expr list *)
+
 type summary =
     Env_empty
   | Env_value of summary * Ident.t * value_description
@@ -24,6 +26,7 @@ type summary =
   | Env_class of summary * Ident.t * class_declaration
   | Env_cltype of summary * Ident.t * class_type_declaration
   | Env_open of summary * Path.t
+  | Env_stage of summary * Ident.t * stage (* NNN *)
 
 type t
 
@@ -51,6 +54,7 @@ val find_module: Path.t -> t -> module_type
 val find_modtype: Path.t -> t -> modtype_declaration
 val find_class: Path.t -> t -> class_declaration
 val find_cltype: Path.t -> t -> class_type_declaration
+val find_stage: Path.t -> t -> stage	(* NNN *)
 
 val find_type_expansion:
     ?level:int -> Path.t -> t -> type_expr list * type_expr * int option
@@ -80,6 +84,7 @@ val lookup_module: Longident.t -> t -> Path.t * module_type
 val lookup_modtype: Longident.t -> t -> Path.t * modtype_declaration
 val lookup_class: Longident.t -> t -> Path.t * class_declaration
 val lookup_cltype: Longident.t -> t -> Path.t * class_type_declaration
+val lookup_stage: Longident.t -> t -> Path.t * stage (* NNN *)
 
 exception Recmodule
   (* Raise by lookup_module when the identifier refers
@@ -97,6 +102,7 @@ val add_modtype: Ident.t -> modtype_declaration -> t -> t
 val add_class: Ident.t -> class_declaration -> t -> t
 val add_cltype: Ident.t -> class_type_declaration -> t -> t
 val add_local_constraint: Ident.t -> type_declaration -> int -> t -> t
+val add_stage: Ident.t -> stage -> t -> t (* NNN *)
 
 (* Insertion of all fields of a signature. *)
 
diff --git a/typing/envaux.ml b/typing/envaux.ml
index 5e8b524..aef8811 100644
--- a/typing/envaux.ml
+++ b/typing/envaux.ml
@@ -71,6 +71,8 @@ let rec env_from_summary sum subst =
               raise (Error (Module_not_found path'))
           in
           Env.open_signature Asttypes.Override path' (extract_sig env mty) env
+      | Env_stage(s, id, st) ->                           (* NNN *)
+          Env.add_stage id st (env_from_summary s subst)  (* NNN *)
     in
       Hashtbl.add env_cache (sum, subst) env;
       env
diff --git a/typing/predef.ml b/typing/predef.ml
index e4e96d2..fa7e97a 100644
--- a/typing/predef.ml
+++ b/typing/predef.ml
@@ -108,6 +108,18 @@ and ident_nil = ident_create "[]"
 and ident_cons = ident_create "::"
 and ident_none = ident_create "None"
 and ident_some = ident_create "Some"
+
+
+(* NNN ident_create "code" must be placed at the end of all other
+   ident creation expressions, to make sure that creating ident_code
+   does not shift the timestamps of other standard idents like 
+   Eof, etc. Otherwise, binary compatibility with OCaml breaks,
+   and we have to do expensive bootstrapping.
+*)
+let ident_code = ident_create "code"    (* NNN *)
+let path_code  = Pident ident_code      (* NNN *)
+let type_code t = newgenty (Tconstr(path_code, [t], ref Mnil)) (* NNN *)
+
 let build_initial_env add_type add_exception empty_env =
   let decl_bool =
     {decl_abstr with
@@ -152,6 +164,13 @@ let build_initial_env add_type add_exception empty_env =
      type_params = [tvar];
      type_arity = 1;
      type_variance = [Variance.covariant]}
+ (* NNN added decl_code *)
+  and decl_code =
+    let tvar = newgenvar() in
+    {decl_abstr with
+     type_params = [tvar];
+     type_arity = 1;
+     type_variance = [Variance.covariant]}
   in
 
   let add_exception id l =
@@ -171,6 +190,7 @@ let build_initial_env add_type add_exception empty_env =
                          [newgenty (Ttuple[type_string; type_int; type_int])] (
   add_exception ident_undefined_recursive_module
                          [newgenty (Ttuple[type_string; type_int; type_int])] (
+  add_type ident_code decl_code (       (* NNN *)
   add_type ident_int64 decl_abstr (
   add_type ident_int32 decl_abstr (
   add_type ident_nativeint decl_abstr (
@@ -186,7 +206,7 @@ let build_initial_env add_type add_exception empty_env =
   add_type ident_string decl_abstr (
   add_type ident_char decl_abstr (
   add_type ident_int decl_abstr (
-    empty_env)))))))))))))))))))))))))))
+    empty_env))))))))))))))))))))))))))) ) (* NNN extra parenthesis *)
 
 let builtin_values =
   List.map (fun id -> Ident.make_global id; (Ident.name id, id))
diff --git a/typing/predef.mli b/typing/predef.mli
index a2f4724..610e233 100644
--- a/typing/predef.mli
+++ b/typing/predef.mli
@@ -28,6 +28,7 @@ val type_nativeint: type_expr
 val type_int32: type_expr
 val type_int64: type_expr
 val type_lazy_t: type_expr -> type_expr
+val type_code:   type_expr -> type_expr (* NNN *)
 
 val path_int: Path.t
 val path_char: Path.t
@@ -44,6 +45,7 @@ val path_nativeint: Path.t
 val path_int32: Path.t
 val path_int64: Path.t
 val path_lazy_t: Path.t
+val path_code: Path.t  (* NNN *)
 
 val path_match_failure: Path.t
 val path_assert_failure : Path.t
diff --git a/typing/printtyped.ml b/typing/printtyped.ml
index 840a767..76b8615 100644
--- a/typing/printtyped.ml
+++ b/typing/printtyped.ml
@@ -353,6 +353,15 @@ and expression i ppf x =
   | Texp_pack me ->
       line i ppf "Pexp_pack";
       module_expr i ppf me
+        (* NNN: through the rest of the expression *)
+  | Texp_bracket e ->
+      line i ppf "Pexp_bracket";
+      expression i ppf e;
+  | Texp_escape e ->
+      line i ppf "Pexp_escape";
+      expression i ppf e;
+  | Texp_cspval (_, li) ->
+      line i ppf "Pexp_cspval %a\n" fmt_longident li
 
 and value_description i ppf x =
   line i ppf "value_description\n";
diff --git a/typing/trx.ml b/typing/trx.ml
new file mode 100644
index 0000000..6f94793
--- /dev/null
+++ b/typing/trx.ml
@@ -0,0 +1,2121 @@
+(*
+  This file is to post-process the Typedtree built by the type checker
+  before it is passed to the code generator -- to get rid of bracket and
+  escape. The main function is trx_structure, which initiates the
+  traversal and transforms every found expression with trx_exp. The
+  real transformation is done by trx_bracket.
+
+  For example,
+     <succ 1> 
+  gets transformed to 
+     mkApp <succ> <1> 
+  and eventually to
+     mkApp (mkIdent "succ") (mkConst 1)
+  One may say that we `push the brackets inside'.  We replace brackets
+  with calls to functions that will construct, at run-time, a
+  Parsetree, which is the representation of values of the code type.
+
+  Generally, the Parsetree is constructed when the program is run.
+  In some cases we can construct the Parsetree at compile time,
+  that is, when this trx.ml is run. Constants like <1> is such a case.
+  If we see <1>, or, in terms of trees,
+      Texp_bracket (Texp_constant (Constant_int 1))
+  we can immediately construct the Parsetree:
+      Pexp_constant (Constant_int 1)
+  After we construct the Parsetree at compile time, we use CSP to
+  pass it over to run-time. At run-time, we merely use the compiled constant.
+  This mechanism of building Parsetree at compile-time whenever possible
+  is one of the large differences from the previous versions of MetaOCaml.
+
+  Future-stage Bindings.
+  Future-stage bindings are introduced by patterns in let, fun,
+  match, try and for forms. Global bindings are always at present-stage.
+  Since local modules in brackets are not allowed, all future bindings are
+  unqualified (i.e., simple names, without the module path).
+  The principal rule of translating binding forms is
+     <fun x -> e> ---> let x = gensym "x" in mkLAM x <e>
+  Emphatically, gensym cannot be run at compile time!
+  Reason: consider the recursive invocation:
+     let rec f z = <fun y -> ~( ... f 1 ... )>
+
+  Thus, at run-time, we generate new names for bound variables and
+  use the OCaml's evaluator (the `run-time') to substitute these
+  new names in <e>. Therefore, a future-stage bound variable after
+  the translation becomes a present-stage bound variable,
+  but at a different type: string loc. We use string loc rather
+  than Longident.t loc since all, at present, future-stage bindings
+  are simple names.
+
+  We now check for scope extrusion: we enforce the region discipline
+  for generated identifiers. To make it easier to impose checks,
+  the translation rule is modified as follows
+     <fun x -> e> ---> build_simple_fun "x" (fun x -> <e>)
+  One can say that <fun x -> e> of the type (a->b) code is translated
+  into (fun x -> <e>) of the type a code -> b code. This looks quite
+  like the HOAS syntax for lambda (see the code-generation approach
+  with code combinators. The function build_simple_fun generates a gensym
+  and establishes a region for the gensym variable.
+
+  OCaml has more complicated functions, <function pattern -> body> with
+  complex patterns. If the patterns contain no binding variables,
+  there is no need to go into the gensym generation. The translation is
+  no more complex than that of <lazy e>. 
+  For more complicated binding patterns, we generalize, for example
+     <fun (x1,true,x2) as x3 -> e1 | _ -> e2> ---> 
+       build_fun ["x1";"x2"] (fun (x1,x2,x3) -> [<e1>;e2])
+  That is, we pick all binding variables from the pattern and build a
+  function that receives the code for these variables and produces the
+  array of code for all alternatives.
+
+  Here are the main patterns of scope extrusion
+  let r = <0> in 
+  <fun x -> ~(r := <x + 1>; <()>)>
+
+  let r = <0> in
+  <fun x -> .~(<fun x -> ~(let v = <x> in r := <fun x -> ~v>; <()>)>; !r)>
+
+  exception E of int code
+  try <fun x -> ~(raise (E <x>)> with E x -> x
+  (actually we need a local polymorphic exception, but the idea is the same)
+
+  and similar using control effects.
+
+  The most obvious method of detecting the scope extrusion is traversing
+  the generated code looking for unbound identifiers. We can do
+  such a check when we are about to show or run the code, or
+  about to splice (in the latter case, we have to maintain
+  the dynamic environment of gensym'ed names generated by 
+  build_fun_). However, reporting the scope
+  extrusion upon printing or running the code is reporting it too
+  late. Doing the check on each escape (since only splices can incorporate
+  scope-extruded code) means many repeated traversals of the generated
+  code.
+
+  We use a different method: we mark each piece of the generated code
+  with the list of free variable the code contains. Each variable
+  is associated with a `stackmark', which identifiers the region
+  with which the variable is associated. All valid stackmarks form
+  a total order. Alas, delimited control can reshuffle that order.
+  The function build_simple_fun and others enter a new region
+  and then check that the generated body contains only valid stackmarks
+  (that is, stackmarks that correspond to active regions). 
+  Every code building function ( build_* ) checks to see that the stackmarks
+  in the incorporated fragments are all valid, that is,
+  correspond currently alive variables. These code building function
+  merge the free variable lists (heaps actually) from the incorporated
+  fragments.
+
+This file was based on trx.ml from the original MetaOCaml, but it is
+completely re-written from scratch and has many comments. The
+traversal algorithm, the way of compiling Parsetree builders, dealing
+    with CSP and many other algorithms are all different.
+
+*)
+
+open Parsetree
+open Asttypes
+open Misc
+open Typedtree
+open Types
+
+
+(*{{{ Preliminaries, common functions *)
+
+(* BER MetaOCaml version string *)
+let meta_version  = "N 101"
+
+(* Co-opt Camlp4 class of warnings *)
+let debug_print : string -> unit = fun msg ->
+ ignore(Warnings.print Format.err_formatter 
+          (Warnings.Camlp4 msg))
+
+(* Emit a translation-time error *)
+let trx_error ?(loc = Location.none) fn =
+  raise (Typecore.Error (loc, Env.initial, Typecore.Trx_error fn))
+
+let not_supported loc msg =
+  trx_error ~loc:loc (fun ppf -> Format.fprintf ppf 
+      "%s is not yet supported within brackets" msg)
+
+(* left-to-right accumulating map *)
+let rec map_accum : ('accum -> 'a -> 'b * 'accum) -> 'accum -> 'a list ->
+  'b list * 'accum = fun f acc -> function
+    | []   -> ([],acc)
+    | h::t -> 
+        let (h,acc) = f acc h in
+        let (t,acc) = map_accum f acc t in
+        (h::t, acc)
+
+(*}}}*)
+
+
+(*{{{ Path and location utilities *)
+
+(* ------------------------------------------------------------------------ *)
+(* Path utilities *)
+
+(* We always use path when available, and convert it to Longident
+   when needed -- even if the Typedtree already carries the longident.
+   The path is preferred because it is fully qualified for
+   external identifiers and it is unambiguous.
+   If we open a module, its components can be referred to without
+   qualification -- the path will be qualified nevertheless.
+   When we build a Parsetree representing the generated code,
+   we have to use fully qualified identifiers since the open statement
+   in the original code won't be represented in the generated
+   Parsetree.
+*)
+
+(* Check to see if a path refers to an identifier, exception, or
+   constructor that is available from an external module. If so, the run-time
+   compiler invoked by run can get the definition for the identifier from
+   a .cmi file. The value of an external identifier can be obtained from
+   a .cmo file.
+*)
+let is_external = function
+  | Path.Pident id ->           (* not qualified *)
+      Ident.persistent id || Ident.global id || Ident.is_predef_exn id
+  | Path.Papply _  -> false
+  | Path.Pdot(Path.Pident id, _,_) -> Ident.persistent id
+  | _             -> false
+
+(* Convert a path to an identifier. Since the path is assumed to be
+   `global', time stamps don't matter and we can use just strings.
+*)
+let rec path_to_lid : Path.t -> Longident.t = function
+  | Path.Pident i       -> Longident.Lident (Ident.name i)
+  | Path.Pdot (p,s,_)   -> Longident.Ldot (path_to_lid p, s)
+  | Path.Papply (p1,p2) ->
+      Longident.Lapply(path_to_lid p1, path_to_lid p2)
+
+(* Convert the path to lid but use the given str as the last component.
+   This in effect qualifies 'str' with the given module path
+*)
+let path_to_lid_but_last : Path.t -> string -> Longident.t =
+  fun p str ->
+    match p with
+    | Path.Pident _ -> Longident.Lident str
+    | Path.Pdot (p,_,pos) -> path_to_lid (Path.Pdot (p,str,pos))
+    | _ -> assert false
+
+(* Replace the last component of p1 with p2, which should be a Pident
+   path 
+*)
+let path_replace_last : Path.t -> Path.t -> Path.t = fun p1 p2 ->
+ match (p1,p2) with
+  | (Path.Pident _,x) -> x
+  | (Path.Pdot(p1,_,s),Path.Pident id) -> Path.Pdot(p1,Ident.name id,s)
+  | _ -> assert false
+
+
+(* Check to make sure a constructor, label, exception, etc.
+   have the name that we can put into AST (Parsetree).
+   Local names can't be put into the Parsetree since the type env in which
+   they are declared is not represented in the Parsetree.
+*)
+let check_path_quotable msg path =
+  if not (is_external path) then
+    trx_error (fun ppf ->
+      Format.fprintf ppf 
+        "%s %s cannot be used within brackets. Put into a separate file."
+        msg (Path.name path))
+
+(* Check to see that a constructor belongs to a type defined
+   in a persistent module or in the initial environment.
+   Return the fully qualified name to put into AST 
+   (Pervasive constructors remain unqualified however).
+
+   We have nothing to do if the constructor is already fully qualified
+   with a persistent module identifier: for example, Scanf.Scan_failure.
+   The major complexity comes from this scenario:
+      open Scanf
+      .<raise (Scan_failure "xx")>.
+   The Texp_construct node of Typedtree contains the lid and (was: the
+   path) that refer to "Scan_failure" without any module qualifications.
+   We have to find the fully qualified path and check
+   that it is external. We do that by finding the path for the _type_
+   constructor, for the type of which the data constructor is a member.
+   That type_path is fully qualified. We can ascertain the later fact
+   from Env.constructors_of_type, which puts the complete path
+   into the type of the constructor, which is always of the form
+   Tconstr(ty_path,_,_). The function constructors_of_type is used
+   within Env.store_type, which is used when opening a module.
+
+   Alternatively we could've used Env.lookup_constuctor, which also
+   returns the qualified path? Searching the environment is costly
+   though.
+   Actually, using Env.lookup_constuctor is a bad idea. Now labels and
+   constructors don;t have to be unique. The type checker goes to
+   a great length to disambiguate a constructor or a label. It records
+   the eventually determined type of the label/constructor in
+   label_description or constructor_description.
+   So, we should only use information from these descriptions.
+
+   Alas, the predefined types (with no module qualification) are
+   not specially distinguished. So, we have to check the initial
+   environment.
+ *)
+let qualify_ctor : 
+    Longident.t loc -> constructor_description -> Longident.t loc = 
+ fun lid cdesc ->
+  let loc = lid.loc in
+  match (cdesc.cstr_tag, Ctype.repr cdesc.cstr_res) with
+  | (Cstr_exception (p,_),_) ->
+      if is_external p then Location.mkloc (path_to_lid p) loc else
+       trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
+       "Exception %s cannot be used within brackets. Put into a separate file."
+        (Path.name p))
+  | (_,{desc = Tconstr((Path.Pident _ as ty_path), _, _)}) ->
+     begin
+      try ignore (Env.find_type ty_path Env.initial); lid
+      with Not_found ->
+        trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
+        "Unqualified constructor %s cannot be used within brackets. Put into a separate file."
+          cdesc.cstr_name)
+     end
+  | (_,{desc = Tconstr(ty_path, _, _)}) ->
+      if is_external ty_path then
+        Location.mkloc (path_to_lid_but_last ty_path cdesc.cstr_name) loc
+      else
+      trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
+      "Constructor %s cannot be used within brackets. Put into a separate file."
+          cdesc.cstr_name)
+  | _ -> Printtyp.type_expr Format.err_formatter cdesc.cstr_res;
+           failwith ("qualify_ctor: cannot determine type_ctor from data_ctor "^
+                     cdesc.cstr_name)
+
+(* Check to see that a record label belongs to a record defined
+   in a persistent module or in the initial environment.
+   This is a label version of qualify_ctor
+*)
+let qualify_label : Longident.t loc -> label_description -> Longident.t loc =
+ fun lid ldesc ->
+  let loc = lid.loc in
+  match Ctype.repr ldesc.lbl_res with
+  | {desc = Tconstr((Path.Pident _ as ty_path), _, _)} ->
+    begin
+      try ignore (Env.find_type ty_path Env.initial); lid
+      with Not_found ->
+        trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
+        "Unqualified label %s cannot be used within brackets. Put into a separate file."
+          ldesc.lbl_name)
+    end
+  | {desc = Tconstr(ty_path, _, _)} ->
+      if is_external ty_path then
+        Location.mkloc 
+          (path_to_lid_but_last ty_path ldesc.lbl_name) loc
+      else
+        trx_error ~loc:loc (fun ppf -> Format.fprintf ppf
+          "Label %s cannot be used within brackets. Put into a separate file."
+          ldesc.lbl_name)
+  | _ -> Printtyp.type_expr Format.err_formatter ldesc.lbl_res;
+           failwith ("qualify_label: cannot determine type from label "^
+                     ldesc.lbl_name)
+
+(* Test if we should refer to a CSP value by name rather than by
+   value
+*)
+(* Module identifiers for the modules that are expected to be
+   present at run-time -- that is, will be available for
+   dynamic linking of the run-time generated code.
+
+TODO: check bytecomp/transclass.ml:const_path
+Perhaps that's a hint which unqualified identifiers will be persistent
+*)
+
+let ident_can_be_quoted = is_external
+
+(*}}}*)
+
+
+(*{{{ Templates for building Parsetree/Typedtree components *)
+
+let dummy_lid : string -> Longident.t loc = fun name ->
+  Location.mknoloc (Longident.Lident name)
+
+(* Exported. Used as a template for constructing lid expressions *)
+let sample_lid = dummy_lid "*sample*"
+
+(* Exported. Used as a template for constructing name expression *)
+let sample_name : string loc = mknoloc "*sample*"
+
+(* Exported. Used as a template for constructing Location.t expressions *)
+let sample_loc = Location.none
+
+(* Exported. Used as a template for constructing pattern lists expressions *)
+let sample_pat_list : Parsetree.pattern list = []
+let sample_pats_names : Parsetree.pattern list * string loc list = ([],[])
+
+(* Exported. Used as a template for passing the Asttypes.rec_flag *)
+let sample_rec_flag : Asttypes.rec_flag = Nonrecursive
+
+(* Exported. Used as a template for passing the Asttypes.override_flag *)
+let sample_override_flag : Asttypes.override_flag = Fresh
+
+(*}}}*)
+
+(* ------------------------------------------------------------------------ *)
+(* Building Texp nodes *)
+(* Env.initial is used for all look-ups. Unqualified identifiers
+   must be found there. For qualified identifiers, Env.lookup
+   functions look things up in the persistent structures, loading them
+   up as needed.
+*)
+
+let mk_texp : ?env:Env.t -> Typedtree.expression_desc -> type_expr -> 
+  Typedtree.expression =
+  fun ?(env=Env.initial) desc ty ->
+  { exp_desc = desc; exp_type = ty;
+    exp_loc  = Location.none; exp_extra = [];
+    exp_env  = env }
+
+(* TODO: add memoization? *)
+
+(* Compiling an identifier with a given (qualified) name *)
+let texp_ident : string -> expression = fun name ->
+  let lid     = Longident.parse name in
+  let (p, vd) = try Env.lookup_value lid Env.initial 
+                with Not_found -> fatal_error ("Trx.find_value: " ^ name) in
+  mk_texp (Texp_ident (p,mknoloc lid, vd))
+          (Ctype.instance Env.initial vd.val_type)
+
+
+(* Building an application *)
+let texp_apply : Typedtree.expression -> Typedtree.expression list -> 
+ Typedtree.expression_desc = fun f args ->
+   Texp_apply(f, List.map (fun arg -> ("",Some arg, Required)) args)
+
+(* Compiling location data *)
+let texp_loc : Location.t -> Typedtree.expression = fun loc ->
+  let loc_exp = texp_ident "Trx.sample_loc" in (* this fills in the type, etc.*)
+  {loc_exp with exp_desc = Texp_cspval (Obj.repr loc, dummy_lid "*loc*")}
+
+(* Compiling longident with location data *)
+let texp_lid : Longident.t loc -> Typedtree.expression = fun lid ->
+  let lid_exp = texp_ident "Trx.sample_lid" in (* this fills in the type, etc.*)
+  {lid_exp with exp_desc = Texp_cspval (Obj.repr lid, dummy_lid "*lid*")}
+
+(* Compiling a string constant *)
+let texp_string : string -> Typedtree.expression = fun str ->
+  mk_texp (Texp_constant (Const_string str))
+          (Ctype.instance_def Predef.type_string)
+
+(* Compiling a string with a location *)
+let texp_string_loc : string loc -> Typedtree.expression = fun name ->
+  let name_exp = texp_ident "Trx.sample_name" in
+  {name_exp with
+   exp_desc = Texp_cspval (Obj.repr name, dummy_lid "*name*")} 
+
+(* Compiling a boolean *)
+(* For prototype, see Typecore.option_none *)
+let texp_bool : bool -> Typedtree.expression = fun b ->
+  let lid = Longident.Lident (if b then "true" else "false") in
+  let cdec = Env.lookup_constructor lid Env.initial in
+  mk_texp (Texp_construct(mknoloc lid, cdec, [], false))
+          (Ctype.instance_def Predef.type_bool)
+
+(* Compiling an option *)
+(* For prototype, see Typecore.option_none *)
+let texp_option : Typedtree.expression option -> Typedtree.expression = 
+  function
+    | None -> 
+        let lid = Longident.Lident "None" in
+        let cnone = Env.lookup_constructor lid Env.initial in
+        mk_texp (Texp_construct(mknoloc lid, cnone, [], false))
+                (Ctype.instance_def (Predef.type_option (Btype.newgenvar ())))
+    | Some e ->
+        let lid = Longident.Lident "Some" in
+        let csome = Env.lookup_constructor lid Env.initial in
+        mk_texp (Texp_construct(mknoloc lid, csome, [e],false))
+                (Ctype.instance_def (Predef.type_option e.exp_type)) 
+                ~env:e.exp_env
+
+(* Compiling a tuple *)
+let texp_tuple : Typedtree.expression list -> Typedtree.expression = fun el ->
+  mk_texp (Texp_tuple el)
+          (Ctype.newty (Ttuple (List.map (fun e -> e.exp_type) el)))
+
+(* Compiling an array *)
+(* We use this function for grouping trx_bracket-transformed expressions,
+   which have the same representation type (but may be different
+   code type). We ignore the differences in the code type, since
+   the representation type is the same.
+
+   We don't use lists since they are harder to compile, and more
+   fragile. Texp_construct has more arguments, we have to locate
+   constructor information, etc.
+*)
+let texp_array : Typedtree.expression list -> Typedtree.expression = function
+  | [] -> 
+      mk_texp (Texp_array []) 
+	      (Ctype.instance_def (Predef.type_array (Btype.newgenvar ())))
+  | (h::_) as el ->
+      mk_texp (Texp_array el) 
+	      (Ctype.instance_def (Predef.type_array h.exp_type))
+
+(* Compiling patterns and the list of names bound by them *)
+let texp_pats_names : Parsetree.pattern list -> string loc list -> 
+  Typedtree.expression = fun pats names ->
+    let pn_exp = texp_ident "Trx.sample_pats_names" in
+    {pn_exp with
+     exp_desc = Texp_cspval (Obj.repr (pats,names), dummy_lid "*pn*")}
+
+(* ------------------------------------------------------------------------ *)
+(* Stack marks, a simple form of dynamic binding *)
+
+(* In the earlier version, our stackmarks could be ordered.
+   Alas, it is hard to dynamically replace the implementation
+   below with the one adjusted for delimcc. The implementation below
+   does not work when partial continuations can be captured and reinstated.
+   Mainly, when delimited continuations are used, the order is
+   not stable. Delimited control operators can reshuffle the order
+   arbitrarily. Therefore, the fact that there is order among valid stackmarks
+   is not helpful anyway.
+
+module type STACKMARK = sig
+  type t
+  val is_valid : t -> bool
+  (* compare is supposed to be called on stack marks that are
+     checked to be valid
+   *)
+  val compare : t -> t -> int
+  val with_stack_mark : (t -> 'w) -> 'w
+end
+
+(* Simple implementation with shallow dynamic binding *)
+module StackMark : STACKMARK = struct
+  type t = int ref
+
+  (* The global counter of the nesting depth of with_stack_mark *)
+  let stack_mark_cnt = ref 0
+
+  (* A stack mark is ref n where n is the depth of the corresponding
+     with_stack_mark form.
+     The stack mark is invalid if the counter is 0
+   *)
+  let with_stack_mark body =
+    incr stack_mark_cnt;
+    let mark = ref !stack_mark_cnt in
+    let finalize () =
+      mark := 0;                         (* invalidate the mark *)
+      assert (!stack_mark_cnt > 0);
+      decr stack_mark_cnt
+    in
+    try 
+      let r = body mark in finalize (); r
+    with e -> finalize (); raise e
+
+  let is_valid mark = !mark > 0
+  let compare m1 m2 =
+    assert (!m1 >0 && !m2 > 0);
+    compare !m1 !m2
+end
+
+*)
+
+(* A robust and truly minimalistic implementation of stack-marks.
+   A stack-mark is created by 'with_stack_mark' function. Since
+   the only operation on a stackmark is to test if it is valid,
+   the stackmark is realized as a thunk unit -> bool.
+*)
+type stackmark = unit -> bool           (* true if valid *)
+
+(* The type of the with_stack_mark operation *)
+type stackmark_region_fn = 
+    {stackmark_region_fn : 'w. (stackmark -> 'w) -> 'w}
+
+(* The simple implementation of stackmark_region_fn, appropriate
+   when no delimited control is used.
+   The mark is a ref bool cell, containing true within
+   stackmark_region_fn's dynamic region.
+*)
+let with_stack_mark_simple : stackmark_region_fn = 
+  {stackmark_region_fn = fun body ->
+    let mark = ref true in
+    try
+      let r = body (fun () -> !mark) in
+      mark := false;                      (* invalidate the mark *)
+      r
+    with e -> mark := false; raise e
+ }
+
+let with_stack_mark : stackmark_region_fn ref = ref with_stack_mark_simple
+
+(* Replace a with_stack_mark implementation, e.g., when delimcc is used *)
+let set_with_stack_mark : stackmark_region_fn -> unit =
+  fun smf -> with_stack_mark := smf
+
+    
+(* ------------------------------------------------------------------------ *)
+(* Simple heap *)
+(* A mapping of keys to values. Priority is used for the sake of
+   efficient operations. Also, values with the same priority are
+   considered equivalent (belong to the same binding region)
+   and are collapsed, lazily. 
+
+   The invariant: for each non-leaf
+   node, the priority of the node is strictly greater than the priorities 
+   of any of the child nodes. The order of priorities between 
+   the children can be arbitrary.
+*)
+type prio = int
+type 'v heap = Nil | HNode of prio * stackmark * 'v * 'v heap * 'v heap
+let empty = Nil
+
+let rec merge : 'v heap -> 'v heap -> 'v heap = fun h1 h2 ->
+  match (h1,h2) with
+  | (Nil,h) | (h,Nil)-> h
+  | (HNode (p1,k1,v1,l1,r1), HNode (p2,k2,v2,l2,r2)) ->
+      begin
+        match p1 - p2 with
+        | 0 -> HNode (p1,k1,v1, merge l1 l2, merge r1 r2) (* same keys *)
+        | n when n < 0 -> HNode (p2,k2,v2, merge h1 l2, r2)
+        | _ -> HNode (p1,k1,v1,l1,merge h2 r1)
+      end
+
+(* Remove the node with a given priority *)
+let rec remove : prio -> 'v heap -> 'v heap = fun p -> function
+  | Nil -> Nil
+  | HNode (pn,k,v,h1,h2) as h -> 
+      begin
+        match p - pn with
+        | 0 -> merge h1 h2              (* p cannot occur in h1 or h2 *)
+        | n when n > 0 -> h             (* entire tree has the lower prio *)
+        | _ -> HNode (pn,k,v, remove p h1, remove p h2)
+      end
+
+(* The representation of the possibly open code: AST plus the
+   set of free identifiers, annotated with the marks
+   of the corresponding with_binding_region forms
+*)
+type code_repr = Code of string loc heap * Parsetree.expression
+
+(* The closed code is AST *)
+type closed_code_repr = Parsetree.expression
+
+(* Check that the code is closed and return the closed code *)
+
+(* The same as close_code but return the closedness check as a thunk
+   rather than performing it.
+   This is useful for debugging and for showing the code
+*)
+let close_code_delay_check : code_repr -> closed_code_repr * (unit -> unit) =
+ function
+  | Code (Nil,ast) -> (ast,fun () -> ())
+  | Code (HNode (_,_,var,_,_),ast) ->
+    (ast, fun () ->
+      Format.fprintf Format.str_formatter
+      "The code built at %a is not closed: identifier %s bound at %a is free"
+      Location.print ast.pexp_loc var.txt Location.print var.loc;
+      failwith (Format.flush_str_formatter ()))
+
+let close_code_repr : code_repr -> closed_code_repr = fun cde ->
+  let (ast, check) = close_code_delay_check cde in
+  check (); ast
+
+let open_code : closed_code_repr -> code_repr = fun ast ->
+  Code (Nil,ast)
+
+(* Compiling a closed code value: a structural constant of
+   type code_repr
+   This constant is transported via CSP (although we could have
+   built a Typedtree node for that purpose.
+ *)
+let texp_code : ?node_id:string ->
+  Location.t -> Parsetree.expression_desc -> Typedtree.expression_desc =
+  fun ?(node_id="") loc desc ->
+  let ast = {pexp_loc = loc; pexp_desc = desc}
+  in Texp_cspval (Obj.repr (open_code ast), dummy_lid node_id)
+
+
+
+(* ------------------------------------------------------------------------ *)
+(* Bindings in the future stage *)
+(* Recall, all bindings at the future stage are introduced by
+   patterns, and hence are simple names, without any module qualifications.
+*)
+let gensym_count = ref 0
+
+(* Generate a fresh name with a given base name *)
+let gensym : string -> string = fun s ->
+  incr gensym_count;
+  s ^ "_" ^ string_of_int !gensym_count
+
+let reset_gensym_counter () = gensym_count := 0
+
+(* Make a simple identifier unique *)
+let genident : string loc -> string loc = fun name ->
+  {name with txt = gensym name.txt}
+
+(* This is a run-time error, rather than a translation-time error *)
+let scope_extrusion_error : 
+  detected:Location.t -> occurred:Location.t -> string loc -> 'a = 
+  fun ~detected ~occurred var ->
+  Format.fprintf Format.str_formatter
+    "Scope extrusion detected at %a for code built at %a for the identifier %s bound at %a"
+    Location.print detected Location.print occurred
+    var.txt Location.print var.loc;
+  failwith (Format.flush_str_formatter ())
+
+(* Check to make sure that free variables in the potentially open
+   code fragment are valid.
+   If it weren't for delimited control, the order of stack marks is
+   stable; therefore, if the maximal mark is valid then all
+   smaller marks are valid as well.
+   Delimited control spoils all that. 
+   When we capture some of the inner-bidings
+   in a continuation and then reinstall that continuation at the
+   top level, the `latest' free variable is valid but earlier are
+   no longer valid:
+
+  let r = ref ... in
+  .<fun x1 x2 -> .~(reset .<fun y1 y2 -> 
+                              .~(shift k (r := k; k .<0>.))>.)>.
+  .r .<2>.
+  Here, y1 and y2 are valid but x1 and x2 are not.
+*)
+let validate_vars : Location.t -> code_repr -> code_repr = 
+  fun l -> function
+  | Code (Nil,_) as cde -> cde
+  | Code (h, ast) as cde -> begin
+      let rec check = function
+        | Nil -> ()
+        | HNode (_,sm,var,h1,h2) ->
+            if sm () then (check h1; check h2)
+            else scope_extrusion_error ~detected:l ~occurred:ast.pexp_loc var 
+      in check h; cde
+  end
+
+let validate_vars_option : Location.t -> code_repr option -> 
+  Parsetree.expression option * string loc heap = 
+  fun l -> function
+  | None -> (None,Nil)
+  | Some e -> let Code (vars, e) = validate_vars l e in (Some e, vars)
+
+let validate_vars_list : Location.t -> code_repr list -> 
+  Parsetree.expression list * string loc heap = fun l cs ->
+  map_accum (fun acc c -> 
+      let Code (vars,e) = validate_vars l c in
+      (e, merge vars acc))
+    Nil cs
+
+(* Generate a fresh name off the given name, enter a new binding region
+   and evaluate a function passing it the generated name as code_repr.
+   Remove the generated name from the annotation on the resulting code_expr.
+   Return that result and the generated name.
+   This function embodies the translation of simple functions, for-loops,
+   simple let-expressions, etc.
+*)
+      (* Counter for assiging priorities to vars heap nodes. *)
+      (* Keep in mind the invariant that variables of the same priority
+         comes from the same binding location. So, we must keep the
+         priorities unique to binders. Giving binders monotonically
+         increasing priorities is helpful: the innermost binding
+         has the highest priority and it will be at the top of the heap,
+         the easiest to remove.
+       *)
+let prio_counter = ref 0
+
+let with_binding_region : 
+  Location.t -> string loc -> (code_repr -> code_repr) -> 
+  string loc * string loc heap * Parsetree.expression = fun l name f -> 
+  let new_name = genident name in
+  let (vars,e) = 
+   !with_stack_mark.stackmark_region_fn (fun mark ->
+     incr prio_counter;
+     let prio = !prio_counter in
+     let var_code = (* code that corresponds to the bound variable *)
+       Code (HNode (prio,mark,new_name,Nil,Nil),
+          {pexp_loc  = name.loc;        (* the loc of the binder *)
+           pexp_desc = 
+            Pexp_ident (mkloc (Longident.Lident new_name.txt) new_name.loc)}) in
+     let Code (vars,e) = validate_vars l (f var_code) in
+     (remove prio vars, e)) in
+  (new_name, vars, e)
+
+(* The most general version with several bindings and several expressions 
+   that use the bindings
+ *)
+let with_binding_region_gen : 
+  Location.t -> string loc list -> (code_repr array -> code_repr array) -> 
+  string loc list * string loc heap * Parsetree.expression list
+  = fun l names f -> 
+  let new_names = List.map genident names in
+  let (vars,es) = 
+   !with_stack_mark.stackmark_region_fn (fun mark ->
+     incr prio_counter;
+     let prio = !prio_counter in
+     let vars_code = Array.of_list (List.map (fun new_name ->
+                      (* code that corresponds to a bound variable *)
+       Code (HNode (prio,mark,new_name,Nil,Nil),
+          {pexp_loc  = new_name.loc;        (* the loc of the binder *)
+           pexp_desc = 
+            Pexp_ident (mkloc (Longident.Lident new_name.txt) new_name.loc)}))
+       new_names) in
+     let cs = Array.to_list (f vars_code) in
+     let (es,vars) = map_accum (fun vars c -> 
+                      let Code (var,e) = validate_vars l c in 
+                      (e,merge var vars)) Nil cs in
+     (remove prio vars, es)) in
+  (new_names, vars, es)
+
+
+(* ------------------------------------------------------------------------ *)
+(* Building Parsetree nodes *)
+
+(* Handle timestamp for builders of the type 
+      Parsetree.expression -> Parsetree.expression
+*)
+let code_wrapper : 
+    (Location.t -> Parsetree.expression -> Parsetree.expression) ->
+    (Location.t -> code_repr -> code_repr) =
+fun f l e ->
+  let Code (vars,e) = validate_vars l e in
+  Code (vars, f l e)
+
+(* building a typical Parsetree node: Pexp_assert of expression*)
+let build_assert : Location.t -> code_repr -> code_repr = 
+  code_wrapper
+  (fun l e -> {pexp_loc = l; pexp_desc = Pexp_assert e})
+
+(* When we translate the typed-tree, we have to manually compile
+   the above code 
+First, to see the AST for the phrase, invoke the top-level with the flag
+-dparsetree. Then
+   {pexp_loc  = l; pexp_desc = Pexp_assert e}
+
+gives the parsetree:
+let build_assert_ast : Location.t -> Parsetree.expression -> Parsetree.expression = 
+{pexp_loc = l1;
+ pexp_desc = 
+  Pexp_record
+        ([(Location.mknoloc (Longident.parse "Parsetree.pexp_loc"), 
+           Pexp_ident "l");
+         (Location.mknoloc (Longident.parse "Parsetree.pexp_desc"),
+           {pexp_loc  = Location.none;
+            pexp_desc = Pexp_construct 
+                          ((Location.mknoloc (Longident.parse 
+                                                "Parsetree.Pexp_assert")),
+              Some {pexp_loc = Location.none;
+                    pexp_desc = Pexp_ident "e"},
+              false)})
+        ],
+        None)}
+type_expression
+
+If building the parsetree on our own, beware! For example, labels in
+Texp_record must be sorted, in their declared order!
+*)
+
+
+(* Other similar builders *)
+let build_lazy : Location.t -> code_repr -> code_repr = 
+  code_wrapper
+    (fun l e -> {pexp_loc = l; pexp_desc = Pexp_lazy e})
+let build_bracket : Location.t -> code_repr -> code_repr= 
+  code_wrapper
+    (fun l e -> {pexp_loc = l; pexp_desc = Pexp_bracket e})
+let build_escape : Location.t -> code_repr -> code_repr = 
+  code_wrapper
+    (fun l e -> {pexp_loc = l; pexp_desc = Pexp_escape e})
+
+let build_sequence : Location.t -> code_repr -> code_repr -> code_repr = 
+  fun l e1 e2 -> 
+    let Code (vars1,e1) = validate_vars l e1 in
+    let Code (vars2,e2) = validate_vars l e2 in
+    Code (merge vars1 vars2,
+          {pexp_loc = l; pexp_desc = Pexp_sequence (e1,e2) })
+let build_while : Location.t -> code_repr -> code_repr -> code_repr = 
+  fun l e1 e2 -> 
+    let Code (vars1,e1) = validate_vars l e1 in
+    let Code (vars2,e2) = validate_vars l e2 in
+    Code (merge vars1 vars2,
+          {pexp_loc = l; pexp_desc = Pexp_while (e1,e2) })
+let build_when : Location.t -> code_repr -> code_repr -> code_repr = 
+  fun l e1 e2 -> 
+    let Code (vars1,e1) = validate_vars l e1 in
+    let Code (vars2,e2) = validate_vars l e2 in
+    Code (merge vars1 vars2,
+          {pexp_loc = l; pexp_desc = Pexp_when (e1,e2) })
+
+(* Build the application. The first element in the array is the
+   function. The others are arguments. *)
+let build_apply : Location.t -> (label * code_repr) array -> code_repr = 
+  fun l ea -> 
+    assert (Array.length ea > 1);
+    match map_accum (fun vars (lbl,e) -> 
+                   let Code (var,e) = validate_vars l e in
+                   ((lbl,e),merge var vars))
+          Nil (Array.to_list ea) with
+    | (("",eh)::elt,vars) ->
+       Code (vars, 
+              {pexp_loc  = l; 
+               pexp_desc = Pexp_apply (eh, elt)})
+    | _ -> assert false
+
+
+let build_tuple : Location.t -> code_repr array -> code_repr =
+ fun l ea -> 
+  let (els,vars) = validate_vars_list l (Array.to_list ea) in
+  Code (vars, 
+    {pexp_loc = l; pexp_desc = Pexp_tuple els })
+
+let build_array : Location.t -> code_repr array -> code_repr =
+ fun l ea -> 
+  let (els,vars) = validate_vars_list l (Array.to_list ea) in
+  Code (vars, 
+    {pexp_loc = l; pexp_desc = Pexp_array els })
+
+let build_ifthenelse : 
+ Location.t -> code_repr -> code_repr -> code_repr option -> code_repr =
+ fun l e1 e2 eo -> 
+    let Code (vars1,e1) = validate_vars l e1 in
+    let Code (vars2,e2) = validate_vars l e2 in
+    let (eo,varso)      = validate_vars_option l eo in
+    Code (merge vars1 (merge vars2 varso),
+      {pexp_loc = l; pexp_desc = Pexp_ifthenelse (e1,e2,eo) })
+
+let build_construct :
+ Location.t -> Longident.t loc -> code_repr array -> bool -> code_repr =
+ fun loc lid args explicit_arity ->
+  let (args,vars) = validate_vars_list loc (Array.to_list args) in
+  Code (vars, 
+  {pexp_loc  = loc;
+   pexp_desc = Pexp_construct (lid,
+     begin
+      match args with
+      | []  -> None
+      | [x] -> Some x
+      | xl  -> Some { pexp_loc  = loc; pexp_desc = Pexp_tuple xl }
+     end,
+     explicit_arity) })
+
+let build_record : Location.t -> (Longident.t loc * code_repr) array ->
+ code_repr option -> code_repr =
+ fun loc lel eo ->
+   let (lel,vars) = map_accum (fun vars (lbl,e) -> 
+                       let Code (var,e) = validate_vars loc e in
+                       ((lbl,e),merge var vars))
+        Nil (Array.to_list lel) in
+   let (eo,varo) = validate_vars_option loc eo in
+   Code (merge vars varo, 
+   {pexp_loc  = loc; pexp_desc = Pexp_record (lel,eo)})
+
+let build_field : Location.t -> code_repr -> Longident.t loc -> code_repr =
+ fun loc e lid ->
+  let Code (vars,e) = validate_vars loc e in
+  Code (vars, 
+     {pexp_loc  = loc;
+      pexp_desc = Pexp_field (e,lid)})
+
+let build_setfield :
+ Location.t -> code_repr -> Longident.t loc -> code_repr -> code_repr =
+ fun loc e1 lid e2 ->
+  let Code (vars1,e1) = validate_vars loc e1 in
+  let Code (vars2,e2) = validate_vars loc e2 in
+  Code (merge vars1 vars2,
+     {pexp_loc  = loc;
+      pexp_desc = Pexp_setfield (e1,lid,e2)})
+
+let build_variant : Location.t -> string -> code_repr option -> code_repr =
+ fun loc l eo ->
+  let (eo,vars) = validate_vars_option loc eo in
+  Code (vars, 
+     {pexp_loc  = loc;
+      pexp_desc = Pexp_variant (l,eo)})
+
+let build_send : Location.t -> code_repr -> string -> code_repr =
+ fun loc e l ->
+  let Code (vars,e) = validate_vars loc e in
+  Code (vars, 
+    {pexp_loc  = loc;
+     pexp_desc = Pexp_send (e,l)})
+
+let build_open :
+ Location.t -> Longident.t loc -> override_flag -> code_repr -> code_repr =
+ fun loc l ovf e ->
+  let Code (vars,e) = validate_vars loc e in
+  Code (vars, 
+     {pexp_loc  = loc;
+      pexp_desc = Pexp_open (ovf,l,e)})
+
+(* Build a function with a non-binding pattern, such as fun () -> ... *)
+let build_fun_nonbinding : 
+  Location.t -> string -> Parsetree.pattern list -> 
+  code_repr array -> code_repr =
+  fun l label pats bodies -> 
+  let (ebodies,vars) = validate_vars_list l (Array.to_list bodies) in
+  Code (vars,
+    {pexp_loc = l; 
+     pexp_desc = Pexp_function (label,None,
+                                List.map2 (fun p e -> (p,e)) pats ebodies)})
+
+
+(* Build a Parsetree for a future-stage identifier
+   It is always in scope of with_binding_region:
+   Bound variables are always in scope of their binders;
+   A well-typed code has no unbound variables.
+let build_ident : Location.t -> string loc -> code_repr =
+ fun loc l ->
+  not_supported loc "vars not supported"
+  Code (add_timestamp (Some l)
+   {pexp_loc  = loc;
+    pexp_desc = Pexp_ident (mkloc (Longident.Lident l.txt) l.loc)}
+*)
+
+(* Build a simple one-arg function, as described in the the title comments *)
+(* 'name' is the name of the variable from Ppat_var of the fun x -> ...
+   form. It is the real name with the location within the function pattern.
+   Use name.loc to identify the binder in the source code.
+*)
+let build_fun_simple : 
+  Location.t -> string -> string loc -> (code_repr -> code_repr) -> code_repr =
+  fun l label old_name fbody -> 
+  let (name, vars, ebody) = with_binding_region l old_name fbody in
+  let pat = {ppat_loc  = name.loc; ppat_desc = Ppat_var name} in
+  Code (vars,
+    {pexp_loc = l; 
+     pexp_desc = Pexp_function (label,None,[(pat,ebody)])})
+
+let build_for : 
+  Location.t -> string loc -> code_repr -> code_repr -> 
+  bool -> (code_repr -> code_repr) -> code_repr =
+  fun l old_name elo ehi dir fbody -> 
+  let (name, varsb, ebody) = with_binding_region l old_name fbody in
+  let Code (varso,elo) = validate_vars l elo in
+  let Code (varsh,ehi) = validate_vars l ehi in
+  Code (merge varsb (merge varso varsh),
+  {pexp_loc = l; 
+   pexp_desc = Pexp_for (name,elo,ehi,(if dir then Upto else Downto), ebody) })
+
+(* deflt_flag = True, the let was Default (auto-geneterated by the type
+   checker for the default function argument)
+*)
+let build_let_simple_nonrec : 
+  Location.t -> string loc -> bool -> code_repr -> (code_repr -> code_repr) -> 
+    code_repr = fun l old_name deflt_flag e fbody -> 
+  let (name, varsb, ebody) = with_binding_region l old_name fbody in
+  let pat = {ppat_loc  = name.loc; ppat_desc = Ppat_var name} in
+  let Code (varse,e) = validate_vars l e in
+  Code (merge varsb varse,
+  {pexp_loc = l; 
+   pexp_desc = 
+    Pexp_let ((if deflt_flag then Default else Nonrecursive), [(pat,e)],ebody)})
+
+(*
+ Recursive let is subject to additional well-formedness constraints, 
+ see bytecomp/translcore.ml:transl_let.
+ The first is that binding pattern should contain either Tpat_var
+ or Tpat_alias. For build_let_simple_rec, this constraint is
+ satisfied automatically. 
+ The second check is performed by check_recursive_lambda in 
+ bytecomp/translcore.ml. We use a simpler version of the test:
+ we allow only letrec experssions of the form
+   let rec f = fun x -> ....
+ that is, 
+   let rec f x y ... =
+*)
+let build_letrec : 
+  Location.t -> string loc array -> 
+    (code_repr array -> code_repr array) -> code_repr = 
+  fun l old_names fbodies -> 
+  let (names,vars,ebodies) = 
+    with_binding_region_gen l (Array.to_list old_names) fbodies in
+  let (ebody,es) = 
+    match ebodies with body::es -> (body,es) | _ -> assert false in
+  let pel = List.map2 (fun name e ->
+     ({ppat_loc  = name.loc; ppat_desc = Ppat_var name},e)) names es in
+  let check_rhs e =
+    match e.pexp_desc with
+    | Pexp_function (_,_,_) -> ()
+    | _ ->     
+        Format.fprintf Format.str_formatter
+          "Recursive let binding %a must be to a function %a"
+          Location.print l Location.print e.pexp_loc;
+        failwith (Format.flush_str_formatter ()) in
+  List.iter check_rhs es;
+  Code (vars,
+  {pexp_loc = l; 
+   pexp_desc = Pexp_let (Recursive, pel, ebody)})
+
+
+(*{{{ CSP *)
+
+(* ------------------------------------------------------------------------ *)
+(* Dealing with CSP *)
+
+exception CannotLift
+
+(* Analyze the type of the expression and figure out if we can lift it.
+   Raise CannotLift if cannot (e.g., the type is polymorphic), or it is too
+   much to bother.
+   TODO: lists, arrays, option types of liftable types are themselves
+   liftable. We can lift many more types. For arrays, check their length.
+   If the array is short, it should be lifted. For long arrays,
+   building a CSP is better (although it make take a bit longer since
+   we will have to invoke dyn_quote at run-time).
+
+   TODO: currently we generate calls to run-time functions like 
+   lift_constant_int to do the Parsetree generation. In the future
+   we should `inline' those functions -- that is, obtain the Typedtree
+   for them and use the tree for building Texp_apply.
+*)
+let lift_as_literal : 
+  Typedtree.expression -> Path.t -> Longident.t loc -> 
+  Typedtree.expression_desc = fun exp p li ->
+  let exp_ty =
+        Ctype.expand_head exp.exp_env (Ctype.correct_levels exp.exp_type) in
+  match Ctype.repr exp_ty with
+    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_int ->
+        texp_apply (texp_ident "Trx.lift_constant_int") [exp]
+    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_char ->
+        texp_apply (texp_ident "Trx.lift_constant_char") [exp]
+    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_bool ->
+        texp_apply (texp_ident "Trx.lift_constant_bool") [exp]
+          (* double and string are handled by dyn_quote *)
+    | _ -> raise CannotLift
+
+(* TODO: similarly handle Const_nativeint, Const_int32, Const_int64 *)
+let lift_constant_int : int -> code_repr = fun x -> 
+  open_code
+  {pexp_loc  = Location.none;
+   pexp_desc = Pexp_constant (Const_int x)}
+
+let lift_constant_char : char -> code_repr = fun x -> 
+  open_code
+  {pexp_loc  = Location.none;
+   pexp_desc = Pexp_constant (Const_char x)}
+
+let lift_constant_bool : bool -> code_repr = fun x -> 
+  let b = if x then "true" else "false" in 
+  open_code
+  {pexp_loc  = Location.none;
+   pexp_desc = Pexp_construct (Location.mknoloc (Longident.Lident b), 
+                               None, false)}
+
+
+(* Lift the run-time value v into a Parsetree for the code that, when
+   run, will produce v.
+   We do not have the type information for v, but we can examine
+   its run-time representation, to decide if we lift it is a source
+   literal or as a CSP.
+
+  TODO: also check for double_array_tag
+   and create a (structured) constant for a double array
+*)
+let dyn_quote : Obj.t -> Longident.t loc -> code_repr =
+  fun v li ->
+   let dflt = Pexp_cspval(v,li) in        (* By default, we build CSP *)
+   let desc = 
+    match Obj.is_int v with
+    | true -> dflt  (* If v looks like an int, it can represent many things: *)
+                    (* can't lift *)
+    | false when Obj.tag v = Obj.double_tag ->
+      Pexp_constant (Const_float (string_of_float (Obj.obj v)))
+    | false when Obj.tag v = Obj.string_tag ->
+      Pexp_constant (Const_string (Obj.obj v))
+    | _   -> dflt
+   in 
+   open_code
+   {pexp_loc = li.loc; pexp_desc = desc}
+
+       
+(* Build the Typedtree that lifts the variable with the given path and type.
+   Since this code receives the type of the variable, we use the
+   type to generate the lifting code for that particular type.
+   For example, we build the code to convert a float
+   0.1 to the Parsetree node Pexp_constant(Const_float "0.1")).
+   If we cannot or would not do the type-dependent lifting and we cannot
+   refer to the variable by name (e.g., because it is local),
+   we generate the call to the dynamic quoter, dyn_quote.
+   The latter will receive the actual value to quote and will generate,
+   at run-time, a Parsetree constant or CSP, based on that value.
+ *)
+let trx_csp : 
+  Typedtree.expression -> Path.t -> Longident.t loc ->
+  Typedtree.expression_desc = fun exp p li ->
+  (* First we try lifting as a constant *)
+  try lift_as_literal exp p li 
+  with CannotLift ->
+  (* Then check if we can pass by reference *)
+  if ident_can_be_quoted p then
+    texp_code ~node_id:"*id*" exp.exp_loc
+          (Pexp_ident (Location.mkloc (path_to_lid p) li.loc))
+  else
+  (* Otherwise, do the lifting at run-time *)
+  texp_apply (texp_ident "Trx.dyn_quote") [exp; texp_lid li]
+
+(*{{{ Historical: hints on native mode CSP *)
+
+(* Native mode is moved out to the `userland'
+
+let remove_texp_cspval exp =
+  if !native_mode = false then exp else
+  failwith "native mode CSP are not impemented yet"
+
+old code
+  match exp.exp_desc with
+  | Texp_cspval (v,l) ->
+      let i = add_csp_value (v,l) in
+      let exp' = {exp with exp_desc = Texp_constant (Const_int i)} in
+      let desc = if !initial_native_compilation
+        then (Texp_apply (trx_array_get exp, [(Some !local_csp_arr_texp, Required);(Some exp', Required)]))
+	else (Texp_apply (trx_get_csp_value exp, [(Some exp', Required)])) in
+      {exp with exp_desc = desc}
+  | _ -> assert false
+*)
+
+(*}}}*)
+
+(*}}}*)
+
+
+(*{{{ Translating patterns and expressions using patterns *)
+
+
+(* Analyze and translate a pattern:
+         Typedtree.pattern -> Parsetree.pattern
+  The function is somewhat similar to tools/untypeast.ml;untype_pattern
+
+  However, we also determine and return the list of bound variables.
+  The list is in the reverse of the order of variables occurring in the pattern.
+  Finally, we check that labels and constructors may be quoted.
+
+  The algorithm of determining the names of bound variables is based
+  on Typedtree.pat_bound_idents. There is one subtle issue.
+  Normally all variables within a pattern are unique (patterns are
+  always linear). Identically named variables within a list of patterns, like 
+      match ... with
+      | [x] -> 
+      | [x;y] ->
+  are _distinct_ variables. They have different Ident.t values, even though
+  their names may be the same. However, components of an OR pattern 
+  bind exactly the same identifiers. Don't count them twice!
+*)
+
+
+(* The first argument is a list of identifiers. Found identifiers are
+   prepended to that list. The order of identifiers is important!
+   If you change the traversal order, be sure to modify pattern_subst below!
+*)
+let rec trx_pattern : 
+    (Ident.t * string loc) list -> Typedtree.pattern -> 
+     Parsetree.pattern * (Ident.t * string loc) list = fun acc pat ->
+ if not (pat.pat_extra = []) then
+   not_supported pat.pat_loc
+    "patterns with unpack, constraints, and other pat_extra";
+  let (pd,acc) = match pat.pat_desc with
+  | Tpat_any -> (Ppat_any, acc)
+  | Tpat_var (id, name) when 
+      (match (Ident.name id).[0] with 'A'..'Z' -> true | _ -> false) ->
+        (Ppat_unpack name,acc)        (* We don't handle modules though...*)
+  | Tpat_var (id, name) ->
+      (Ppat_var name, (id,name)::acc)
+  | Tpat_alias (p, id, name) ->
+      let (p,acc) = trx_pattern acc p in
+      (Ppat_alias (p, name),(id,name)::acc)
+  | Tpat_constant cst -> (Ppat_constant cst, acc)
+  | Tpat_tuple lst ->
+    let (pl,acc) = map_accum trx_pattern acc lst
+    in (Ppat_tuple pl, acc)
+  | Tpat_construct (li, cdesc, args, explicit_arity) ->
+      let lid = qualify_ctor li cdesc in
+      let (args,acc) = map_accum trx_pattern acc args in
+      (Ppat_construct (lid,
+          (match args with
+          | []  -> None 
+          | [x] -> Some x 
+          | _   -> Some {ppat_desc = Ppat_tuple args; ppat_loc = pat.pat_loc}),
+          explicit_arity),
+       acc)
+  | Tpat_variant (label, None, _) -> (Ppat_variant (label,None),acc)
+  | Tpat_variant (label, Some p, _) ->
+      let (p,acc) = trx_pattern acc p 
+      in (Ppat_variant (label,Some p),acc)
+  | Tpat_record (lst, closed) ->
+      let dolab acc (li,ldesc,pat) =
+        let lid = qualify_label li ldesc in
+        let (pat,acc) = trx_pattern acc pat in
+        ((lid,pat),acc)
+      in
+      let (lpl,acc) = map_accum dolab acc lst in
+      (Ppat_record (lpl,closed),acc)
+  | Tpat_array lst -> 
+    let (pl,acc) = map_accum trx_pattern acc lst
+    in (Ppat_array pl, acc)
+  | Tpat_or (p1, p2, _) -> 
+      (* Invariant : both arguments bind the same variables *)
+      let (p1,acc) = trx_pattern acc p1 in
+      let (p2,_)   = trx_pattern acc p2 in (* ignore vars in p2 *)
+      (Ppat_or (p1,p2),acc)
+  | Tpat_lazy p -> 
+      let (p,acc) = trx_pattern acc p in (Ppat_lazy p,acc)
+  in
+  ({ ppat_desc = pd; ppat_loc = pat.pat_loc}, acc)
+
+
+(* Process all patterns in the pattern-expression list *)
+(* Patterns are processed left-to-right. The result is the processed
+   pattern list plus the list of names of the bound variables.
+   The variables are listed in the order they occur in the pattern.
+   Thus the following should hold:
+      let (pats,names,_) = trx_pel pel in
+      let (pats',acc) =  pattern_subst_list names pats in
+      assert (pats = pats');
+      assert (acc = [])
+   The final result of trx_pel is the pattern binding the names.
+   We build an array pattern rather than a more appropriate tuple.
+   Using array forces a single type to all arguments. Although
+   it is phantom anyway, it is still a bummer. But we the tuple
+   we can't generically write build_fun.
+   The second argument, typ_expr, should normally be a code type.
+
+   This function is used when translating a future-stage function as the 
+   present-stage whose argument is an array of variables.
+   See trx_bracket for functions, let, match and try
+*)
+let trx_pel : (Typedtree.pattern * Typedtree.expression) list -> type_expr ->
+     Parsetree.pattern list * string loc list * Typedtree.pattern
+   = fun pel typ -> 
+   let (pats, lst) = map_accum (fun acc (p,_) -> trx_pattern acc p) [] pel in
+   let idnames = List.rev lst in
+   let (loc,env) = 
+     match pel with (p,_)::_ -> (p.pat_loc, p.pat_env) |_ -> assert false in
+    (* Pattern representing one binding variable *)
+   let var_pat (id,name) =
+    {pat_loc = loc; pat_extra = []; pat_env = env;
+     pat_desc = Tpat_var (id,name);
+     pat_type = typ} in
+   (pats, List.map snd idnames,
+    {pat_loc = loc; pat_extra = []; pat_env = env;
+     pat_desc = Tpat_array (List.map var_pat idnames);
+     pat_type = Ctype.instance_def (Predef.type_array typ)})
+
+(* Substitute the names of bound variables in the pattern.
+   The new names are given in the string loc list. We
+   take advantage of the fact that patterns are linear and
+   the list of new names is ordered, in the order the bound
+   variables occur in the pattern. Therefore, we substitute based
+   on position.
+   OR-patterns bring complexity however: both branches of an OR
+   pattern bind exactly the same variables (but the order of
+   variable occurrence within branches may be different).
+   So for OR patterns we substitute by name, taking advantage
+   of the fact the new names differ from the old ones in _nnn
+   suffix. OR patterns are uncommon, so the complication of their processing
+   is not that bad.
+
+   This function is closely related to trx_pattern; It relies on the
+   same pattern traversal order as trx_pattern.
+ *)
+
+         (* two strings are the same up to (and including) n *)
+let rec same_upto s1 s2 n =
+  n < 0 || (s1.[n] = s2.[n] && same_upto s1 s2 (n-1))
+
+let rec pattern_subst : ?by_name:bool ->
+    string loc list -> Parsetree.pattern -> 
+     Parsetree.pattern * string loc list = fun ?(by_name=false) acc pat ->
+ if acc = [] then (pat,acc) else           (* no more variables to subst *)
+ let subst old_name acc =
+   if by_name then begin
+     let new_name =
+       try List.find (fun n -> 
+         same_upto old_name.txt n.txt (String.rindex n.txt '_' - 1)) acc 
+       with _ ->
+         begin
+           Format.fprintf Format.str_formatter "old_name %s %a\n"
+             old_name.txt Location.print old_name.loc;
+           List.iter (fun n -> Format.fprintf Format.str_formatter
+               "new name %s %a\n" n.txt Location.print n.loc) acc;
+           failwith (Format.flush_str_formatter ())
+         end
+     in
+     (new_name, acc)                       (* don't bother removing from acc*)
+   end
+   else match acc with
+   | h::t -> (h,t)
+   | _    -> assert false
+ in
+ let (desc,acc) = match pat.ppat_desc with
+  | Ppat_any as x -> (x,acc)
+  | Ppat_var old_name ->
+      let (new_name,acc) = subst old_name acc in (Ppat_var new_name,acc)
+  | Ppat_alias (p,old_name) ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     let (new_name,acc) = subst old_name acc in 
+     (Ppat_alias (p,new_name),acc)
+  | Ppat_constant _ as x -> (x,acc)
+  | Ppat_tuple pl ->
+      let (pl,acc) = map_accum (pattern_subst ~by_name) acc pl in
+      (Ppat_tuple pl,acc)
+  | Ppat_construct (_,None,_) as x -> (x,acc)
+  | Ppat_construct (lid,Some p,b) ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     (Ppat_construct (lid,Some p,b),acc)
+  | Ppat_variant (_,None) as x -> (x,acc)
+  | Ppat_variant (l,Some p) ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     (Ppat_variant (l,Some p),acc)
+  | Ppat_record (pl,cf) ->
+      let (pl,acc) = map_accum (fun acc (l,p) -> 
+          let (p,acc) = pattern_subst ~by_name acc p in ((l,p),acc)) acc pl in
+      (Ppat_record (pl,cf),acc)
+  | Ppat_array pl ->
+      let (pl,acc) = map_accum (pattern_subst ~by_name) acc pl in
+      (Ppat_array pl,acc)
+  | Ppat_or (p1,p2) ->
+     let (p1,acc') = pattern_subst ~by_name acc p1 in
+     let (p2,_)   = pattern_subst ~by_name:true acc p2 in
+     (Ppat_or (p1,p2), acc')
+  | Ppat_constraint (p,cty) ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     (Ppat_constraint (p,cty), acc)
+  | Ppat_type _ as x -> (x,acc)
+  | Ppat_lazy p ->
+     let (p,acc) = pattern_subst ~by_name acc p in
+     (Ppat_lazy p, acc)
+  | Ppat_unpack _ as x -> (x,acc)
+ in
+ ({pat with ppat_desc = desc}, acc)
+
+
+let pattern_subst_list :
+    string loc list -> Parsetree.pattern list -> 
+     Parsetree.pattern list * string loc list = fun acc pl ->
+ map_accum (pattern_subst ~by_name:false) acc pl
+
+
+
+(* Build the general fun Parsetree *)
+let build_fun : 
+  Location.t -> string -> 
+  (* The following argument is a pair: a pattern list for the clauses
+     of the function, and the list of names of bound variables, in order.
+  *)
+  (Parsetree.pattern list * string loc list) -> 
+  (code_repr array -> code_repr array) -> code_repr =
+  fun l label (pats,old_names) fbodies -> 
+    let (names,vars,ebodies) = with_binding_region_gen l old_names fbodies in
+    let pats = 
+      if names = [] then pats else
+      let (pats,acc) = pattern_subst_list names pats in
+      assert (acc = []); pats
+    in
+    Code(vars,
+      {pexp_loc = l; 
+       pexp_desc = Pexp_function (label,None,
+                                  List.map2 (fun p e -> (p,e)) pats ebodies)})
+
+(* Build the general let-Parsetree (like the fun-Parsetree) *)
+let build_let : 
+  Location.t -> bool -> 
+  (Parsetree.pattern list * string loc list) -> code_repr array ->
+  (code_repr array -> code_repr array) -> code_repr =
+  fun l recf (pats,old_names) ecs fbodies ->
+    let (names,bvars,ebodies) = with_binding_region_gen l old_names fbodies in
+    let ebody = match ebodies with [x] -> x | _ -> assert false in
+    let pats = 
+      if names = [] then pats else
+      let (pats,acc) = pattern_subst_list names pats in
+      assert (acc = []); pats
+    in
+    let (es,evars) = validate_vars_list l (Array.to_list ecs) in
+    Code (merge evars bvars,
+          {pexp_loc = l; 
+           pexp_desc = 
+             Pexp_let ((if recf then Default else Nonrecursive), 
+                       List.map2 (fun p e -> (p,e)) pats es,ebody)})
+
+
+(* build match and try: both are very similar and similar to build_fun *)
+let build_match : 
+  Location.t -> (Parsetree.pattern list * string loc list) -> code_repr ->
+  (code_repr array -> code_repr array) -> code_repr =
+  fun l (pats,old_names) ec fbodies ->
+    let (names,bvars,ebodies) = with_binding_region_gen l old_names fbodies in
+    let pats = 
+      if names = [] then pats else
+      let (pats,acc) = pattern_subst_list names pats in
+      assert (acc = []); pats
+    in
+    let Code (evars,exp) = validate_vars l ec in
+    Code (merge evars bvars,
+     {pexp_loc = l; 
+      pexp_desc = Pexp_match (exp, List.map2 (fun p e -> (p,e)) pats ebodies)})
+
+
+(* Essentially the same as build_match.
+   TODO: implement the same check on the timestamp of the expression to try
+*)
+let build_try : 
+  Location.t -> (Parsetree.pattern list * string loc list) -> code_repr ->
+  (code_repr array -> code_repr array) -> code_repr =
+  fun l (pats,old_names) ec fbodies ->
+    let (names,bvars,ebodies) = with_binding_region_gen l old_names fbodies in
+    let pats = 
+      if names = [] then pats else
+      let (pats,acc) = pattern_subst_list names pats in
+      assert (acc = []); pats
+    in
+    let Code (evars,exp) = validate_vars l ec in
+    Code (merge evars bvars,
+     {pexp_loc = l; 
+      pexp_desc = Pexp_try (exp, List.map2 (fun p e -> (p,e)) pats ebodies)})
+
+
+(*}}}*)
+
+(* ------------------------------------------------------------------------ *)
+(* The main function to translate away brackets. It receives
+   an expression at the level n > 0.
+
+   Since bracket-translation is somewhat similar to un-typechecking,
+   see tools/untypeast.ml for hints on mapping Typedtree.expression
+   to Parsetree.expression.
+
+TODO: an optimization idea. Consider <assert e> as a typical expression.
+We translate it to the invocation of build_assert that will construct
+the Parsetree node at run-time. However, of 'e' is simple (e.g., a constant)
+then we can construct the Parsetree node at compile time and pass it
+as a CSP. There are no longer any functions calls to make at run-time.
+So, we can modify the translation of <assert e> below to detect
+if the translation of e produced Texp_cspval. We extract the CSP value,
+invoke build_assert (at compile time, when trx.ml is run) to build
+the Pexp_assert node, and wrap it as a CSP.
+
+Essentially the result of trx_bracket should be like
+   Transl_bracket of Parsetree.expression option * Typedtree.expression
+The first part of the result is the code built-in at compile time.
+This part is None of the expression to translate contains an escape
+or a true CSP (global id is OK). Sometimes we need both parts: consider
+       <fun x -> x + ~(...)>
+When we translate x we don't know if we can take a shortcut and
+build the function code at translation time. So, we have to account
+for both possibilities. If we can build the function at compile time,
+we don't even need to rename the bound variable!
+
+*)
+
+(* Given a type [ty], return [ty code code ... code] (n times code).
+   When we push the bracket in, expressions that had type ty before
+   will have the type ty code.
+   Here, ty code is an abstract type whose concrete representation
+   is code_repr.
+   Generally speaking we don't have to adjust the types since the
+   type checking is finished. However, code generator may look
+   at types; it's better if we don't lie. Thus, as trx_bracket
+   translates the expression, it should also adjust the types.
+*)
+
+let rec wrap_ty_in_code : int -> type_expr -> type_expr = fun n ty ->
+  if n=0 then ty else
+  (* let clsfier = Btype.newgenvar () in *)
+  wrap_ty_in_code (n-1) (Predef.type_code ty)
+
+let map_option : ('a -> 'b) -> 'a option -> 'b option = fun f -> function
+  | None   -> None
+  | Some x -> Some (f x)
+
+
+let rec trx_bracket : 
+  (expression -> expression) -> (* 0-level traversal *)
+  int -> (expression -> expression) = fun trx_exp n exp ->
+  let new_desc = match exp.exp_desc with
+    (* Don't just do when vd.val_kind = Val_reg 
+       because (+) or Array.get are Val_prim *)
+  | Texp_ident (p,li,vd)  ->
+    let stage = try Env.find_stage p exp.exp_env
+	        with Not_found ->
+                  if false then
+                    debug_print ("Stage for var is set to implicit 0:" ^ 
+	                         Path.name p ^ "\n");  0 in
+    (* We make CSP only if the variable is bound at the stage 0.
+       Variables bound at stage > 0 are subject to renaming.
+       They are translated into stage 0 variable but of a different
+       type (t code), as explained in the title comments.
+     *)
+    if stage = 0 then trx_csp exp p li 
+    else
+         (* Future-stage bound variable becomes the present-stage
+            bound-variable, but at a different type.
+          *)
+      let () = assert (vd.val_kind = Val_reg) in
+      (* The drawback is that exp.exp_loc disappears. If the scope extrusion
+         is reported for a simple expression like <x>, we can no longer
+         print in the error message the location that <x> appeared.
+         We can only print the location x was bound.
+      *)
+      Texp_ident (p,li,{vd with val_type = wrap_ty_in_code n vd.val_type})
+
+  | Texp_constant cst -> 
+      texp_code ~node_id:"*cst*" exp.exp_loc (Pexp_constant cst)
+
+     (* Recursive let: 
+         let rec f = e1 [and g = e2 ...] in body
+        According to transl_let in bytecomp/translcore.ml,
+        the patterns in recursive let are very restrictive: elther
+          let rec var = ...
+        or
+          let rec _ as var = ...
+       For instance, let rec (x1,x2) = ... is not allowed.
+       We do this test here. For simplicity, we are not going to support
+          let rec _ as var = ...
+       pattern.
+      *)
+  | Texp_let (Recursive,pel,ebody) ->
+      let names =                       (* in the order of appearance *)
+        let rec loop = function
+          | [] -> []
+          | ({pat_desc = Tpat_var (_,name)},_) :: rest -> name :: loop rest
+          | _ -> trx_error ~loc:exp.exp_loc (fun ppf -> Format.fprintf ppf
+                "Only variables are allowed as left-hand side of `let rec'")
+        in loop pel
+      in
+      (* code for body followed by the code for e's *)
+      let es_body = texp_array (
+        trx_bracket trx_exp n ebody ::
+          (List.map (fun (_,e) -> trx_bracket trx_exp n e) pel)) in
+      texp_apply (texp_ident "Trx.build_letrec") 
+        [texp_loc exp.exp_loc;
+         texp_array (List.map texp_string_loc names);
+             (* Translate the future-stage function as the present-stage 
+                function whose argument is an array of variables 
+                (should be a tuple, really) and the type
+                   some_targ code array -> tres code array
+                See the comment at Texp_function below for details.
+              *)
+         let pats = List.map (fun (p,_) -> 
+                      {p with pat_type = wrap_ty_in_code n p.pat_type}) pel in
+         let p1 = (match pats with h::_ -> h | _ -> assert false) in
+         let pat = {p1 with
+                    pat_desc = Tpat_array pats;
+                    pat_type = 
+                        Ctype.instance_def (Predef.type_array p1.pat_type)} in
+         { exp with
+           exp_desc = Texp_function ("",[(pat, es_body)],Total);
+           exp_type = {exp.exp_type with desc =
+                           Tarrow ("",pat.pat_type, es_body.exp_type, Cok)}
+         }
+       ]
+
+     (* The most common case of let-expressions: non-recursive
+        let x = e in body *)
+     (* recf = Default for a let auto-generated by the type
+        checker for the default function argument.
+      *)
+  | Texp_let (recf,[({pat_desc = Tpat_var (_,name)} as pat,e)],ebody) ->
+      let pat = {pat with pat_type = wrap_ty_in_code n pat.pat_type} in
+      texp_apply (texp_ident "Trx.build_let_simple_nonrec") 
+        [texp_loc exp.exp_loc;
+         texp_string_loc name;
+         texp_bool (recf = Default);
+         trx_bracket trx_exp n e;
+         { exp with
+           exp_desc = 
+             Texp_function ("",[(pat, trx_bracket trx_exp n ebody)],Total);
+           exp_type = 
+            {exp.exp_type with desc =
+               Tarrow ("",pat.pat_type, wrap_ty_in_code n ebody.exp_type, Cok)}
+         }
+       ]
+
+    (* General-case, non-recursive let General case. Like Texp_function *)
+  | Texp_let (recf,pel,body) ->
+      let (pl,names,binding_pat) = 
+        trx_pel pel (wrap_ty_in_code n (Btype.newgenvar ())) in
+      texp_apply (texp_ident "Trx.build_let") 
+        [texp_loc exp.exp_loc;
+         texp_bool (recf = Default);
+         texp_pats_names pl names;
+         texp_array (List.map (fun (_,e) -> trx_bracket trx_exp n e) pel);
+         (* See the comment at Texp_function below *)
+         let body = texp_array [trx_bracket trx_exp n body] in
+         { exp with
+           exp_desc = Texp_function ("",[(binding_pat, body)],Total);
+           exp_type = {exp.exp_type with desc =
+                       Tarrow ("",binding_pat.pat_type, body.exp_type, Cok)}
+         }
+       ]
+
+     (* The most common case of functions: fun x -> body *)
+  | Texp_function (l,[({pat_desc = Tpat_var (_,name)} as pat,ebody)],_) ->
+      let pat = {pat with pat_type = wrap_ty_in_code n pat.pat_type} in
+      texp_apply (texp_ident "Trx.build_fun_simple") 
+        [texp_loc exp.exp_loc;
+         texp_string l;
+         texp_string_loc name;
+         (* Translate the future-stage function as present-stage function;
+            with the same variables, but with a different type,
+            targ code -> tres code
+          *)
+         { exp with
+           exp_desc = 
+             Texp_function ("",[(pat, trx_bracket trx_exp n ebody)],Total);
+           exp_type = 
+            {exp.exp_type with desc =
+               Tarrow ("",pat.pat_type, wrap_ty_in_code n ebody.exp_type, Cok)}
+         }
+       ]
+
+  | Texp_function (l,pel,_) ->
+      begin
+      match trx_pel pel (wrap_ty_in_code n (Btype.newgenvar ())) with
+      | (pl, [], _) ->                    (* non-binding pattern *)
+          texp_apply (texp_ident "Trx.build_fun_nonbinding")
+            [texp_loc exp.exp_loc; 
+             texp_string l;
+             begin 
+               let pl_exp = texp_ident "Trx.sample_pat_list" in
+               {pl_exp with
+                exp_desc = Texp_cspval (Obj.repr pl, dummy_lid "*pl*")}
+             end;
+             texp_array (List.map (fun (_,e) -> trx_bracket trx_exp n e) pel)
+           ]
+      | (pl, names, binding_pat) ->
+          texp_apply (texp_ident "Trx.build_fun") 
+            [texp_loc exp.exp_loc;
+             texp_string l;
+             texp_pats_names pl names;
+             (* Translate the future-stage function as the present-stage 
+                function whose argument is an array of variables 
+                (should be a tuple, really) and the type
+                   some_targ code array -> tres code array
+                Using array forces a single type to all arguments. Although
+                it is phantom anyway, it is still a bummer. Instead of
+                array, we should have used a tuple. But then we can't
+                generically write build_fun.
+              *)
+               (* Pattern representing the function's argument:
+                  array of variables bound by the original pattern, in order.
+                *)
+             let body = texp_array (List.map (fun (_,e) -> 
+                                     trx_bracket trx_exp n e) pel) in
+             { exp with
+                exp_desc = Texp_function ("",[(binding_pat, body)],Total);
+                exp_type = {exp.exp_type with desc =
+                            Tarrow ("",binding_pat.pat_type, body.exp_type, 
+                                    Cok)}
+             }
+           ]
+      end
+
+  | Texp_apply (e, el) ->
+     (* first, we remove from el the information added by the type-checker *)
+     let lel = List.fold_right (function                 (* keep the order! *)
+                | (_,None,_)   -> fun acc -> acc
+                | (l,Some e,_) -> fun acc -> (l,e)::acc) el [] in
+     let lel = ("",e) :: lel in          (* Add the operator *)
+      texp_apply (texp_ident "Trx.build_apply")
+        [texp_loc exp.exp_loc; 
+         texp_array (List.map (fun (l,e) ->
+           texp_tuple [texp_string l;trx_bracket trx_exp n e]) lel)]
+
+  (* Pretty much like a function *)
+  | Texp_match (e,pel,_) ->
+      let (pl,names,binding_pat) = 
+        trx_pel pel (wrap_ty_in_code n (Btype.newgenvar ())) in
+      texp_apply (texp_ident "Trx.build_match") 
+        [texp_loc exp.exp_loc;
+         texp_pats_names pl names;
+         trx_bracket trx_exp n e;
+         (* See the comment at Texp_function above *)
+         let body = texp_array (List.map (fun (_,e) -> 
+                                     trx_bracket trx_exp n e) pel) in
+         { exp with
+           exp_desc = Texp_function ("",[(binding_pat, body)],Total);
+           exp_type = {exp.exp_type with desc =
+                       Tarrow ("",binding_pat.pat_type, body.exp_type, Cok)}
+         }
+       ]
+
+  | Texp_try (e,pel) ->                 (* same as Texp_match *)
+      let (pl,names,binding_pat) = 
+        trx_pel pel (wrap_ty_in_code n (Btype.newgenvar ())) in
+      texp_apply (texp_ident "Trx.build_try") 
+        [texp_loc exp.exp_loc;
+         texp_pats_names pl names;
+         trx_bracket trx_exp n e;
+         (* See the comment at Texp_function above *)
+         let body = texp_array (List.map (fun (_,e) -> 
+                                     trx_bracket trx_exp n e) pel) in
+         { exp with
+           exp_desc = Texp_function ("",[(binding_pat, body)],Total);
+           exp_type = {exp.exp_type with desc =
+                       Tarrow ("",binding_pat.pat_type, body.exp_type, Cok)}
+         }
+       ]
+
+  | Texp_tuple el ->
+      texp_apply (texp_ident "Trx.build_tuple")
+        [texp_loc exp.exp_loc; 
+	 texp_array (List.map (trx_bracket trx_exp n) el)]
+
+  | Texp_construct (li, cdesc, args, explicit_arity) ->
+      let lid = qualify_ctor li cdesc in
+      texp_apply (texp_ident "Trx.build_construct")
+        [texp_loc exp.exp_loc; 
+         texp_lid lid;
+	 texp_array (List.map (trx_bracket trx_exp n) args);
+         texp_bool explicit_arity]
+
+  | Texp_variant (l,eo) ->              (* polymorphic variant *)
+      texp_apply (texp_ident "Trx.build_variant")
+        [texp_loc exp.exp_loc; 
+         texp_string l;
+	 texp_option (map_option (trx_bracket trx_exp n) eo)]
+
+  | Texp_record (lel,eo) ->
+      texp_apply (texp_ident "Trx.build_record")
+        [texp_loc exp.exp_loc; 
+         texp_array (List.map (fun (li,ldesc,e) ->
+           texp_tuple [texp_lid (qualify_label li ldesc);
+                       trx_bracket trx_exp n e]) lel);
+         texp_option (map_option (trx_bracket trx_exp n) eo)]
+
+  | Texp_field (e,li,ldesc) ->
+      texp_apply (texp_ident "Trx.build_field")
+        [texp_loc exp.exp_loc; 
+         trx_bracket trx_exp n e;
+         texp_lid (qualify_label li ldesc)]
+
+  | Texp_setfield (e1,li,ldesc,e2) ->
+      texp_apply (texp_ident "Trx.build_setfield")
+        [texp_loc exp.exp_loc; 
+         trx_bracket trx_exp n e1;
+         texp_lid (qualify_label li ldesc);
+         trx_bracket trx_exp n e2]
+
+  | Texp_array el ->
+      texp_apply (texp_ident "Trx.build_array")
+        [texp_loc exp.exp_loc; 
+	 texp_array (List.map (trx_bracket trx_exp n) el)]
+
+  | Texp_ifthenelse (e,et,efo) ->
+      texp_apply (texp_ident "Trx.build_ifthenelse")
+        [texp_loc exp.exp_loc; 
+         trx_bracket trx_exp n e;
+         trx_bracket trx_exp n et;
+	 texp_option (map_option (trx_bracket trx_exp n) efo)]
+
+  | Texp_sequence (e1,e2) ->
+      texp_apply (texp_ident "Trx.build_sequence")
+        [texp_loc exp.exp_loc; 
+	 trx_bracket trx_exp n e1; trx_bracket trx_exp n e2]
+  | Texp_while (e1,e2) ->
+      texp_apply (texp_ident "Trx.build_while")
+        [texp_loc exp.exp_loc; 
+	 trx_bracket trx_exp n e1; trx_bracket trx_exp n e2]
+
+  | Texp_for (id, name, elo, ehi, dir, ebody) ->
+      texp_apply (texp_ident "Trx.build_for") 
+        [texp_loc exp.exp_loc;
+         texp_string_loc name;
+         trx_bracket trx_exp n elo;
+         trx_bracket trx_exp n ehi;
+         texp_bool (dir = Upto);
+         let var_typ = wrap_ty_in_code n (Ctype.instance_def Predef.type_int) in
+         let pat = {pat_loc = exp.exp_loc; pat_extra = [];
+                    pat_type = var_typ; pat_env = exp.exp_env;
+                    pat_desc = Tpat_var (id,name)} in
+         { exp with
+           exp_desc = 
+             Texp_function ("",[(pat, trx_bracket trx_exp n ebody)],Total);
+           exp_type = 
+            {exp.exp_type with desc =
+               Tarrow ("",var_typ, wrap_ty_in_code n ebody.exp_type, Cok)}
+         }
+       ]
+
+  | Texp_when (e1,e2) ->
+      texp_apply (texp_ident "Trx.build_when")
+        [texp_loc exp.exp_loc; 
+	 trx_bracket trx_exp n e1; trx_bracket trx_exp n e2]
+
+  | Texp_send (e,m,_) ->
+      (* We don't check the persistence of the method: after all,
+         a method name is somewhat like a polymorphic variant.
+         It's perfectly OK to have a function fun x -> x # foo
+      *)
+      texp_apply (texp_ident "Trx.build_send")
+        [texp_loc exp.exp_loc; 
+	 trx_bracket trx_exp n e;
+         texp_string (match m with
+                        | Tmeth_name name -> name
+                        | Tmeth_val id -> Ident.name id)]
+
+  | Texp_new (p,li,_) ->
+      check_path_quotable "Class" p;
+      texp_code ~node_id:"*new*" exp.exp_loc 
+        (Pexp_new (Location.mkloc (path_to_lid p) li.loc))
+
+  | Texp_instvar (p1,p2,s) ->
+      not_supported exp.exp_loc "Objects (Texp_instvar)"
+        (* Alternatively: since instance variables are always bound 
+           at level 0 (for now)
+           so this is like a csp variable 
+        call_trx_mkcsp exp None (path_to_lid p2)
+        *)
+  | Texp_setinstvar _ -> not_supported exp.exp_loc "Objects (Texp_setinstvar)"
+  | Texp_override  _  -> not_supported exp.exp_loc "Objects (Texp_override)"
+  | Texp_letmodule (id,s,me,e) -> not_supported exp.exp_loc "let module"
+
+  | Texp_assert e ->
+      texp_apply (texp_ident "Trx.build_assert")
+        [texp_loc exp.exp_loc; trx_bracket trx_exp n e]
+  | Texp_assertfalse ->
+      texp_code ~node_id:"*af*" exp.exp_loc Pexp_assertfalse
+
+  | Texp_lazy e ->
+      texp_apply (texp_ident "Trx.build_lazy")
+        [texp_loc exp.exp_loc; trx_bracket trx_exp n e]
+
+  | Texp_object (cl,fl) -> not_supported exp.exp_loc "Objects"
+  | Texp_pack _         -> not_supported exp.exp_loc "First-class modules"
+
+  | Texp_bracket e ->
+      texp_apply (texp_ident "Trx.build_bracket")
+        [texp_loc exp.exp_loc; trx_bracket trx_exp (n+1) e]
+  | Texp_escape e ->
+      if n = 1 then (trx_exp e).exp_desc	(* switch to 0 level *)
+      else
+      texp_apply (texp_ident "Trx.build_escape")
+        [texp_loc exp.exp_loc; trx_bracket trx_exp (n-1) e]
+  | Texp_cspval (v,li) ->               (* CSP is a sort of a constant *)
+      texp_code ~node_id:"*csp*" exp.exp_loc (Pexp_cspval(v,li))
+
+  (* | _ -> not_supported exp.exp_loc "not yet supported" *)
+  in                               
+  let trx_extra (extra, loc) exp = (* See untype_extra in tools/untypeast.ml *)
+   let desc =
+    match extra with
+      (* Should check that cty1 and cty2 contain only globally declared
+         type components
+       *)
+    | Texp_constraint (cty1, cty2) -> 
+        not_supported loc "Texp_constraint"
+    | Texp_open (ovf, path, lid, _) -> 
+       check_path_quotable "Texp_open" path;
+       let ovf_exp = texp_ident "Trx.sample_override_flag" in
+       let ovf_exp = {ovf_exp with exp_desc = 
+                        Texp_cspval (Obj.repr ovf, dummy_lid "*ovf*")} in
+       texp_apply (texp_ident "Trx.build_open")
+        [texp_loc exp.exp_loc;
+         texp_lid (mkloc (path_to_lid path) lid.loc);
+         ovf_exp;
+         exp]      (* exp is the result of trx_bracket *)
+    | Texp_poly cto  -> not_supported loc "Texp_poly"
+    | Texp_newtype s -> not_supported loc "Texp_newtype"
+    in {exp with exp_loc = loc; exp_desc = desc} (* type is the same: code *)
+  in
+  List.fold_right trx_extra exp.exp_extra
+  {exp with exp_type = wrap_ty_in_code n exp.exp_type;
+            exp_desc = new_desc}
+
+
+
+(*{{{ Typedtree traversal to eliminate bracket/escapes *)
+
+(* ------------------------------------------------------------------------ *)
+(* Typedtree traversal to eliminate bracket/escapes *)
+
+(* Functions to help traverse and transform a tree.
+   We assume that every tree mapping function of the type 'a -> 'a
+   throws the exception Not_modified if the tree has not been
+   modified.
+   This protocol helps minimize garbage and prevent useless tree
+   duplication.
+*)
+
+exception Not_modified
+
+let replace_list : ('a -> 'a) -> 'a list -> 'a list = fun f l ->
+  let rec loop mdf = function
+  | [] -> if mdf then [] else raise Not_modified
+  | h::t -> match (try Some (f h) with Not_modified -> None) with
+             | Some h -> h :: loop true t
+             | None   -> h :: loop mdf  t
+  in loop false l
+
+let replace_pair : ('a -> 'a) -> ('b -> 'b) -> 'a * 'b -> 'a * 'b =
+  fun f g (x,y) ->
+  match ((try Some (f x) with Not_modified -> None),
+         (try Some (g y) with Not_modified -> None)) with
+  | (None,None)      -> raise Not_modified
+  | (Some x, None)   -> (x,y)
+  | (None, Some y)   -> (x,y)
+  | (Some x, Some y) -> (x,y)
+
+let replace_opt : ('a -> 'a) -> 'a option -> 'a option = fun f -> function
+  | Some e -> Some (f e)
+  | None   -> raise Not_modified
+
+(* The main function to scan the typed tree at the 0 level and
+   detect brackets 
+*)
+
+let rec trx_struct str =
+  {str with str_items = 
+  replace_list (fun si -> {si with str_desc = trx_struct_item si.str_desc})
+           str.str_items}
+
+and trx_struct_item = function
+| Tstr_eval e -> Tstr_eval (trx_exp e)
+| Tstr_value (rf,pel) ->
+    Tstr_value(rf, replace_list (fun (p,e) -> (p, trx_exp e)) pel)
+| Tstr_primitive (_,_,_) 
+| Tstr_type _
+| Tstr_exception (_,_,_)
+| Tstr_exn_rebind (_,_,_,_) -> raise Not_modified
+| Tstr_module (i,l,me) -> Tstr_module (i, l, trx_me me)
+| Tstr_recmodule l ->
+  Tstr_recmodule (replace_list (fun (i,l,mt,me) -> (i,l,mt,trx_me me)) l)
+| Tstr_modtype (_,_,_)
+| Tstr_open (_,_,_) -> raise Not_modified
+| Tstr_class l ->
+    Tstr_class (replace_list (fun (dcl,sl,vf) -> (trx_cdcl dcl,sl,vf)) l)
+| Tstr_class_type _ -> raise Not_modified
+| Tstr_include (me,il) -> Tstr_include (trx_me me, il)
+
+and trx_me me = 
+  {me with mod_desc = trx_me_desc me.mod_desc} 
+
+and trx_me_desc = function
+| Tmod_ident _ -> raise Not_modified
+| Tmod_structure str -> Tmod_structure (trx_struct str)
+| Tmod_functor (i,l,t,me) -> Tmod_functor (i,l,t, trx_me me)
+| Tmod_apply (me1,me2,mc) ->
+  let (me1,me2) = replace_pair trx_me trx_me (me1,me2) in
+  Tmod_apply (me1, me2, mc)
+| Tmod_constraint (me,mt,mtc,mc) -> Tmod_constraint (trx_me me, mt, mtc, mc)
+| Tmod_unpack (e,mt) -> Tmod_unpack (trx_exp e,mt)
+
+and trx_cdcl class_decl =
+  {class_decl with ci_expr = trx_ce class_decl.ci_expr}
+
+and trx_ce class_expr =
+  {class_expr with cl_desc = trx_ce_desc class_expr.cl_desc}
+
+and trx_cl_struct cs =
+  {cs with cstr_fields = 
+     replace_list (fun cf -> {cf with cf_desc = trx_cf cf.cf_desc})
+                  cs.cstr_fields}
+
+and trx_ce_desc = function
+| Tcl_ident (_,_,_) -> raise Not_modified
+| Tcl_structure cs ->
+  Tcl_structure (trx_cl_struct cs)
+| Tcl_fun (l,p,el,ce,pa) ->
+  let (el,ce) = 
+        replace_pair (replace_list (fun (i,l,e) -> (i,l,trx_exp e)))
+                     trx_ce (el,ce) in
+  Tcl_fun (l,p,el,ce,pa)
+| Tcl_apply (ce,el) ->
+  let repel (l,eo,o) = (l,replace_opt trx_exp eo,o) in
+  let (ce,el) = replace_pair trx_ce (replace_list repel) (ce,el) in
+  Tcl_apply (ce,el)
+| Tcl_let (rf,el1,el2,ce) ->
+  let repel1 = replace_list (fun (p,e) -> (p,trx_exp e)) in
+  let repel2 = replace_list (fun (i,l,e) -> (i,l,trx_exp e)) in
+  let ((el1,el2),ce) = replace_pair (replace_pair repel1 repel2) trx_ce
+                        ((el1,el2),ce)
+  in Tcl_let (rf,el1,el2,ce)
+| Tcl_constraint (ce,ct,sl1,sl2,cty) ->
+  Tcl_constraint (trx_ce ce,ct,sl1,sl2,cty)
+
+and trx_cf = function
+| Tcf_inher (ofl,ce,so,sl1,sl2) ->
+  Tcf_inher (ofl,trx_ce ce,so,sl1,sl2)
+| Tcf_val (_,_,_,_,Tcfk_virtual _,_) -> raise Not_modified
+| Tcf_val (s,l,mf,i,Tcfk_concrete e,b) ->
+  Tcf_val (s,l,mf,i,Tcfk_concrete (trx_exp e),b)
+| Tcf_meth (s,l,pf,Tcfk_virtual _,_) -> raise Not_modified
+| Tcf_meth (s,l,pf,Tcfk_concrete e,b) ->
+  Tcf_meth (s,l,pf,Tcfk_concrete (trx_exp e),b)
+| Tcf_constr (_,_) -> raise Not_modified
+| Tcf_init e -> Tcf_init (trx_exp e)
+
+and trx_exp exp =
+  {exp with exp_desc = trx_expression exp.exp_desc}
+
+and trx_pelist l = replace_list (fun (p,e) -> (p,trx_exp e)) l
+and trx_expression = function
+| Texp_ident (_,_,_)
+| Texp_constant _ -> raise Not_modified
+| Texp_let (rf, el, e) ->
+  let (el,e) = replace_pair trx_pelist trx_exp (el,e)
+  in Texp_let (rf, el, e)
+| Texp_function (l,el,p) ->
+  Texp_function (l,trx_pelist el,p)
+| Texp_apply (e,el) ->
+  let repl (l,eo,op) = (l,replace_opt trx_exp eo,op) in
+  let (e,el) = replace_pair trx_exp (replace_list repl) (e,el)
+  in Texp_apply (e,el)
+| Texp_match (e,el,p) ->
+  let (e,el) = replace_pair trx_exp trx_pelist (e,el)
+  in Texp_match (e,el,p)
+| Texp_try (e,el) ->
+  let (e,el) = replace_pair trx_exp trx_pelist (e,el)
+  in Texp_try (e,el)
+| Texp_tuple l -> Texp_tuple (replace_list trx_exp l)
+| Texp_construct (l,cd,el,b) ->
+  Texp_construct (l,cd,replace_list trx_exp el,b)
+| Texp_variant (l,eo) -> Texp_variant (l,replace_opt trx_exp eo)
+| Texp_record (ll,eo) ->
+  let repll (l,ld,e) = (l,ld,trx_exp e) in
+  let (ll,eo) = replace_pair (replace_list repll) (replace_opt trx_exp) (ll,eo)
+  in Texp_record (ll,eo)
+| Texp_field (e,l,ld) -> Texp_field (trx_exp e,l,ld)
+| Texp_setfield (e1,l,ld,e2) ->
+  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
+  in Texp_setfield (e1,l,ld,e2)
+| Texp_array el -> Texp_array (replace_list trx_exp el)
+| Texp_ifthenelse (e1,e2,eo) ->
+  let ((e1,e2),eo) = replace_pair (replace_pair trx_exp trx_exp) 
+                                  (replace_opt trx_exp) ((e1,e2),eo)
+  in Texp_ifthenelse (e1,e2,eo)
+| Texp_sequence (e1,e2) -> 
+  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
+  in Texp_sequence (e1,e2)
+| Texp_while (e1,e2) ->
+  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
+  in Texp_while (e1,e2)
+| Texp_for (i,l,e1,e2,df,e3) ->
+  let ((e1,e2),e3) = replace_pair (replace_pair trx_exp trx_exp) 
+                                  trx_exp ((e1,e2),e3)
+  in Texp_for (i,l,e1,e2,df,e3)
+| Texp_when (e1,e2) ->
+  let (e1,e2) = replace_pair trx_exp trx_exp (e1,e2)
+  in Texp_when (e1,e2)
+| Texp_send (e1,m,eo) ->
+  let (e1,eo) = replace_pair trx_exp (replace_opt trx_exp) (e1,eo)
+  in Texp_send (e1,m,eo)
+| Texp_new (_,_,_)
+| Texp_instvar (_,_,_) -> raise Not_modified
+| Texp_setinstvar (p1,p2,l,e) -> Texp_setinstvar (p1,p2,l,trx_exp e)
+| Texp_override (p, el) ->
+  Texp_override (p, replace_list (fun (p,l,e) -> (p,l,trx_exp e)) el)
+| Texp_letmodule (i,l,me,e) ->
+  let (me,e) = replace_pair trx_me trx_exp (me,e)
+  in Texp_letmodule (i,l,me,e)
+| Texp_assert e -> Texp_assert (trx_exp e)
+| Texp_assertfalse -> raise Not_modified
+| Texp_lazy e -> Texp_lazy (trx_exp e)
+| Texp_object (cs,sl) -> Texp_object (trx_cl_struct cs,sl)
+| Texp_pack me -> Texp_pack (trx_me me)
+
+| Texp_bracket e -> 
+   let trx_exp e = try trx_exp e with Not_modified -> e in
+  (trx_bracket trx_exp 1 e).exp_desc
+
+| Texp_escape _ -> assert false         (* Not possible in well-typed code *)
+| Texp_cspval (_,_) -> raise Not_modified
+
+
+(* public interface *)
+let trx_structure str = 
+  try trx_struct str with Not_modified -> str
+
+(*}}}*)
+
+  
diff --git a/typing/trx.mli b/typing/trx.mli
new file mode 100644
index 0000000..4990889
--- /dev/null
+++ b/typing/trx.mli
@@ -0,0 +1,128 @@
+(* BER MetaOCaml compilation
+   Transforming the Typedtree to eliminate brackets and escapes,
+   replacing them with calls to ordinary OCaml functions
+   to build the code representation (that is, Parsetree).
+*)
+
+val meta_version : string
+(** [meta_version] is the version of BER MetaOCaml*)
+
+(* The function to post-process the typed tree and translate away
+   brackets and escapes 
+*)
+val trx_structure: Typedtree.structure -> Typedtree.structure
+
+(* The following functions operate on untyped code_repr.
+   We cannot use the type constructor 'code' here since
+   it is not available in the bootstrap compiler.
+*)
+
+(* The representation of possibly code: abstract *)
+type code_repr
+
+type closed_code_repr = private Parsetree.expression
+
+(* Check that the code is closed and return the closed code *)
+val close_code_repr : code_repr -> closed_code_repr
+
+(* The same as close_code but return the closedness check as a thunk
+   rather than performing it.
+   This is useful for debugging and for showing the code:
+   If there is a scope extrusion error, it is still useful
+   to show the code with the extrusion before throwing the scope-extrusion
+   exception.
+*)
+val close_code_delay_check : code_repr -> closed_code_repr * (unit -> unit)
+
+(* Total: a closed code can always be used in slices, etc. *)
+val open_code : closed_code_repr -> code_repr
+
+(* Adjusting the implementation of stackmarks -- needed when delimited
+   control is used (other than mere exceptions).
+*)
+type stackmark = unit -> bool           (* true if valid *)
+type stackmark_region_fn = 
+    {stackmark_region_fn : 'w. (stackmark -> 'w) -> 'w}
+val set_with_stack_mark : stackmark_region_fn -> unit
+
+
+(* The following names are used by Trx itself to construct a Parsetree
+   or as templates to build the Typedtree.
+   Trx may generate code the refers to the functions below.
+   Therefore, do NOT rename the functions or change their types!
+*)
+
+val sample_lid  : Longident.t Location.loc  (* A template for lid expressions *)
+val sample_loc  : Location.t
+val sample_name : string Location.loc
+val sample_pat_list : Parsetree.pattern list
+val sample_pats_names : Parsetree.pattern list * string Location.loc list
+val sample_rec_flag : Asttypes.rec_flag
+val sample_override_flag : Asttypes.override_flag
+
+        (* Run-time quotator *)
+val dyn_quote  : Obj.t -> Longident.t Location.loc -> code_repr
+
+val lift_constant_int  : int  -> code_repr
+val lift_constant_char : char -> code_repr
+val lift_constant_bool : bool -> code_repr
+
+(* Builders of the Parsetree *)
+val build_assert   : Location.t -> code_repr -> code_repr
+val build_lazy     : Location.t -> code_repr -> code_repr
+val build_bracket  : Location.t -> code_repr -> code_repr
+val build_escape   : Location.t -> code_repr -> code_repr
+
+val build_sequence : Location.t -> code_repr -> code_repr -> code_repr
+val build_while    : Location.t -> code_repr -> code_repr -> code_repr
+val build_when     : Location.t -> code_repr -> code_repr -> code_repr
+
+val build_apply : Location.t -> (Asttypes.label * code_repr) array -> code_repr
+
+val build_tuple : Location.t -> code_repr array -> code_repr
+val build_array : Location.t -> code_repr array -> code_repr
+val build_ifthenelse : 
+  Location.t -> code_repr -> code_repr -> code_repr option -> code_repr
+val build_construct  :
+ Location.t -> Longident.t Location.loc -> code_repr array -> bool -> code_repr
+val build_record :
+ Location.t -> (Longident.t Location.loc * code_repr) array ->
+ code_repr option -> code_repr
+val build_field :
+ Location.t -> code_repr -> Longident.t Location.loc -> code_repr
+val build_setfield :
+ Location.t -> code_repr -> Longident.t Location.loc -> code_repr -> code_repr
+val build_variant  : Location.t -> string -> code_repr option -> code_repr
+val build_send     : Location.t -> code_repr -> string -> code_repr
+val build_open :
+ Location.t -> Longident.t Location.loc -> Asttypes.override_flag -> 
+   code_repr -> code_repr
+val build_fun_nonbinding : 
+  Location.t -> string -> Parsetree.pattern list -> 
+  code_repr array -> code_repr
+
+val build_fun_simple : 
+  Location.t -> string -> string Location.loc -> 
+  (code_repr -> code_repr) -> code_repr
+val build_for : 
+  Location.t -> string Location.loc -> code_repr -> code_repr -> 
+  bool -> (code_repr -> code_repr) -> code_repr
+val build_let_simple_nonrec : 
+  Location.t -> string Location.loc -> bool -> code_repr -> 
+    (code_repr -> code_repr) -> code_repr
+val build_letrec : 
+  Location.t -> string Location.loc array -> 
+    (code_repr array -> code_repr array) -> code_repr
+val build_fun : Location.t -> string -> 
+  (Parsetree.pattern list * string Location.loc list) -> 
+  (code_repr array -> code_repr array) -> code_repr
+val build_let : 
+  Location.t -> bool -> 
+  (Parsetree.pattern list * string Location.loc list) -> code_repr array ->
+  (code_repr array -> code_repr array) -> code_repr
+val build_match : 
+  Location.t -> (Parsetree.pattern list * string Location.loc list) -> 
+  code_repr -> (code_repr array -> code_repr array) -> code_repr
+val build_try : 
+  Location.t -> (Parsetree.pattern list * string Location.loc list) -> 
+  code_repr -> (code_repr array -> code_repr array) -> code_repr
diff --git a/typing/typecore.ml b/typing/typecore.ml
index 2964f3f..21cc004 100644
--- a/typing/typecore.ml
+++ b/typing/typecore.ml
@@ -63,6 +63,7 @@ type error =
   | Recursive_local_constraint of (type_expr * type_expr) list
   | Unexpected_existential
   | Unqualified_gadt_pattern of Path.t * string
+  | Trx_error of (Format.formatter -> unit)               (* NNN *)
 
 exception Error of Location.t * Env.t * error
 
@@ -88,6 +89,81 @@ let type_object =
        Env.t -> Location.t -> Parsetree.class_structure ->
          Typedtree.class_structure * Types.class_signature * string list)
 
+(* NNN: begin
+  The current stage level.
+  Type-checking the body of a bracket increases the level
+  type-checking of an escape decreases.
+  Be sure to reset upon any exception;
+  alternatively; reset when beginning a new type-level
+  expression or binding
+  (whenever you do Typetexp.reset_type_variables();)
+
+ Check all instances of Env.add_value amd make sure that
+ we record the stage of every identifier that is added to the
+ value env (unless the stage is 0).
+*)
+let global_stage : Env.stage ref  = ref 0
+
+(* Obsolete; kept for reference 
+
+  The list of active classifiers. The length of the list
+  is the level of an expression.
+  Type-checking the body of a bracket adds a type variable
+  to the list; type-checking of an escape removes the
+  top-most classifier.
+  Be sure to reset this list upon any exception;
+  alternatively; reset the list when beginning a new type-level
+  expression or binding
+  (whenever you do Typetexp.reset_type_variables();)
+
+let global_stage : Env.stage ref  = ref []
+
+   Unify classifier lists, *right-to-left*
+   See the bug Tue Jan 20 12:18:00 GMTST 2004 in XXCC-BUG-OPEN-FIXED
+   why we need this order.
+   The current classifier is left-most, and the lists don't have
+   to have the same length.
+   Example:
+   .<fun x -> .< x >. >.
+   When type-checking the innermost bracket, the global_stage
+   will contain ['b,'a] and the level of x will be ['a]
+   The unification will succeed, without changing anything, as expected.
+
+let unify_stage env tl1 tl2 =
+   let rec loop = function
+   | (t1::tl1,t2::tl2) -> unify env t1 t2; loop (tl1,tl2)
+   | _ -> ()
+   in loop (List.rev tl1, List.rev tl2)
+*)
+open Format
+
+let raise_wrong_stage_error loc env n m =
+  raise (Error(loc, env, Trx_error (fun ppf ->
+	fprintf ppf 
+         "Wrong level: variable bound at level %d and used at level %d" n m)))
+
+let with_stage_up body =
+   let old_stage = !global_stage in
+   let () = incr global_stage in
+   try 
+    let r = body () in
+    global_stage := old_stage; r
+   with e ->
+   global_stage := old_stage; raise e
+
+let with_stage_down loc env body =
+   let old_stage = !global_stage in
+   if !global_stage = 0 then
+     raise (Error (loc, env, Trx_error (fun ppf ->
+       fprintf ppf "Wrong level: escape at level 0")));
+   decr global_stage;
+   try 
+    let r = body () in
+    global_stage := old_stage; r
+   with e ->
+   global_stage := old_stage; raise e
+(* NNN end *)
+
 (*
   Saving and outputting type information.
   We keep these function names short, because they have to be
@@ -150,6 +226,8 @@ let iter_expression f e =
     | Pexp_letmodule (_, me, e) -> expr e; module_expr me
     | Pexp_object { pcstr_fields = fs } -> List.iter class_field fs
     | Pexp_pack me -> module_expr me
+    | Pexp_bracket e | Pexp_escape e -> expr e (* NNN *)
+    | Pexp_cspval (_, _) -> ()                 (* NNN *)
 
   and module_expr me =
     match me.pmod_desc with
@@ -1161,13 +1239,16 @@ let rec iter3 f lst1 lst2 lst3 =
   | _ ->
       assert false
 
+
 let add_pattern_variables ?check ?check_as env =
   let pv = get_ref pattern_variables in
   (List.fold_right
      (fun (id, ty, name, loc, as_var) env ->
        let check = if as_var then check_as else check in
+       Env.add_stage id !global_stage ( (* NNN *)
        Env.add_value ?check id
          {val_type = ty; val_kind = Val_reg; Types.val_loc = loc} env
+       )                                              (* NNN *)
      )
      pv env,
    get_ref module_variables)
@@ -1207,6 +1288,9 @@ let type_class_arg_pattern cl_num val_env met_env l spat =
            else Warnings.Unused_var_strict s in
          let id' = Ident.create (Ident.name id) in
          ((id', name, id, ty)::pv,
+	  (* NNN we don't do Env.add_stage id' 0
+	     since we don't handle classes within brackets.
+	   *)
           Env.add_value id' {val_type = ty;
                              val_kind = Val_ivar (Immutable, cl_num);
                              Types.val_loc = loc;
@@ -1234,6 +1318,10 @@ let type_self_pattern cl_num privty val_env met_env par_env spat =
   pattern_variables := [];
   let (val_env, met_env, par_env) =
     List.fold_right
+	  (* NNN we don't do Env.add_stage id 0 for all
+	     Env.add_value below
+	     since we don't handle classes within brackets.
+	   *)
       (fun (id, ty, name, loc, as_var) (val_env, met_env, par_env) ->
          (Env.add_value id {val_type = ty;
                             val_kind = Val_unbound;
@@ -1330,6 +1418,8 @@ let rec is_nonexpansive exp =
       is_nonexpansive_mod mexp && is_nonexpansive e
   | Texp_pack mexp ->
       is_nonexpansive_mod mexp
+  | Texp_bracket e -> is_nonexpansive e     (* NNN *)
+  | Texp_escape e  -> is_nonexpansive e     (* NNN *)
   | _ -> false
 
 and is_nonexpansive_mod mexp =
@@ -1786,6 +1876,9 @@ let duplicate_ident_types loc caselist env =
            I don't think this is what we want *)
         let (path, desc) = Env.lookup_value (Longident.Lident s) env in
         match path with
+        (* NNN since id is already known in the Env, its stage is
+           already recorded.
+         *)
           Path.Pident id ->
             let desc = {desc with val_type = correct_levels desc.val_type} in
             Env.add_value id desc env
@@ -1836,6 +1929,11 @@ and type_expect_ ?in_function env sexp ty_expected =
           let name = Path.name ~paren:Oprint.parenthesized_ident path in
           Stypes.record (Stypes.An_ident (loc, name, annot))
         end;
+        let stage =				(* NNN begin *)
+              try snd (Env.lookup_stage lid.txt env)
+              with Not_found -> 0
+        in                                      (* NNN end *)
+	(* unify_stage env stage !global_stage;	 NNN old *)
         rue {
           exp_desc =
             begin match desc.val_kind with
@@ -1855,9 +1953,13 @@ and type_expect_ ?in_function env sexp ty_expected =
             | Val_unbound ->
                 raise(Error(loc, env, Masked_instance_variable lid.txt))
             | _ ->
+              if stage > !global_stage then                          (* NNN *)
+                 raise_wrong_stage_error loc env stage !global_stage (* NNN *)
+	      else                                                   (* NNN *)
                 Texp_ident(path, lid, desc)
           end;
           exp_loc = loc; exp_extra = [];
+(* NNN:  Instantiates type scheme to a type *)
           exp_type = instance env desc.val_type;
           exp_env = env }
       end
@@ -2017,6 +2119,51 @@ and type_expect_ ?in_function env sexp ty_expected =
         exp_loc = loc; exp_extra = [];
         exp_type = ty_res;
         exp_env = env }
+
+       (* NNN:  Typechecking bracket *)
+       (* follow Pexp_array or Pexp_lazy as a template *)
+       (* Expected type: ty code where ty is the type
+          of the expression within brackets.
+        *)
+  | Pexp_bracket(sexp) ->   
+      let ty = newgenvar() in     (* expected type for the bracketed sexp *)
+      let to_unify = Predef.type_code ty in
+      unify_exp_types loc env to_unify ty_expected;
+      with_stage_up (fun () ->
+      let exp = type_expect env sexp ty in
+        re { 
+          exp_desc = Texp_bracket(exp);
+          exp_loc = loc; exp_extra = [];
+          exp_type = instance env ty_expected;
+          exp_env = env })
+       (* NNN:  Typechecking escapes *)
+       (* If ~e is expected to have the type ty then
+          e is expected to have the type ty code
+        *)
+  | Pexp_escape(sexp) ->    
+      with_stage_down loc env (fun () ->
+       let sexp_ty_expected = Predef.type_code ty_expected in
+       let exp = type_expect env sexp sexp_ty_expected in
+       re { 
+         exp_desc = Texp_escape(exp);
+         exp_loc = loc; exp_extra = [];
+         exp_type = instance env ty_expected;
+         exp_env = env })
+       (* The rule says that CSP can have any desired type.
+          Pexp_cspval nodes are added only by the builder of
+          code expressions, by the builder of AST in trx.ml
+         At that time we know that the expression that gave
+         rise to CSP had the correct type. Therefore, we trust
+         that the type was correct the first time around.
+         The second argument, li, is used for identification only.
+        *)
+  | Pexp_cspval(obj,li) ->
+     re { 
+        exp_desc = Texp_cspval(obj,li);
+        exp_loc = loc; exp_extra = [];
+        exp_type = instance env ty_expected;
+        exp_env = env }
+       (* NNN end *)
   | Pexp_match(sarg, caselist) ->
       begin_def ();
       let arg = type_exp env sarg in
@@ -2257,6 +2404,8 @@ and type_expect_ ?in_function env sexp ty_expected =
           val_kind = Val_reg; Types.val_loc = loc; } env
           ~check:(fun s -> Warnings.Unused_for_index s)
       in
+      let (id, new_env) =				  (* NNN *)
+          (id, Env.add_stage id !global_stage new_env) in (* NNN *)
       let body = type_statement new_env sbody in
       rue {
         exp_desc = Texp_for(id, param, low, high, dir, body);
@@ -2405,6 +2554,10 @@ and type_expect_ ?in_function env sexp ty_expected =
                   let (obj_ty, res_ty) = filter_arrow env method_type "" in
                   unify env obj_ty desc.val_type;
                   unify env res_ty (instance env typ);
+                  (* NNN Texp_ident should've been accompanied by
+		     Env.add_level id !global_level
+		     But we don't support staging for objects.
+		   *)
                   let exp =
                     Texp_apply({exp_desc =
                                 Texp_ident(Path.Pident method_id, lid,
@@ -2475,6 +2628,9 @@ and type_expect_ ?in_function env sexp ty_expected =
               exp_env = env }
         end
   | Pexp_setinstvar (lab, snewval) ->
+      if !global_stage != 0 then                                      (* NNN *)
+        raise (Error (loc, env, Trx_error (fun ppf ->                 (* NNN *)
+          fprintf ppf "Setinstvar not supported within brackets")));  (* NNN *)
       begin try
         let (path, desc) = Env.lookup_value (Longident.Lident lab.txt) env in
         match desc.val_kind with
@@ -2498,6 +2654,9 @@ and type_expect_ ?in_function env sexp ty_expected =
           raise(Error(loc, env, Unbound_instance_variable lab.txt))
       end
   | Pexp_override lst ->
+      if !global_stage != 0 then                                    (* NNN *)
+        raise (Error (loc, env, Trx_error (fun ppf ->               (* NNN *)
+          fprintf ppf "Override not supported within brackets")));  (* NNN *)
       let _ =
        List.fold_right
         (fun (lab, _) l ->
@@ -2535,6 +2694,9 @@ and type_expect_ ?in_function env sexp ty_expected =
           assert false
       end
   | Pexp_letmodule(name, smodl, sbody) ->
+      if !global_stage != 0 then                                    (* NNN *)
+        raise (Error (loc, env, Trx_error (fun ppf ->               (* NNN *)
+          fprintf ppf "Letmodule not supported within brackets"))); (* NNN *)
       let ty = newvar() in
       (* remember original level *)
       begin_def ();
@@ -2824,6 +2986,10 @@ and type_argument env sarg ty_expected' ty_expected =
       unify_exp env {texp with exp_type = ty_fun} ty_expected;
       if args = [] then texp else
       (* eta-expand to avoid side effects *)
+      (* NNN Every Texp_ident below should've been accompanied by
+	 Env.add_stage. But we don't support staging for
+	 optional and named parameters.
+       *)
       let var_pair name ty =
         let id = Ident.create name in
         {pat_desc = Tpat_var (id, mknoloc name); pat_type = ty;pat_extra=[];
@@ -3414,6 +3580,7 @@ and type_let ?(check = fun s -> Warnings.Unused_var s)
 
 let type_binding env rec_flag spat_sexp_list scope =
   Typetexp.reset_type_variables();
+  global_stage := 0;			(* NNN *)
   let (pat_exp_list, new_env, unpacks) =
     type_let
       ~check:(fun s -> Warnings.Unused_value_declaration s)
@@ -3431,6 +3598,7 @@ let type_let env rec_flag spat_sexp_list scope =
 
 let type_expression env sexp =
   Typetexp.reset_type_variables();
+  global_stage := 0;			(* NNN *)
   begin_def();
   let exp = type_exp env sexp in
   end_def();
@@ -3640,6 +3808,8 @@ let report_error env ppf = function
       fprintf ppf "@[The GADT constructor %s of type %a@ %s.@]"
         name path tpath
         "must be qualified in this pattern"
+(* NNN through the end of the pattern-match *)
+  | Trx_error fn -> fn ppf              (* NNN *)
 
 let report_error env ppf err =
   wrap_printing_env env (fun () -> report_error env ppf err)
diff --git a/typing/typecore.mli b/typing/typecore.mli
index 8840a34..2cbe02a 100644
--- a/typing/typecore.mli
+++ b/typing/typecore.mli
@@ -105,6 +105,7 @@ type error =
   | Recursive_local_constraint of (type_expr * type_expr) list
   | Unexpected_existential
   | Unqualified_gadt_pattern of Path.t * string
+  | Trx_error of (Format.formatter -> unit)               (* NNN *)
 
 exception Error of Location.t * Env.t * error
 
diff --git a/typing/typedtree.ml b/typing/typedtree.ml
index 405e56b..74ad6aa 100644
--- a/typing/typedtree.ml
+++ b/typing/typedtree.ml
@@ -100,6 +100,10 @@ and expression_desc =
   | Texp_lazy of expression
   | Texp_object of class_structure * string list
   | Texp_pack of module_expr
+(* NNN through the rest of the definition of expression *)
+  | Texp_bracket of expression
+  | Texp_escape of expression
+  | Texp_cspval of Obj.t * Longident.t loc
 
 and meth =
     Tmeth_name of string
diff --git a/typing/typedtree.mli b/typing/typedtree.mli
index a263c90..8c3d237 100644
--- a/typing/typedtree.mli
+++ b/typing/typedtree.mli
@@ -99,6 +99,10 @@ and expression_desc =
   | Texp_lazy of expression
   | Texp_object of class_structure * string list
   | Texp_pack of module_expr
+(* NNN through the rest of the definition of expression *)
+  | Texp_bracket of expression
+  | Texp_escape of expression
+  | Texp_cspval of Obj.t * Longident.t loc
 
 and meth =
     Tmeth_name of string
diff --git a/typing/typedtreeIter.ml b/typing/typedtreeIter.ml
index 4280826..0badaf6 100644
--- a/typing/typedtreeIter.ml
+++ b/typing/typedtreeIter.ml
@@ -322,6 +322,10 @@ module MakeIterator(Iter : IteratorArgument) : sig
             iter_class_structure cl
         | Texp_pack (mexpr) ->
             iter_module_expr mexpr
+        (* NNN: through the rest of the expression *)
+        | Texp_bracket exp -> iter_expression exp
+        | Texp_escape  exp -> iter_expression exp
+        | Texp_cspval (_, li) -> ()
       end;
       Iter.leave_expression exp;
 
diff --git a/typing/typedtreeMap.ml b/typing/typedtreeMap.ml
index 7c8c633..9a1fb53 100644
--- a/typing/typedtreeMap.ml
+++ b/typing/typedtreeMap.ml
@@ -344,6 +344,10 @@ module MakeMap(Map : MapArgument) = struct
           Texp_object (map_class_structure cl, string_list)
         | Texp_pack (mexpr) ->
           Texp_pack (map_module_expr mexpr)
+        (* NNN: through the rest of the expression *)
+        | Texp_bracket exp -> Texp_bracket (map_expression exp)
+        | Texp_escape  exp -> Texp_escape  (map_expression exp)
+        | Texp_cspval (_, li) -> exp.exp_desc
     in
     let exp_extra = List.map map_exp_extra exp.exp_extra in
     Map.leave_expression {
diff --git a/typing/typemod.ml b/typing/typemod.ml
index 7cbda25..a2f1b03 100644
--- a/typing/typemod.ml
+++ b/typing/typemod.ml
@@ -1151,10 +1151,31 @@ and type_structure ?(toplevel = false) funct_body anchor env sstr scope =
     (Cmt_format.Partial_structure str :: previous_saved_types);
   str, sg, final_env
 
+(* NNN begin
+Hook up the Trx post-processing
+old
 let type_toplevel_phrase env s =
   type_structure ~toplevel:true false None env s Location.none
+*)
+let type_toplevel_phrase env s = 
+  let (str, sg, finalenv) = 
+    type_structure ~toplevel:true false None env s Location.none
+  in 
+  (Trx.trx_structure str, sg, finalenv)
+(* NNN end *)
+
 let type_module = type_module true false None
-let type_structure = type_structure false None
+(* NNN begin
+Hook up the Trx post-processing
+old
+ let type_structure = type_structure false None
+*)
+let type_structure env sstr scope = 
+  let (str, sg, finalenv) = type_structure false None env sstr scope
+  in 
+  (Trx.trx_structure str, sg, finalenv)
+(* NNN end *)
+
 
 (* Normalize types in a signature *)
 
